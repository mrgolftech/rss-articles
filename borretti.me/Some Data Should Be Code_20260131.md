# Some Data Should Be Code

**来源:** [borretti.me](https://borretti.me)
**发布时间:** Sat, 31 Jan 2026 00:00:00 +0000
**链接:** https://borretti.me/article/some-data-should-be-code

---

{'type': 'text/html', 'language': None, 'base': 'https://borretti.me/feed.xml', 'value': '<p>I write a lot of <a href="https://en.wikipedia.org/wiki/Make_(software)">Makefiles</a>. I use it not as a command runner but as an ad-hoc build system for small projects, typically for compiling Markdown documents and their dependencies. Like so:</p>\n\n<p><img alt="A build graph for a document. A central node `doc.md` represents the Markdown source. Two outgoing arrows point to `doc.html` and `doc.pdf`, representing the output format. A chain through `graph.dot`, `graph.png`, and `doc.md` represets how a Graphviz .dot file can be rendered to PNG. A chain through `data.csv`, `plot.py`, `plot.png`, and `doc.md` represents using a Python script to make a plot from a CSV file." src="https://borretti.me/assets/content/some-data-should-be-code/graph.png" style="margin-left: auto; margin-right: auto; width: 300px;" /></p>\n\n<p>And the above graph was generated by this very simple Makefile:</p>\n\n<div class="language-makefile highlighter-rouge">\n  <div class="highlight">\n    <pre class="highlight"><code><span class="nl">graph.png</span><span class="o">:</span> <span class="nf">graph.dot</span>\n    <span class="err">dot</span> <span class="err">-Tpng</span> <span class="err">$&lt;</span> <span class="err">-o</span> <span class="err">$@</span>\n\n<span class="nl">clean</span><span class="o">:</span>\n    <span class="err">rm</span> <span class="err">-f</span> <span class="err">graph.png</span>\n</code></pre>\n  </div>\n</div>\n\n<p>(I could never remember the <a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html">automatic variable</a> syntax until I made <a href="https://github.com/eudoxia0/flashcards/blob/aefae3ed874627201dbcedec045095779691d323/Cards/make.md">flashcards</a> for them.)</p>\n\n<p>It works for simple projects, when you can mostly hand-write the rules. But the abstraction ceiling is very low. If you have a bunch of almost identical rules, e.g.:</p>\n\n<div class="language-makefile highlighter-rouge">\n  <div class="highlight">\n    <pre class="highlight"><code><span class="nl">a.png</span><span class="o">:</span> <span class="nf">a.csv plot.py</span>\n    <span class="err">python</span> <span class="err">plot.py</span> <span class="err">$&lt;</span> <span class="err">$@</span>\n\n<span class="nl">b.png</span><span class="o">:</span> <span class="nf">b.csv plot.py</span>\n    <span class="err">python</span> <span class="err">plot.py</span> <span class="err">$&lt;</span> <span class="err">$@</span>\n\n<span class="nl">c.png</span><span class="o">:</span> <span class="nf">c.csv plot.py</span>\n    <span class="err">python</span> <span class="err">plot.py</span> <span class="err">$&lt;</span> <span class="err">$@</span>\n</code></pre>\n  </div>\n</div>\n\n<p>You can use pattern-matching to them into a “rule schema”, by analogy to axiom schemata:</p>\n\n<div class="language-makefile highlighter-rouge">\n  <div class="highlight">\n    <pre class="highlight"><code><span class="nl">%.png</span><span class="o">:</span> <span class="nf">%.csv plot.py</span>\n    <span class="err">python</span> <span class="err">plot.py</span> <span class="err">$&lt;</span> <span class="err">$@</span>\n</code></pre>\n  </div>\n</div>\n\n<p>Which works backwards: when something in the build graph depends on a target matching <code class="language-plaintext highlighter-rouge">%.png</code>, Make synthesizes a rule instance with a dependency on the corresponding <code class="language-plaintext highlighter-rouge">.csv</code> file.</p>\n\n<p>But pattern matching is still very limited. Lately I’ve been building my own <a href="https://plaintextaccounting.org/">plain-text accounting</a> solution using some Python scripts. One of the tasks is to read a CSV of bank transactions from 2019–2024 and split it into TOML files for each year-month, to make subsequent processing parallelizable. So the rules might be something like:</p>\n\n<pre><code class="language-makefile:">ledger/2019-08.toml: inputs/checkbook_pro_export.csv\n    uv run import_from_checkbook.py --year=2019 --month=8\n\nledger/2019-09.toml: inputs/checkbook_pro_export.csv\n    uv run import_from_checkbook.py --year=2019 --month=9\n\n# ...\n</code></pre>\n\n<p>I had to write a Python script to generate the complete Makefile. Makefiles look like code, but are data: they are a container format for tiny fragments of shell that are run on-demand by the Make engine. And because Make doesn’t scale, for complex tasks you have to bring out a real programming language to generate the Makefile.</p>\n\n<p>I wish I could, instead, write a <code class="language-plaintext highlighter-rouge">make.py</code> file with something like this:</p>\n\n<div class="language-python highlighter-rouge">\n  <div class="highlight">\n    <pre class="highlight"><code><span class="kn">from</span> <span class="nn">whatever</span> <span class="kn">import</span> <span class="o">*</span>\n\n<span class="n">g</span> <span class="o">=</span> <span class="n">BuildGraph</span><span class="p">()</span>\n\n<span class="n">EXPORT</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"inputs/checkbook_pro_export.csv"</span>\n\n<span class="c1"># The (year, month) pairs I have bank transaction CSVs for.\n</span><span class="n">year_months</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span>\n    <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2019</span><span class="p">,</span> <span class="mi">2026</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>\n<span class="p">]</span>\n\n<span class="c1"># Import transactions for each year-month into a separate ledger.\n</span><span class="k">for</span> <span class="n">year</span><span class="p">,</span> <span class="n">month</span> <span class="ow">in</span> <span class="n">year_months</span><span class="p">:</span>\n    <span class="n">ledger_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sa">f</span><span class="s">"ledger/</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s">_</span><span class="si">{</span><span class="n">month</span><span class="si">:</span><span class="mi">02</span><span class="n">d</span><span class="si">}</span><span class="s">.toml"</span>\n    <span class="n">g</span><span class="p">.</span><span class="n">rule</span><span class="p">(</span>\n        <span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="n">ledger_path</span><span class="p">],</span>\n        <span class="n">deps</span><span class="o">=</span><span class="p">[</span><span class="n">EXPORT</span><span class="p">],</span>\n        <span class="n">fn</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">import_from_checkbook</span><span class="p">(</span><span class="n">ledger_path</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">),</span>\n    <span class="p">)</span>\n</code></pre>\n  </div>\n</div>\n\n<p>Fortunately this exists: it’s called <a href="https://pydoit.org/">doit</a>, but it’s not widely known.</p>\n\n<hr />\n\n<p>A lot of things are like Makefiles: data that should be lifted one level up to become code.</p>\n\n<p>Consider <a href="https://en.wikipedia.org/wiki/AWS_CloudFormation">CloudFormation</a>. Nobody likes writing those massive YAML files by hand, so AWS introduced <a href="https://en.wikipedia.org/wiki/AWS_Cloud_Development_Kit">CDK</a>, which is literally just a library<sup id="fnref:fn1"><a class="footnote" href="https://borretti.me/feed.xml#fn:fn1" rel="footnote">1</a></sup> of classes that represent AWS resources. Running a CDK program emits CloudFormation YAML as though it were an assembly language for infrastructure. And so you get type safety, modularity, abstraction, conditionals and loops, all for free.</p>\n\n<p>Consider <a href="https://docs.github.com/en/actions">GitHub Actions</a>. How much better off would we be if, instead of writing the workflow-job-step tree by hand, we could just have a single Python script, executed on push, whose output is the GitHub Actions YAML-as-assembly? So you might write:</p>\n\n<div class="language-python highlighter-rouge">\n  <div class="highlight">\n    <pre class="highlight"><code><span class="kn">from</span> <span class="nn">ga</span> <span class="kn">import</span> <span class="o">*</span>\n<span class="kn">from</span> <span class="nn">checkout_action</span> <span class="kn">import</span> <span class="n">CheckoutAction</span>\n<span class="kn">from</span> <span class="nn">rust_action</span> <span class="kn">import</span> <span class="n">RustSetupAction</span>\n\n<span class="c1"># Define the workflow that runs on each commit.\n</span><span class="n">commit_workflow</span> <span class="o">=</span> <span class="n">Workflow</span><span class="p">(</span>\n    <span class="n">name</span><span class="o">=</span><span class="s">"commit"</span><span class="p">,</span>\n    <span class="n">test</span><span class="o">=</span><span class="k">lambda</span> <span class="n">ev</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ev</span><span class="p">,</span> <span class="n">CommitEvent</span><span class="p">),</span>\n    <span class="n">jobs</span><span class="o">=</span><span class="p">[</span>\n        <span class="c1"># The lint job.\n</span>        <span class="n">Job</span><span class="p">(</span>\n            <span class="n">name</span><span class="o">=</span><span class="s">"lint"</span><span class="p">,</span>\n            <span class="n">steps</span><span class="o">=</span><span class="p">[</span>\n                <span class="n">Step</span><span class="p">(</span>\n                    <span class="n">name</span><span class="o">=</span><span class="s">"check out"</span><span class="p">,</span>\n                    <span class="n">run</span><span class="o">=</span><span class="n">CheckoutAction</span><span class="p">(),</span>\n                <span class="p">),</span>\n                <span class="n">Step</span><span class="p">(</span>\n                    <span class="n">name</span><span class="o">=</span><span class="s">"set up Rust and Cargo"</span><span class="p">,</span>\n                    <span class="n">run</span><span class="o">=</span><span class="n">RustSetupAction</span><span class="p">(),</span>\n                <span class="p">),</span>\n                <span class="n">Step</span><span class="p">(</span>\n                    <span class="n">name</span><span class="o">=</span><span class="s">"run cargo fmt"</span><span class="p">,</span>\n                    <span class="n">run</span><span class="o">=</span><span class="n">Shell</span><span class="p">([</span><span class="s">"cargo"</span><span class="p">,</span> <span class="s">"fmt"</span><span class="p">,</span> <span class="s">"--check"</span><span class="p">])</span>\n                <span class="p">)</span>\n            <span class="p">]</span>\n        <span class="p">)</span>\n    <span class="p">]</span>\n<span class="p">)</span>\n</code></pre>\n  </div>\n</div>\n\n<p>Actions here would simply be ordinary Python libraries the CI script depends on. Again: conditions, loops, abstraction, type safety, we get all of those for free by virtue of using a language that was designed to be a language, rather than a data exchange language that slowly grows into a poorly-designed DSL.</p>\n\n<p>Why do we repeatedly end up here? Static data has better safety/static analysis properties than code, but I don’t think that’s foremost in mind when people design these systems. Besides, using code to emit data (as CDK does) gives you those exact same properties. Rather, I think some people think it’s cute and clever to build tiny DSLs in a data format. They’re proud that they can get away with a “simple”, static solution rather than a dynamic one.</p>\n\n<p>If you’re building a new CI system/IaC platform/Make replacement: please just let me write code to dynamically create the workflow/infrastructure/build graph.</p>\n\n<h1 id="footnotes">Footnotes</h1>\n\n<div class="footnotes">\n  <ol>\n    <li id="fn:fn1">\n\n      <p>Or rather, a polyglot collection of libraries, one per language, like <a href="https://en.wikipedia.org/wiki/Pulumi">Pulumi</a>.\xa0<a class="reversefootnote" href="https://borretti.me/feed.xml#fnref:fn1">&#8617;</a></p>\n    </li>\n  </ol>\n</div>'}

---

*抓取时间: 2026-02-06 06:02:39*
