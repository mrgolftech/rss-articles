
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="技术博客文章聚合 - Hacker News 2025年最受欢迎的博客">
      
      
        <meta name="author" content="OpenClaw">
      
      
        <link rel="canonical" href="https://mrgolftech.github.io/rss-articles/chiark.greenend.org.uk/~sgtatham/Aperiodic%20Tilings%20V-%20the%20Refinable%20Frontier_20260205/">
      
      
      
      
        
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.1">
    
    
      
        <title>Aperiodic Tilings V: the Refinable Frontier - Hacker News 精选博客</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.484c7ddc.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      
  


    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#aperiodic-tilings-v-the-refinable-frontier" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="Hacker News 精选博客" class="md-header__button md-logo" aria-label="Hacker News 精选博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Hacker News 精选博客
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Aperiodic Tilings V: the Refinable Frontier
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="切换到深色模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换到深色模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="切换到浅色模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换到浅色模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="分享" aria-label="分享" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/mrgolftech/rss-articles" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    rss-articles
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../.." class="md-tabs__link">
        
  
  
    
  
  首页

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../../blogs/" class="md-tabs__link">
        
  
  
    
  
  所有博客

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Hacker News 精选博客" class="md-nav__button md-logo" aria-label="Hacker News 精选博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Hacker News 精选博客
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/mrgolftech/rss-articles" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    rss-articles
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    首页
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../blogs/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    所有博客
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  


  
    <a href="https://github.com/mrgolftech/rss-articles/edit/master/docs/chiark.greenend.org.uk/~sgtatham/Aperiodic Tilings V- the Refinable Frontier_20260205.md" title="编辑此页" class="md-content__button md-icon" rel="edit">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75z"/></svg>
    </a>
  
  


<h1 id="aperiodic-tilings-v-the-refinable-frontier">Aperiodic Tilings V: the Refinable Frontier<a class="headerlink" href="#aperiodic-tilings-v-the-refinable-frontier" title="Permanent link">&para;</a></h1>
<p><strong>来源:</strong> https://chiark.greenend.org.uk/~sgtatham
<strong>链接:</strong> https://www.chiark.greenend.org.uk/~sgtatham/quasiblog/aperiodic-refine/
<strong>日期:</strong> 2025-09-02T00:00:00+00:00</p>
<hr />
<h1 id="aperiodic-tilings-v-the-refinable-frontier_1">Aperiodic Tilings V: the Refinable Frontier<a class="headerlink" href="#aperiodic-tilings-v-the-refinable-frontier_1" title="Permanent link">&para;</a></h1>
<p>[Simon Tatham, 2025-09-02]</p>
<p>[Part of a series: <a href="../aperiodic-tilings/">Penrose and hats</a> | <a href="../aperiodic-spectre/">Spectres</a> | <a href="../aperiodic-transducers/">finite-state transducers</a> | <a href="../aperiodic-followup/">more transducers</a> | <strong>refining tilings</strong> ]</p>
<ul>
<li>Introduction<ul>
<li>Recap</li>
</ul>
</li>
<li>Ambiguous substitution systems<ul>
<li>Refining the set of tile types</li>
</ul>
</li>
<li>Making refined substitution systems from scratch<ul>
<li>Clues to the secret</li>
<li>Neighbourhood-based refinement</li>
<li>Reducing the set of subtypes</li>
</ul>
</li>
<li>Trying it out on real aperiodic tilings<ul>
<li>The auto-refiner rediscovers HHTPFFF from first principles</li>
<li>It figures out the Spectre 9-hex system too</li>
<li>And now look what happens with hats!</li>
</ul>
</li>
<li>Difficult cases<ul>
<li>The âAwkward Squaresâ substitution system</li>
<li>Extendable list of queries</li>
<li>Sometimes you have to refine more than once!</li>
<li>The test case that wasnât a test case</li>
</ul>
</li>
<li>Conclusion</li>
</ul>
<h2 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Permanent link">&para;</a></h2>
<p>(I know, I know. Iâm running out of title ideas.)</p>
<p>This is article #5 in my series about generating aperiodic tilings using string-processing techniques. Every time, thereâs more to recap from the previous ones. So Iâm just going to start with the introduction to <em>this</em> article, and fill in the recap in a moment.</p>
<p>In the previous two articles Iâve talked about using a finite-state transducer to move around a tiling, tracking your current position as a string of combinatorial coordinates, and using the transducer to update the coordinate string as you step from each tile to the next. These transducers are ideally <em>deterministic</em> , generating a unique output coordinate string given any legal input. But not every substitution system admits a deterministic transducer: different systems describing the same actual <em>tiling</em> may or may not unambiguously identify the neighbouring coordinates of every tile in every situation.</p>
<p>What do you do if your substitution system <em>doesnât</em> work with this technique? In the past, Iâve had to depend on luck. Some systems I wanted to use happened to work already; in cases where the system I started with didnât work, someone else found an alternative system that did (though I think that was luck too, and this wasnât the property they were specifically after).</p>
<p>In this article Iâm going to talk about a technique for solving the problem without needing to depend on luck: if you have an ambiguous substitution system, you can <em>construct</em> a variation of it which is unambiguous, and make a transducer out of that instead.</p>
<h3 id="recap">Recap<a class="headerlink" href="#recap" title="Permanent link">&para;</a></h3>
<p>I just said that thereâs more to recap every time from previous articles. But itâs not <em>quite</em> true, because some of those articles contained ideas that Iâve now decided are superseded by better thoughts I had later. If you were to go back and re-read the whole lot, there would be entire sections Iâd recommend skipping. So here Iâll try to summarise the <em>useful</em> parts.</p>
<p>This whole project has focused on tilings of the plane generated by <em>substitution systems</em>. A substitution system is a set of rules that allow you to turn each tile of tiling <em>A</em> into a cluster of tiles in tiling <em>B</em> , in a consistent way (each <em>type</em> of tile is transformed into the same cluster every time), and also specifies how those clusters fit next to each other when theyâre expanded from neighbouring tiles. (Examples from previous articles: <a href="../aperiodic-tilings/#ccoords-penrose">Penrose</a>, <a href="../aperiodic-spectre/#hextransitions">Spectre</a>, <a href="../aperiodic-transducers/#hats-nonoverlapping">hats</a>, <a href="../aperiodic-transducers/#hat10">hats done differently</a>.)</p>
<p>So in principle â in the ideal world of mathematics where infinite processes can be imagined â you can take an entire infinite tiling of the plane, and apply these substitution rules to make a different complete tiling derived from the first one. Iâve been calling this âexpansionâ; mathematicians often say âdeflationâ.</p>
<p>More practically, you can take just <em>one</em> tile, and expand it repeatedly via the substitution system to turn it into a large patch of your tiling. This is a common technique for actually generating patches of (say) Penrose tilings in software.</p>
<p>But this series of articles has been about a better approach. If you have a tiling that was (or could have been) <em>generated</em> by iterating a substitution system â and with the famous aperiodic tilings like Penrose and hats, <em>every</em> tiling of the plane has this property â you can describe the <em>combinatorial</em> position of a tile in terms of the substitution system, by describing its position in the hierarchy of expansions. First say what type the tile <em>T</em> 0 itself is; then say how it was generated from its supertile <em>T</em> 1, by giving the type of <em>T</em> 1 and also saying which tile is <em>T</em> 0 in the cluster of multiple tiles expanded from <em>T</em> 1. Then describe how <em>T</em> 1 was generated from its parent <em>T</em> 2 in turn, via another (tile type, subtile index) pair, and so on.</p>
<p>Once you have a string of âcombinatorial coordinatesâ describing a tile <em>T</em> , it turns out that you can calculate the coordinates of a neighbouring tile <em>U</em> by several algorithms Iâve described in previous articles, all of which operate only on the string of coordinates, without having to think about geometry at all. So you can generate a patch of tiling that occupies a given region of the plane by generating each tile on demand as you find you need it, which is much more efficient than generating a much larger piece of tiling and then throwing most of its tiles away.</p>
<p>The <a href="../aperiodic-tilings/#recursive-algorithm">first of these algorithms</a> is recursive: ascend the hierarchy until you find a single supertile whose expansion contains both <em>T</em> and <em>U</em> , so that the coordinates of <em>T</em> and <em>U</em> are identical from that point onwards; then unwind the algorithmâs stack, generating the new set of low-order coordinates that describe <em>U</em>. The low-order part of this procedureâs output tells you which type of tile <em>U</em> actually is, and which edge of <em>T</em> is adjacent to which edge of <em>U</em> , so you know what tile to draw where in your output diagram. Then the rest of the output coordinate string contains enough information to run the algorithm again to step to <em>U</em> âs neighbour in turn, and so on.</p>
<p>You can use that recursive algorithm directly in simple cases, but I prefer a more sophisticated technique based on finite state machines, which requires more setup but is faster and simpler at run time, and can also handle special cases in which the recursion would never terminate. The first step of that is to use data obtained from the recursive algorithm to <a href="../aperiodic-followup/#adjrec-dsf">build</a> a thing I call an âadjacency recogniserâ. Thatâs a finite state machine which takes the coordinates of <em>two</em> tiles <em>T</em> and <em>U</em> , as if combined by Python <code>zip()</code>, and accepts or rejects depending on whether the two coordinate strings describe neighbouring tiles.</p>
<p>You can also <a href="../aperiodic-transducers/#nondeterministic-transducer">imagine</a> the adjacency recogniser as a state machine which takes <em>T</em> alone as input, by reinterpreting the input <em>U</em> as output. But this state machine is nondeterministic: there isnât a unique output for all possible inputs. So next you try to <a href="../aperiodic-transducers/#determinisation">transform it</a> into a <em>deterministic</em> finite-state transducer, and see if that works.</p>
<p>A deterministic transducer, if you can build one, is my current gold standard for the best way to generate patches of tiling. Itâs fast, simple (once youâve built it), never needs to backtrack, and can cross <a href="../aperiodic-transducers/#infinite-boundary">âinfinite-order supertileâ boundaries</a> â a phenomenon that comes up in special cases of these tilings, where no finitely large supertile contains any two tiles on opposite sides of the boundary. The recursive algorithm canât handle a case like that at all, but a deterministic transducer can bypass one of those boundaries effortlessly, and find the unique infinite-order supertile that fits to the far side in such a way that every patch of tiling along the border is consistent with how the tiles normally fit together.</p>
<p>But for some systems you <a href="../aperiodic-transducers/#hats-ambiguity">canât build a deterministic transducer</a>, because not every infinite-order supertile boundary <em>has</em> a unique neighbour: there exists some infinite string of coordinates which describes only part of the plane, and <em>multiple</em> options for what goes on the other side. I call a substitution system of this kind <em>ambiguous</em>.</p>
<h2 id="ambiguous-substitution-systems">Ambiguous substitution systems<a class="headerlink" href="#ambiguous-substitution-systems" title="Permanent link">&para;</a></h2>
<p>In previous articles, Iâve shown two cases of this kind of ambiguity. <a href="../aperiodic-transducers/#htpf-ambiguity">One occurred</a> in the original HTPF system of metatiles for the hat tiling; <a href="../aperiodic-followup/#spectre-h7h8-ambiguity">the other</a> was in the minimalist H7Â /Â H8 substitution system for the Spectre tiling. In each case, thereâs an infinite-order supertile boundary (shown as a thick line in the diagrams), with one side of the boundary fixed, and multiple possibilities for the other side.</p>
<p>To refresh your memory, hereâs the hat example again:</p>
<p>(F,Â 5) and (H,Â 7) supertiles<img alt="[hats-f5-h7.svg]" src="hats-f5-h7.svg" /> (F,Â 5) and (H,Â 8) supertiles<img alt="[hats-f5-h8.svg]" src="hats-f5-h8.svg" /></p>
<p><img alt="" src="hats-f5-spacer.svg" /></p>
<p>The two possible infinite hat supertiles that can go with (F,Â 5)</p>
<h3 id="refining-the-set-of-tile-types">Refining the set of tile types<a class="headerlink" href="#refining-the-set-of-tile-types" title="Permanent link">&para;</a></h3>
<p>What do you do if you want to use a deterministic transducer on one of those tilings? In both cases, my previous articles provide an answer: you can switch to a substitution system very like the previous one, but with additional types of tile. Iâm going to call this a <em>refinement</em> of the previous system.</p>
<p>In the HTPF case, I presented a <a href="../aperiodic-followup/#hhtpfff">substitution system of my own</a>, which I called âHHTPFFFâ. It looks just like <a href="../aperiodic-transducers/#hats-nonoverlapping-spec">the non-overlapping version of the standard HTPF system</a>, except that the H tile type has been cloned into two subtypes H0 and H1, and the F tile has been cloned into three, F0, F1 and F2. (And the difficult part, which is mostly what Iâm going to end up discussing in this article, is deciding which version of H and F should appear in which expansion diagrams.)</p>
<p><img alt="[hat-hhtpfff-H0.svg]" src="hat-hhtpfff-H0.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[hat-hhtpfff-H0exp.svg]" src="hat-hhtpfff-H0exp.svg" /></p>
<p><img alt="[hat-hhtpfff-H1.svg]" src="hat-hhtpfff-H1.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[hat-hhtpfff-H1exp.svg]" src="hat-hhtpfff-H1exp.svg" /></p>
<p><img alt="[hat-hhtpfff-T.svg]" src="hat-hhtpfff-T.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[hat-hhtpfff-Texp.svg]" src="hat-hhtpfff-Texp.svg" /></p>
<p><img alt="[hat-hhtpfff-P.svg]" src="hat-hhtpfff-P.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[hat-hhtpfff-Pexp.svg]" src="hat-hhtpfff-Pexp.svg" /></p>
<p><img alt="[hat-hhtpfff-F0.svg]" src="hat-hhtpfff-F0.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[hat-hhtpfff-F0exp.svg]" src="hat-hhtpfff-F0exp.svg" /></p>
<p><img alt="[hat-hhtpfff-F1.svg]" src="hat-hhtpfff-F1.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[hat-hhtpfff-F1exp.svg]" src="hat-hhtpfff-F1exp.svg" /></p>
<p><img alt="[hat-hhtpfff-F2.svg]" src="hat-hhtpfff-F2.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[hat-hhtpfff-F2exp.svg]" src="hat-hhtpfff-F2exp.svg" /></p>
<p>Substitution rules for the HHTPFFF hat system</p>
<p>If youâre using <em>this</em> system, then what happens to the HTPF coordinate sequence that led to the ambiguity? The sequence in question was (F,5) repeated endlessly: that is, an F metatile which is child #5 of a larger F in turn, and so on forever. But in the more detailed HHTPFFF system, now you have to say <em>which</em> kind of F metatile you mean: you can either have an F0 which is child #5 of another F0 forever, or an F1 which is child #5 of another F1. (Thereâs no third option involving type F2, because child #5 of F2 is an F1, not another F2.)</p>
<p>And whichever of those options you pick, the HHTPFFF system only allows <em>one</em> possibility for the coordinates of the tile on the far side of the boundary. So weâve removed the ambiguity, by forcing the user to specify which version of (F,5) they meant.</p>
<p>(F1,Â 5) and (H0,Â 7) supertiles<img alt="[hats-f5-refined-h7.svg]" src="hats-f5-refined-h7.svg" /> (F0,Â 5) and (H1,Â 8) supertiles<img alt="[hats-f5-refined-h8.svg]" src="hats-f5-refined-h8.svg" /></p>
<p><img alt="" src="hats-f5-spacer.svg" /></p>
<p>The same two hat tilings, specified in the HHTPFFF system.<br />
Each tile shows its containing metatile type and a hat index within that metatile.</p>
<p>(Of course, this doesnât mean that only one set of tiles fits <em>physically</em> to the far side of the boundary. The infinite supertiles (F0,5) and (F1,5) occupy exactly the same shape of region in the plane, so each one fits perfectly to the other oneâs official neighbouring supertile. But if you fit one to the wrong neighbour, the tile types arenât consistent across the border: pairs of adjacent tiles occur which are never seen in any finitely large patch expanded from a single metatile. Transducers insist on maintaining <em>that</em> type of consistency.)</p>
<p>In the case of the Spectre H7Â /Â H8 system, I didnât even have to make up a substitution system of my own. The discoverers of the Spectre tiling had long since done it for me: the system of 9 hexagonal metatiles in the original Spectre paper essentially <em>is</em> a refinement of the H7Â /Â H8 system. And itâs already unambiguous in this sense, so it allows a transducer to be constructed.</p>
<h2 id="making-refined-substitution-systems-from-scratch">Making refined substitution systems from scratch<a class="headerlink" href="#making-refined-substitution-systems-from-scratch" title="Permanent link">&para;</a></h2>
<p>When I wrote the previous articles, I didnât know <em>how</em> to construct an unambiguous refinement of an ambiguous substitution system.</p>
<p>That seems like an odd thing to say, given that I just said I <em>had</em> constructed one myself â the HHTPFFF system. But I didnât do it from scratch: I had help. Bowen Ping and Brad Klee had already discovered <a href="/aperiodic-transducers/#hat10">a completely different unambiguous system for hats</a> involving 10 types of hexagonal metatile. I derived the HHTPFFF system by looking at the correspondence between HTPF and those 10 hexagon types, and spotting that the H metatile in one system didnât always correspond to the same group of hexagons in the other â there were two different clusters of hexagons occupying the space of an H metatile, and three different clusters corresponding to an F.</p>
<p>In other words, I made an unambiguous HTPF-like system by combining the original HTPF system with another system that was already unambiguous. I didnât <em>create</em> the lack of ambiguity: I just copied it from one place to another.</p>
<p>In fact, I had previously <em>tried</em> to make an HHTPFFF-type system from scratch by hand, when I first discovered HTPFâs ambiguity. I was attempting exactly this kind of thing: split each tile into multiple types and somehow figure out which ones have to appear where in which expansion diagrams. I didnât manage to solve the problem by hand. In fact, I eventually began to suspect it wasnât possible, and gave up trying.</p>
<p>But it <em>was</em> possible, as it turned out. I just hadnât found it by manually searching the large space of possible refinements, and I didnât know of any principled approach to finding it <em>without</em> having to search a large space.</p>
<p>Well, now I do know! In fact, better than that: Iâve automated the process. Iâve found an <em>algorithm</em> , and implemented it in software, which can make an unambiguous version of a substitution system, given an ambiguous one as input.</p>
<p>At least, itâs worked on every ambiguous system Iâve tried so far, including an extra-awkward one I made up myself.</p>
<h3 id="clues-to-the-secret">Clues to the secret<a class="headerlink" href="#clues-to-the-secret" title="Permanent link">&para;</a></h3>
<p>Iâll start by describing the clues that gave me the idea I ended up with.</p>
<p>After I published the previous article including a specification of the HHTPFFF tiling, I had a response on Mastodon from <a href="https://mathstodon.xyz/@mathBlock">mathBlock</a>, who had been studying a different property of the HTPF tiles, which they called â<a href="https://mathstodon.xyz/@mathBlock/110653707540128465">drainage</a>â â if I havenât totally misunderstood, it was about interpreting the tile outlines as contour lines and imagining how rivers of water would run down them. mathBlock had found that the HTPF metatile system didnât provide quite enough information to determine the drainage: P metatiles always behaved in a consistent way, but F metatiles could do more than one thing, depending on where they appeared in the tiling. It turned out that my division of the F metatiles into F0, F1 and F2 seemed to match up to the different drainage behaviours.</p>
<p>I must admit that I never quite fully understood what the idea of drainage was useful for. But I know that what it <em>was</em> had to do with the neighbourhood of the tiles. What distinguishes the F0, F1 and F2 metatiles is: after you expand each one into two hats, look at <a href="https://mathstodon.xyz/@mathBlock/112806677484242025">two particular convex vertices</a> of the resulting shape. Each one either meets two convex vertices of other hats, or meets a concave vertex of a single hat. Depending on which of those vertices do which, the metatile is either F0, F1 or F2. Similarly, a single vertex on the edge of the expansion of the H metatile into hats distinguishes H0 from H1.</p>
<p>In fact, it turns out that in each case thereâs only one way that the neighbouring hat or hats around that vertex can be oriented. For example, here are the three subtypes of F, with the neighbouring hats around those vertices shown: </p>
<p>F0<img alt="[hats-f-subtypes-F0.svg]" src="hats-f-subtypes-F0.svg" /> F1<img alt="[hats-f-subtypes-F1.svg]" src="hats-f-subtypes-F1.svg" /> F2<img alt="[hats-f-subtypes-F2.svg]" src="hats-f-subtypes-F2.svg" /></p>
<p><img alt="" src="hats-f-subtypes-spacer.svg" /></p>
<p>The three subtypes of F, and their forced hat neighbours around two particular vertices</p>
<p>We can check those diagrams against the ambiguous pair of (F,5) tilings I showed earlier. Here are those ambiguous tilings again, this time zoomed in to show the two hats expanded from the âcentralâ F metatile (the one which is child #5 of another F all the way up), with the two critical vertices marked as shown in the diagrams above:</p>
<p>(F1,Â 5) and (H0,Â 7) supertiles<img alt="[hats-f5-refined-zoom-h7.svg]" src="hats-f5-refined-zoom-h7.svg" /> (F0,Â 5) and (H1,Â 8) supertiles<img alt="[hats-f5-refined-zoom-h8.svg]" src="hats-f5-refined-zoom-h8.svg" /></p>
<p><img alt="" src="hats-f5-spacer-zoom.svg" /></p>
<p>Detail of the ambiguous supertile boundary, with crucial F vertices marked</p>
<p>You can see that the hats on the other side of the boundary meet this F metatile in a way thatâs consistent with the diagrams here. When the F metatile is an F1, the marked vertex of its hat #0 meets a concave corner of a hat (as it happens, labelled H0.0); when itâs F0, the same vertex meets convex corners of two hats (P.1 and H1.2). Meanwhile, the marked vertex of hat #1 meets convex corners of two hats in both cases, as weâd also expect from the previous diagrams (it would only meet a concave corner in the F2 subtype). So this even shows us <em>how</em> specifying the subtype of F tile has disambiguated the far side of the boundary: of the two possibilities, each is only consistent with one of F0 and F1.</p>
<p>So this was my first clue that in one of these refined tilings, the subtype of a tile is related in some way to <em>what its neighbouring tiles are</em>.</p>
<p>What about the Spectre 9-hex system, which is pretty much a disambiguating refinement of the H7Â /Â H8 system?</p>
<p>The same is true there. In fact, the original Spectre paper says outright that the 9 hexagon types were <em>derived</em> by looking at the neighbourhood of each tile in the overall tiling.</p>
<p>And this also makes perfect sense from first principles. What problem were we originally trying to solve? The existence of a tile coordinate with more than one possible neighbour. How might you solve that? By making two (or more) copies of the tile and simply <em>ruling</em> that each one is only allowed to have a certain kind of neighbour. The F0 tile is the one which can be next to an H tile <em>this</em> way round, and not <em>that</em> way round; the F1 tile, <em>vice versa</em>.</p>
<p>That sounds like a pretty short thought process, now that I write it down. But initially these thoughts were very vague. (Not to mention that Iâd forgotten that detail from the Spectre paper, and had to go and read it again before I noticed it!) I turned them over in my head for months before becoming gradually more confident that this was an idea that would work. Then I had to get from the general idea of âlook at the neighbourhoods of the tilesâ to a concrete plan for how to determine those neighbourhoods and exactly what to do about them. And even then I didnât get round to trying it, until I heard of another ambiguous substitution system that I wanted to try it on.</p>
<h3 id="neighbourhood-based-refinement">Neighbourhood-based refinement<a class="headerlink" href="#neighbourhood-based-refinement" title="Permanent link">&para;</a></h3>
<p>The idea I settled on, as a technique for automated tiling refinement, was to make subtypes of each tile based on its <em>whole</em> neighbourhood. For each tile type in your original system, make a lot of clones of it, one for each possible pattern of <em>all</em> of its neighbouring tiles. Initially, by âneighbouring tilesâ, I mean: for each edge of the tile, what type of tile is on the other side of that edge, and in what orientation?</p>
<p>As a worked example, Iâm going to use a substitution system I havenât shown in these articles before, because itâs usually too simple to be interesting, but here itâs just the right size to not be overwhelming. Itâs the âchairâ substitution system from Chaim Goodman-Straussâs 1999 paper â<a href="https://strauss.hosted.uark.edu/papers/AHT.pdf">Aperiodic hierarchical tilings</a>â. The chair system has just one type of tile, and a single substitution rule that tiles a chair with four half-sized chairs:</p>
<p><img alt="[chair-parent.svg]" src="chair-parent.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[chair-exp.svg]" src="chair-exp.svg" /></p>
<p>The substitution rule for the chair tiling</p>
<p>(The chair tile isnât an <em>aperiodic tile</em> , in the way that hats or Spectres are. It <em>can</em> tile the plane non-periodically, but it doesnât <em>force</em> non-periodicity: there are also periodic tilings using the same tile type. But the particular tilings generated by this substitution system are hierarchical rather than periodic.)</p>
<p>So our first task is to analyse this substitution system to find every possible way that a chair tile can be surrounded by other tiles, and make a different subtype of the chair tile for each pattern. In this case, it turns out that there are seven different patterns, shown here:</p>
<p><img alt="[chair-neighbourhood-chair1.svg]" src="chair-neighbourhood-chair1.svg" /></p>
<p><img alt="[chair-neighbourhood-chair2.svg]" src="chair-neighbourhood-chair2.svg" /></p>
<p><img alt="[chair-neighbourhood-chair3.svg]" src="chair-neighbourhood-chair3.svg" /></p>
<p><img alt="[chair-neighbourhood-chair4.svg]" src="chair-neighbourhood-chair4.svg" /></p>
<p><img alt="[chair-neighbourhood-chair5.svg]" src="chair-neighbourhood-chair5.svg" /></p>
<p><img alt="[chair-neighbourhood-chair6.svg]" src="chair-neighbourhood-chair6.svg" /></p>
<p><img alt="[chair-neighbourhood-chair7.svg]" src="chair-neighbourhood-chair7.svg" /></p>
<p>The seven different neighbourhoods of a chair tile</p>
<p>To be clear, those arenât <em>all</em> of the possible patterns of chair tiles that can possibly surround another chair. Theyâre not even all the possible patterns that can arise in the context of a tiling of the whole plane. But theyâre all the patterns that can arise in a tiling <em>generated by iterating this substitution</em> â they were found by analysing the substitution system itself, and only considering possibilities that that system can generate.</p>
<p>The above analysis tells us what subtypes need to <em>exist</em>. But in order to completely specify the refined system, we must also look at the expansion of each tile into smaller tiles, and for each smaller tile, specify which clone of the original type it is.</p>
<p>To do that, we look at the original tile, and whatever neighbours a particular subtype assigns it; expand all of those into their subtiles via the original substitution system; and then, typically, thatâs enough information to find all the neighbours of the subtiles we need to know.</p>
<p>For example, letâs take the above diagram for chair type 1 and its neighbours; expand all the tiles in the diagram into subtiles; and then we can determine the type of each of the central chairâs subtiles, based on its neighbours.</p>
<p>Supertiles<img alt="[chair-classify-start.svg]" src="chair-classify-start.svg" /> Subtiles<img alt="[chair-classify-expand.svg]" src="chair-classify-expand.svg" /> Bottom left<img alt="[chair-classify-bl.svg]" src="chair-classify-bl.svg" /> Bottom right<img alt="[chair-classify-br.svg]" src="chair-classify-br.svg" /> Top right<img alt="[chair-classify-tr.svg]" src="chair-classify-tr.svg" /> Middle<img alt="[chair-classify-mid.svg]" src="chair-classify-mid.svg" /></p>
<p><img alt="" src="chair-classify-spacer.svg" /></p>
<p>Deciding the subtypes of smaller chairs for a type-1 larger chair</p>
<p>If we do that for the other six tile types too, we end up with this complete 7-tile substitution system:</p>
<p><img alt="[chair-unreduced-chair1.svg]" src="chair-unreduced-chair1.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[chair-unreduced-chair1-exp.svg]" src="chair-unreduced-chair1-exp.svg" /></p>
<p><img alt="[chair-unreduced-chair2.svg]" src="chair-unreduced-chair2.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[chair-unreduced-chair2-exp.svg]" src="chair-unreduced-chair2-exp.svg" /></p>
<p><img alt="[chair-unreduced-chair3.svg]" src="chair-unreduced-chair3.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[chair-unreduced-chair3-exp.svg]" src="chair-unreduced-chair3-exp.svg" /></p>
<p><img alt="[chair-unreduced-chair4.svg]" src="chair-unreduced-chair4.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[chair-unreduced-chair4-exp.svg]" src="chair-unreduced-chair4-exp.svg" /></p>
<p><img alt="[chair-unreduced-chair5.svg]" src="chair-unreduced-chair5.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[chair-unreduced-chair5-exp.svg]" src="chair-unreduced-chair5-exp.svg" /></p>
<p><img alt="[chair-unreduced-chair6.svg]" src="chair-unreduced-chair6.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[chair-unreduced-chair6-exp.svg]" src="chair-unreduced-chair6-exp.svg" /></p>
<p><img alt="[chair-unreduced-chair7.svg]" src="chair-unreduced-chair7.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[chair-unreduced-chair7-exp.svg]" src="chair-unreduced-chair7-exp.svg" /></p>
<p>The chair tiling after refinement</p>
<p>And if we feed this refined version of the chair tiling to my transducer-building code, it works! The original chair tiling didnât admit a transducer, but the refined one does.</p>
<p>Why didnât the original tiling admit a transducer? Because there exists at least one infinite supertile boundary where itâs ambiguous whatâs on the far side. Hereâs one: expand a chair into four chairs, at every stage keeping the bottom right corner fixed, so that you occupy one quadrant of the plane.</p>
<p>0<img alt="[chair-incremental-0.svg]" src="chair-incremental-0.svg" /> 1<img alt="[chair-incremental-1.svg]" src="chair-incremental-1.svg" /> 2<img alt="[chair-incremental-2.svg]" src="chair-incremental-2.svg" /> 3<img alt="[chair-incremental-3.svg]" src="chair-incremental-3.svg" /> 4<img alt="[chair-incremental-4.svg]" src="chair-incremental-4.svg" /> 5<img alt="[chair-incremental-5.svg]" src="chair-incremental-5.svg" /></p>
<p><img alt="" src="chair-incremental-spacer.svg" /></p>
<p>Building up an infinite supertile of chairs</p>
<p>In the refined system, in order to describe that infinite supertile in the first place, you have to choose which <em>subtype</em> of chair youâre talking about at every level. Chair types 3 and 7 are the only two types that ever appear in the bottom right of another chair, and each of those has a bottom right subtile of the same type as itself. So you have the choice of a type-3 chair with type-3 supertiles forever, or a type-7 one with type-7 supertiles.</p>
<p>Either way, the ambiguity is removed, because each of those tile types embodies a strong opinion about what must appear to its bottom right. In the neighbourhood diagrams above, you can see that the type-3 chair tile appears âback to backâ with two other chairs, adjacent to each along a whole long edge. But the type-7 tile nestles in the concave corner of another chair. And in the diagrams below, if you look at the tile at the bottom right corner of the top-left quadrant, you can see that the same is true: when itâs type 3, there are two more type 3s back-to-back with it on the far side of the supertile boundary, but when itâs type 7, thereâs a type 4 cuddling its corner.</p>
<p>Type 3<img alt="[chair-3.svg]" src="chair-3.svg" /> Type 7<img alt="[chair-7.svg]" src="chair-7.svg" /></p>
<p><img alt="" src="chair-ambig-spacer.svg" /></p>
<p>Tilings containing the two disambiguated versions of that infinite supertile</p>
<p>Similarly to previous cases (<a href="../aperiodic-followup/#spectre-h7h8-ambiguity">Spectre</a>, <a href="../aperiodic-transducers/#hat10-ambig-diagram">hat 10-hex</a>), we can see that the far side of the boundary doesnât have the same infinite supertile structure in both cases. In the type 3 version of the picture, four identical supertiles meet back to back in a 4-way symmetric tiling of the plane; in the type 7 version, the supertile we started with occupies one quadrant of the plane, and a single neighbour supertile occupies the other three quadrants. (That other supertile is constructed in a very similar way to the first one, except that we keep the <em>concave</em> vertex of the chair fixed at every stage instead of the bottom right vertex.)</p>
<p>Also similarly to previous cases, we see that <em>most</em> of the variable side of the boundary doesnât actually vary! Almost all the chair tiles are the same in both diagrams, with the only changed ones being along a small number of narrow paths â in this case, three of the four diagonals out from the centre of the tiling (excluding the one in the top left, which belongs to the fixed supertile we started with).</p>
<p>That diagram is my excuse for this articleâs terrible pun title, incidentally. We had a substitution system we couldnât make a transducer for, meaning we couldnât find out what was on the other side of that infinite supertile boundary; then we applied our shiny new algorithm to refine the tiling, and that enabled us to build a transducer and use it to cross the barrier. Perhaps more specifically, it became possible to cross the barrier once weâd distinguished <em>which</em> of two very similar barriers it actually was. So it <em>was</em> a refinable frontier, so there.</p>
<h3 id="reducing-the-set-of-subtypes">Reducing the set of subtypes<a class="headerlink" href="#reducing-the-set-of-subtypes" title="Permanent link">&para;</a></h3>
<p>Thatâs proved the concept, at least. This refinement technique seems to <em>work</em> : it produces a version of the original tiling which allows a deterministic transducer to be constructed, even if the original tiling didnât. (I have no proof that it works in all possible cases, but at this stage itâs worked in one, and thatâs one more than I previously knew how to do!)</p>
<p>But you end up with a <em>lot</em> of tile subtypes. The reason I used the chair tiling as my example in the previous section is that anything bigger wouldnât have fitted. The results of running this algorithm on the HTPF system delivers a set of <em>21 tile types</em> in total: 7 kinds of H, 5 kinds of P and 8 kinds of F (but still only one kind of T). And we <em>know</em> thatâs more than we need, because Iâd already found the HHTPFFF system, with only one kind of P, and two H and three F!</p>
<p>Looking at the output, one thing I immediately noticed was that some of the output tile types had exactly the <em>same</em> expansion as each other. For example, in the chair tiling shown above, chair types 1, 2 and 3 all expand to exactly the same pattern, and so do types 5, 6 and 7.</p>
<p>So that led to the idea: what if we postprocess the refined system by merging tile types that have identical expansions?</p>
<p>This <em>shouldnât</em> reintroduce ambiguity, because the aim is to distinguish what happens at the <em>lowest</em> level, in the final output tiling, and higher-order supertiles are only interesting in what they eventually expand to. (A handwave rather than a proof, but enough to make it look worth a try.)</p>
<p>Of course, merging some tile types might make <em>further</em> expansion diagrams identical, if they only differed in subtile types which we just merged into one. So we iterate the merging process if necessary, until we reach a fixed point.</p>
<p>For example, after re-merging those sets of identical subtypes in the chair tiling, the 7 subtypes of chair tile are reduced to only 3:</p>
<p><img alt="[chair-reduced-chair1.svg]" src="chair-reduced-chair1.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[chair-reduced-chair1-exp.svg]" src="chair-reduced-chair1-exp.svg" /></p>
<p><img alt="[chair-reduced-chair2.svg]" src="chair-reduced-chair2.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[chair-reduced-chair2-exp.svg]" src="chair-reduced-chair2-exp.svg" /></p>
<p><img alt="[chair-reduced-chair3.svg]" src="chair-reduced-chair3.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[chair-reduced-chair3-exp.svg]" src="chair-reduced-chair3-exp.svg" /></p>
<p>The chair tiling after refinement and reduction</p>
<p>The reduced set of tile types no longer encapsulate <em>all</em> the information about each tileâs neighbourhood. But they still contain just enough of it to make a transducer work. To prove it, here are the same two tilings as above, regenerated using the reduced system:</p>
<p>Type 1<img alt="[chair-1.svg]" src="chair-1.svg" /> Type 2<img alt="[chair-2.svg]" src="chair-2.svg" /></p>
<p><img alt="" src="chair-ambig-spacer.svg" /></p>
<p>The two chair tilings from above, in the reduced system</p>
<p>(I have to admit that the rainbow versions of these pictures in the previous section were prettier! But the system with fewer tile types is more practical.)</p>
<p>You might wonder: what do these reduced types <em>mean?</em> We had a clear idea what the original seven chair subtypes meant: each one went with a specific diagram of how the chairs around it were arranged. But now that weâve merged some of those subtypes into one, what information does a merged subtype convey, apart from âthe tiles around it can be in one of [this potentially long list of patterns]â?</p>
<p>I think the answer is that a reduced tile type still tells you <em>something</em> about the neighbourhood of the original tile â but it doesnât tell you everything about what tiles <em>of the same size</em> surround it. Instead, weâve narrowed down to only saying something about the surrounding <em>smaller</em> tiles, at the next expansion level down. You can see an example of this in an earlier section, where I showed the three subtypes of F in the HHTPFFF tiling: choosing one of those three subtypes doesnât nail down exactly what <em>metatiles</em> surround the F, but it does tell you something about which <em>hats</em> surround it. And not even on all sides: only at a small number of positions where the answers are crucial to telling the difference between something important.</p>
<h2 id="trying-it-out-on-real-aperiodic-tilings">Trying it out on real aperiodic tilings<a class="headerlink" href="#trying-it-out-on-real-aperiodic-tilings" title="Permanent link">&para;</a></h2>
<p>This is all very well, and has given us a pretty picture or two, but the chair tiling isnât all that interesting, because itâs not a <em>real</em> aperiodic tile: there are plenty of other ways to tile the plane with chairs which arenât derived from the substitution system above, and many of those are periodic. In that respect itâs unlike Penrose tilings, or hats, or Spectres, which all have the property that the <em>only</em> ways you can tile the plane with those tiles are derived from their substitution systems. So those are the interesting ones to study.</p>
<p>So, now weâve got a refinement algorithm that works on a small toy example of an ambiguous substitution system, how does it do when run on the cases we actually care about?</p>
<p>Answer: it does brilliantly!</p>
<h3 id="the-auto-refiner-rediscovers-hhtpfff-from-first-principles">The auto-refiner rediscovers HHTPFFF from first principles<a class="headerlink" href="#the-auto-refiner-rediscovers-hhtpfff-from-first-principles" title="Permanent link">&para;</a></h3>
<p>As I mentioned above, when I ran the <em>first</em> stage of this refinement algorithm on the HTPF system of hat metatiles, it divided each metatile type into many more subtypes than necessary (apart from T, which remained unique). We got seven kinds of H, five P, and eight F, making 21 types of metatile in total.</p>
<p>But when I ran the postprocessing reduction pass, <em>most</em> of those subtypes ended up merging with each other again. Guess how many we ended up with?</p>
<p>We ended up with exactly <em>seven</em> tile types: the single T, two H, three F, and back down to a single P.</p>
<p>And thatâs exactly the same set of tile types as in the HHTPFFF system Iâd already found without this refinement algorithm. This automated analysis can do in a fraction of a second what I spent weeks failing to do in 2023: starting from <em>only</em> the HTPF system itself, itâs able to construct an unambiguous, transducer-capable refinement of it, without needing any input from someone who had already discovered an unambiguous substitution system of any other kind. Moreover, it finds exactly the <em>same</em> one: no pointless extra tile types. (On <em>either</em> side.)</p>
<h3 id="it-figures-out-the-spectre-9-hex-system-too">It figures out the Spectre 9-hex system too<a class="headerlink" href="#it-figures-out-the-spectre-9-hex-system-too" title="Permanent link">&para;</a></h3>
<p>Iâve already mentioned a second ambiguous substitution system: the H7Â /Â H8 substitution system for the Spectre tiling. In <a href="../aperiodic-followup/#spectre-h7h8-ambiguity">the previous article</a> I used the ambiguity to zero in on one of the particularly interesting instances of the Spectre tiling.</p>
<p>To recap the H7Â /Â H8 substitution system: it contains just two types of metatile. One is just a single Spectre; the other is the âMysticâ, two Spectres oriented at a 30Â° angle to each other and glued together into a double-sized tile. The expansion diagrams look like this:</p>
<p><img alt="[spectre-h7h8-Spectre.svg]" src="spectre-h7h8-Spectre.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[spectre-h7h8-Spectreexp.svg]" src="spectre-h7h8-Spectreexp.svg" /></p>
<p><img alt="[spectre-h7h8-Mystic.svg]" src="spectre-h7h8-Mystic.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[spectre-h7h8-Mysticexp.svg]" src="spectre-h7h8-Mysticexp.svg" /></p>
<p>Substitution rules for the Spectre H7Â /Â H8 system</p>
<p>A warning: these expansion diagrams are more complicated than they look, because â to put it mildly â itâs not obvious at all how the edges of the single Spectre or Mystic match up to the crinkly edges of the expansion. As well as the exterior spurs shown, thereâs also an interior spur in the Mystic expansion, and even a section of boundary which is traversed <em>three</em> times, twice in one direction and once in the opposite direction in between. All of that detail is very difficult to show in a single diagram: if I labelled all the edges and sub-edges, as I did for the <a href="../aperiodic-transducers/#hats-nonoverlapping-spec">HTPF system</a> in a previous article, the numbers would all overlap each other and it would still look horribly confusing. If you want to understand how the edges match up, my best suggestion is to go back to the <a href="../aperiodic-followup/#h7h8-spectre-automorphism">diagrams in my previous article</a>, where I showed the outline of each of these expansions being built up one edge at a time.</p>
<p>My <em>first</em> attempt to write the auto-refiner algorithm couldnât handle this system at all, because when it was trying to find all the neighbour patterns it got stuck on even simple spurs â and this tiling has the worst spurs of all. Indeed, I wrote in an early commit message that this system (and its hat analogue) would be âthe boss levelâ of the concept. But then I found a better way to do the analysis which doesnât care about spurs, so I beat the boss fight in the end!</p>
<p>So my current refiner code runs quite happily, given this substitution system as input. It splits the plain Spectre metatile into eight versions, and leaves the Mystic unique, for a total of nine tile types. And it turns out that those nine tile types correspond <em>exactly</em> to the nine hexagon types described in the Spectre paper. Iâve shown the refined system here with my own Latin-alphabet labels for the tile types (and the original Greek ones too in the large tile pictures, in case thatâs useful). And Iâve used the same colour scheme as I used in <a href="../aperiodic-spectre/#hextransitions">my Spectre article in 2023</a>. So you can go back to that older article and easily check that all the expansion maps agree, if you want.</p>
<p><img alt="[spectre-h7h8-refined-Mystic.svg]" src="spectre-h7h8-refined-Mystic.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[spectre-h7h8-refined-Mysticexp.svg]" src="spectre-h7h8-refined-Mysticexp.svg" /></p>
<p><img alt="[spectre-h7h8-refined-Spectre1.svg]" src="spectre-h7h8-refined-Spectre1.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[spectre-h7h8-refined-Spectre1exp.svg]" src="spectre-h7h8-refined-Spectre1exp.svg" /></p>
<p><img alt="[spectre-h7h8-refined-Spectre8.svg]" src="spectre-h7h8-refined-Spectre8.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[spectre-h7h8-refined-Spectre8exp.svg]" src="spectre-h7h8-refined-Spectre8exp.svg" /></p>
<p><img alt="[spectre-h7h8-refined-Spectre4.svg]" src="spectre-h7h8-refined-Spectre4.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[spectre-h7h8-refined-Spectre4exp.svg]" src="spectre-h7h8-refined-Spectre4exp.svg" /></p>
<p><img alt="[spectre-h7h8-refined-Spectre7.svg]" src="spectre-h7h8-refined-Spectre7.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[spectre-h7h8-refined-Spectre7exp.svg]" src="spectre-h7h8-refined-Spectre7exp.svg" /></p>
<p><img alt="[spectre-h7h8-refined-Spectre3.svg]" src="spectre-h7h8-refined-Spectre3.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[spectre-h7h8-refined-Spectre3exp.svg]" src="spectre-h7h8-refined-Spectre3exp.svg" /></p>
<p><img alt="[spectre-h7h8-refined-Spectre2.svg]" src="spectre-h7h8-refined-Spectre2.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[spectre-h7h8-refined-Spectre2exp.svg]" src="spectre-h7h8-refined-Spectre2exp.svg" /></p>
<p><img alt="[spectre-h7h8-refined-Spectre6.svg]" src="spectre-h7h8-refined-Spectre6.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[spectre-h7h8-refined-Spectre6exp.svg]" src="spectre-h7h8-refined-Spectre6exp.svg" /></p>
<p><img alt="[spectre-h7h8-refined-Spectre5.svg]" src="spectre-h7h8-refined-Spectre5.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[spectre-h7h8-refined-Spectre5exp.svg]" src="spectre-h7h8-refined-Spectre5exp.svg" /></p>
<p>Substitution rules for the refined version of Spectre H7Â /Â H8</p>
<p>In other words, this automated algorithm has rediscovered exactly the Spectre 9-hex substitution system shown in the paper â except that it hasnât bothered simplifying the tile <em>shapes</em> into hexagons. That wasnât in its brief. The refinerâs job is to leave the tile shapes unchanged, and do nothing except make more versions of each tile type.</p>
<p>It doesnât matter very much, either way. By the time youâve built a transducer out of this system, the distinction between hexagonal metatiles and ones shaped like Spectres and Mystics has more or less vanished anyway. The lowest-level tiles (the actual Spectres) are the same in both systems, and the transducer has encapsulated all the <em>combinatorial</em> information about the metatiles, and didnât care about their geometry in the first place. The two transducers are interchangeable â you can feed the same coordinate string to either, and it will give the same answers.</p>
<h3 id="and-now-look-what-happens-with-hats">And now look what happens with hats!<a class="headerlink" href="#and-now-look-what-happens-with-hats" title="Permanent link">&para;</a></h3>
<p>Perhaps the most exciting result of this project was what happened when I ran the same refiner on the H7Â /Â H8 substitution system for the <em>hat</em> tiling.</p>
<p>That system is very similar to the Spectre one, in that it has two types of metatile, one of which is a single ordinary hat, and the other is a fusion of two, including the unusual reflected one. As with the Spectre case above, Iâve left the details of which edge is which out of this diagram (and for the same reason â itâs horribly confusing), but my <a href="../aperiodic-followup/#h7h8-hat-automorphism">previous article</a> has the missing detail in full.</p>
<p><img alt="[hat-h7h8-Hat.svg]" src="hat-h7h8-Hat.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[hat-h7h8-Hatexp.svg]" src="hat-h7h8-Hatexp.svg" /></p>
<p><img alt="[hat-h7h8-Double.svg]" src="hat-h7h8-Double.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[hat-h7h8-Doubleexp.svg]" src="hat-h7h8-Doubleexp.svg" /></p>
<p>Substitution rules for the hat H7Â /Â H8 system</p>
<p>In the previous two cases, when I ran my automated refiner, the output had been exactly identical to an unambiguous substitution system I already knew about. Here, I did already know of an unambiguous system that corresponds closely to the H7Â /Â H8 system for hats: Bowen Ping and Brad Kleeâs <a href="../aperiodic-transducers/#hat10">system of 10 hexagonal metatiles</a>. So I was expecting that my refiner would most likely recreate that from first principles, in the same way that it recreated both HHTPFFF and Spectre 9-hex.</p>
<p>But it surprised me, by doing <em>better!</em> The output of my refiner, run on Hat H7Â /Â H8, is a system of only <em>eight</em> tile types in total â the unique double-hat metatile and 7 subtypes of the single hat.</p>
<p><img alt="[hat-h7h8-refined-Hat1.svg]" src="hat-h7h8-refined-Hat1.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[hat-h7h8-refined-Hat1exp.svg]" src="hat-h7h8-refined-Hat1exp.svg" /></p>
<p><img alt="[hat-h7h8-refined-Hat2.svg]" src="hat-h7h8-refined-Hat2.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[hat-h7h8-refined-Hat2exp.svg]" src="hat-h7h8-refined-Hat2exp.svg" /></p>
<p><img alt="[hat-h7h8-refined-Hat3.svg]" src="hat-h7h8-refined-Hat3.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[hat-h7h8-refined-Hat3exp.svg]" src="hat-h7h8-refined-Hat3exp.svg" /></p>
<p><img alt="[hat-h7h8-refined-Hat4.svg]" src="hat-h7h8-refined-Hat4.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[hat-h7h8-refined-Hat4exp.svg]" src="hat-h7h8-refined-Hat4exp.svg" /></p>
<p><img alt="[hat-h7h8-refined-Hat5.svg]" src="hat-h7h8-refined-Hat5.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[hat-h7h8-refined-Hat5exp.svg]" src="hat-h7h8-refined-Hat5exp.svg" /></p>
<p><img alt="[hat-h7h8-refined-Hat6.svg]" src="hat-h7h8-refined-Hat6.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[hat-h7h8-refined-Hat6exp.svg]" src="hat-h7h8-refined-Hat6exp.svg" /></p>
<p><img alt="[hat-h7h8-refined-Hat7.svg]" src="hat-h7h8-refined-Hat7.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[hat-h7h8-refined-Hat7exp.svg]" src="hat-h7h8-refined-Hat7exp.svg" /></p>
<p><img alt="[hat-h7h8-refined-Double.svg]" src="hat-h7h8-refined-Double.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[hat-h7h8-refined-Doubleexp.svg]" src="hat-h7h8-refined-Doubleexp.svg" /></p>
<p>Substitution rules for the refined hat H7Â /Â H8 system</p>
<p>Is this a mistake, and the refined system doesnât admit a transducer? Of course that was the first thing I checked, but no, the transducer construction works fine.</p>
<p>So, how has my just-written algorithm managed to <em>beat</em> Ping and Kleeâs system of ten tile types?</p>
<p>An obvious way to answer that question would be to match up the tile types in this system against the ones in the 10-hex diagrams. Unfortunately, they donât quite match correctly, because as I mentioned in the <a href="../aperiodic-followup/#h7h8-hat-automorphism">previous article</a>, there are actually <em>two</em> ways you can set up the H7Â /Â H8 system for hats, depending on which neighbour you fuse the reflected hat with â and my presentation of Ping and Kleeâs 10-hex system, unfortunately, happened to pick the other one from the one in the hats paper, before I realised there was a right way to make that decision.</p>
<p>(Ping and Kleeâs <em>own</em> presentation of their system was even stranger: it sawed the reflected hat in two, and assigned half of it to <em>each</em> of the neighbouring tiles! So this poor choice was mine, and not theirs.)</p>
<p>Running the refiner again on the <em>other</em> version of H7Â /Â H8 also generates 8 tile types rather than 10, and this time, it is possible to match them up one by one to the 10-hex system and see what happened. It turns out that the refiner has merged the B and C hex types into a single âBCâ tile, and similarly, merged the G and J hexes into one âGJâ.</p>
<p>If you go back and look in detail at the <a href="../aperiodic-transducers/#hat10">10-hex diagrams</a>, it is true that the B and C hexes expand to the same pattern of other <em>hexagons</em>. But the <em>edges</em> match up differently: the B hex has a spur sticking out of its expansion, and the details of how the edges of the original hexagon map to the crinkly edge of the expansion are quite different from each other. Similarly, G and J expand to the same pattern of hexagons but with different edge mappings. In the final mapping to hats, the B and C hexagons donât work the same as each other either, and neither do G and J.</p>
<p>But in the H7Â /Â H8, there <em>are</em> only two edge types in the whole system, corresponding to the long and short edges of hats. So in that system, the B and C tile types are <em>completely</em> identical, because the difference in edge types isnât there. Theyâre just two tiles of the same shape with the same expansion. And similarly for G and J.</p>
<p>So it <em>looks</em> , to me, as if the reason my refiner managed to get away with fewer tile types is actually <em>because</em> it left the tile shapes as hats (and the fused double-hat), and didnât try to simplify them to hexagons with lots of different edge types. It seems to me that that simplification to hexagons creates extra complication!</p>
<p>By some measure, this is now the most economical substitution system for hats that I know of, among those which admit an unambiguous transducer at all. It uses only 8 metatile types, compared to Ping and Kleeâs 10. The HHTPFFF system gets away with one fewer â only 7 in total â but its metatiles are larger, with most of them expanding to 2 hats, and the two H metatiles expanding to 4. If you measure the systemâs overall complexity by âtotal number of hats in the expansion of all lowest-order metatilesâ â a metric that I only just made up but which seems to account for both types of complexity reasonably well â then this system is now the winner, at 9 hats total, to 11 for Ping and Kleeâs hexagons or 17 for HHTPFFF.</p>
<p>Just to demonstrate this 8-tile system in action, here are the two 6-way singular hat tilings from the <a href="../aperiodic-followup/#hat-singular">previous article</a>, regenerated using a transducer made from it. (Theyâre also the same pair of hat tilings shown in the example at the top of <em>this</em> article, although there, I was focusing on the ambiguity for transducer purposes, rather than the six-way near-symmetry.) In terms of the new tiling system, one of these contains a type-2 hat tile which is the subtile of another type-2 hat forever, and the other contains a type-3 hat similarly. (In both cases, the subtileâs position within the supertileâs expansion is always the bottom right hat in the diagrams above.)</p>
<p>Type 2<img alt="[hat-singular-2.svg]" src="hat-singular-2.svg" /> Type 3<img alt="[hat-singular-3.svg]" src="hat-singular-3.svg" /></p>
<p><img alt="" src="hat-singular-spacer.svg" /></p>
<p>Two six-way singular hat tilings, generated using the 8-tile refinement of H7Â /Â H8</p>
<h2 id="difficult-cases">Difficult cases<a class="headerlink" href="#difficult-cases" title="Permanent link">&para;</a></h2>
<p>I left a loose end somewhere back up there. My refinement algorithm starts by splitting each tile into subtypes depending on its neighbourhood, and I said that âinitiallyâ the neighbourhood would be defined as the tile on the other side of each edge (including which way round it is).</p>
<p>The main property we need from the concept of a âneighbourhoodâ is: <em>given the neighbourhood of a supertile, we need to be able to determine the neighbourhoods of all its subtiles</em>. For example, in the example above, I showed how you do this for a particular subtype of chair tile: draw in all the nearby large tiles according to the supertileâs type, and since all the smaller tiles bordering on each subtile are contained within those larger tiles, thatâs enough information to know the type of every smaller tile.</p>
<p>But I wasnât completely confident that that would be enough information in <em>every</em> case. It worked fine for all the tilings Iâve discussed above, but I could see a way it might <em>not</em> work, in principle.</p>
<p>Again it has to do with those awkward zero-thickness spurs that sometimes poke out of tile expansions. What if a tile <em>X</em> has its neighbour on a particular edge being tile <em>Y</em> , but when both are expanded into subtiles, the part of <em>Y</em> âs expansion bordering <em>X</em> turns out to be nothing but a zero-thickness spur? Then, if you were trying to ask our recursive coordinate transition algorithm what was on the other side of a particular edge of a subtile of <em>X</em> , it might find the spur, and then have to recurse back out of the other side of it to find out what the <em>next</em> large tile was. And that might not be one of <em>X</em> âs immediate edge-to-edge neighbours at all.</p>
<p>This hasnât come up yet in any ârealâ aperiodic tile system. Any spur creates a situation where it <em>nearly</em> happens. But usually, the tile whose spur is adjacent to some edge of <em>X</em> also has some nonzero-thickness part of its expansion adjacent to another part of <em>X</em> âs edge, which means that in spite of the spur you <em>do</em> still have enough information to find out everything you need.</p>
<p>But I couldnât rule out this happening in some other more difficult tiling in future â and I wanted my algorithm to have an answer when it did. So I <em>invented</em> a substitution system designed deliberately to have this annoying property, and then used it as a test case to make sure my code could cope.</p>
<h3 id="the-aawkward-squaresa-substitution-system">The âAwkward Squaresâ substitution system<a class="headerlink" href="#the-aawkward-squaresa-substitution-system" title="Permanent link">&para;</a></h3>
<p>The substitution I devised is a thing I called âAwkward Squaresâ. That was just the working filename I assigned it when I started trying to write one: I wanted it to be awkward to my refinement algorithm. In fact it ended up even more awkward than Iâd expected, so I decided it was a <em>good</em> name, and could stay.</p>
<p>The basic idea of Awkward Squares is that each tile is a simple square. The squares come in two colours, red and blue. Both types of square expand to two red and two blue squares, but in one case, horizontally adjacent pairs of squares are the same colour, and in the other, vertically adjacent.</p>
<p><img alt="[awksq-red.svg]" src="awksq-red.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[awksq-redexp.svg]" src="awksq-redexp.svg" /></p>
<p><img alt="[awksq-blue.svg]" src="awksq-blue.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[awksq-blueexp.svg]" src="awksq-blueexp.svg" /></p>
<p>Substitution rules for the Awkward Squares system</p>
<p>This would be extremely boring, except for that spur poking out at the bottom. Thatâs the awkward part: I did something deliberately silly with the edge mappings.</p>
<p>To begin with, I assigned the horizontal and vertical edges different <em>types</em> , so that each one could be expanded into sub-edges in a different way:</p>
<p><img alt="[awksq-square.svg]" src="awksq-square.svg" /></p>
<p>An Awkward Square, with colours and orientations marked on its edges</p>
<p>There are two distinct edge types here: the horizontal edges (drawn in green, with one arrow), and the vertical edges (in purple with two arrows). Both edge types have a direction, so that traversing them backwards reverses the order of the sub-edges they expand into.</p>
<p>The edge types and arrows also function as matching rules: they constrain the squares in the tiling to join together with the same type of edges meeting each other, and the arrows pointing in the same direction. In this case, the effect is simply to keep all the squares the same way up: rotating one square relative to another isnât allowed. (So far, still nothing awkward â thatâs going out of its way to be <em>simple!</em>)</p>
<p>To expand one square into a square of twice the edge length, the obvious thing would be to expand a horizontal edge into two horizontal edges end to end, and similarly for vertical edges. But instead, Iâve done something different. A horizontal edge expands into two horizontal edges <em>and a vertical one</em>.</p>
<p>On the other hand, the vertical edge behaves normally, expanding to two vertical edges as youâd expect:</p>
<p><img alt="[awksq-h.svg]" src="awksq-h.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[awksq-hexp.svg]" src="awksq-hexp.svg" /></p>
<p><img alt="[awksq-v.svg]" src="awksq-v.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[awksq-vexp.svg]" src="awksq-vexp.svg" /></p>
<p>The rules for expanding horizontal and vertical Awkward Square edges</p>
<p>So when you expand a square, you still <em>do</em> get a larger square which can contain four of the smaller squares:</p>
<p>0<img alt="[awksq-square-0.svg]" src="awksq-square-0.svg" /><img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /><img alt="[awksq-squareexp-0.svg]" src="awksq-squareexp-0.svg" /> 1<img alt="[awksq-square-1.svg]" src="awksq-square-1.svg" /><img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /><img alt="[awksq-squareexp-1.svg]" src="awksq-squareexp-1.svg" /> 2<img alt="[awksq-square-2.svg]" src="awksq-square-2.svg" /><img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /><img alt="[awksq-squareexp-2.svg]" src="awksq-squareexp-2.svg" /> 3<img alt="[awksq-square-3.svg]" src="awksq-square-3.svg" /><img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /><img alt="[awksq-squareexp-3.svg]" src="awksq-squareexp-3.svg" /> 4<img alt="[awksq-square-4.svg]" src="awksq-square-4.svg" /><img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /><img alt="[awksq-squareexp-4.svg]" src="awksq-squareexp-4.svg" /> Tiled<img alt="[awksq-square-filled.svg]" src="awksq-square-filled.svg" /><img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /><img alt="[awksq-squareexp-filled.svg]" src="awksq-squareexp-filled.svg" /></p>
<p><img alt="" src="awksq-square-spacer.svg" /><img alt="" src="../aperiodic-followup/arrow-spacer.svg" /><img alt="" src="awksq-squareexp-spacer.svg" /></p>
<p>Expansion of an Awkward Square outline, one edge at a time</p>
<p>But the effect of the knightâs-move expansion of the horizontal edge is that the next Awkward Square to the <em>right</em> of this one will be placed one (smaller) square lower down, because in that expansion of the edges, the right-hand vertical edge has to start below the baseline of the output square, where the expansion of the bottom horizontal edge ended. So thatâs the part that matches up with the left edge of the next square.</p>
<p>You can also see that in the expansion diagrams above: the large circular blobs in the expansion of the R and B tile types show where the images of the original squareâs vertices are. And those are the points which must match between one tile and the next.</p>
<p>So, suppose you know the types of all four neighbours <em>L</em> , <em>R</em> , <em>U</em> , <em>D</em> of an Awkward Square <em>S</em> of one size. Then hereâs what it tells you about the next size down:</p>
<p><img alt="[awksq-neighbours-big.svg]" src="awksq-neighbours-big.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[awksq-neighbours-small.svg]" src="awksq-neighbours-small.svg" /></p>
<p>An Awkward Square with four neighbours, and its expansion</p>
<p>Whatâs on the right-hand side of the S3 sub-square? Or on the left-hand side of S0? You <em>canât</em> answer this if all you know is which type of tile each of <em>L</em> , <em>R</em> , <em>U</em> , and <em>D</em> is. To tell whatâs on the right of S3, youâd need to know the type of the larger tile diagonally adjacent to <em>S</em> , to the right of <em>U</em> and above <em>R</em>. Similarly, you also need to know whatâs below <em>L</em> and left of <em>D</em>.</p>
<p><em>Formally</em> , whatâs immediately on the right of S3 is the spur poking downwards from the expansion of the U square. Similarly, to the left of S0 is the downward spur from the L square. Itâs just that that doesnât help us find out the identity of the <em>smaller squares</em> that must exist there in a full tiling.</p>
<p>So this is exactly an example of the scenario I suggested at the top of this section: we try to find out whatâs to the right of the S3 subtile, we find itâs a zero-thickness spur of one of the neighbouring supertiles, and then we need to know whatâs on the <em>other</em> side of that spur before we can answer the original question.</p>
<h3 id="extendable-list-of-queries">Extendable list of queries<a class="headerlink" href="#extendable-list-of-queries" title="Permanent link">&para;</a></h3>
<p>My solution to this was to rewrite the part of the algorithm that determines all the necessary information about a tile to decide on its subtype.</p>
<p>In the initial version of the algorithm, that code simply looped over each edge, finding out what was on the far side of the edge. Now it has a list of more general <em>queries</em> that it needs to answer about a tile.</p>
<p>Of course, the initial list of queries is exactly the same as before: whatâs on the far side of each edge? Thatâs the <em>minimum</em> information needed to determine a tileâs subtype.</p>
<p>But then, another piece of code is asked to determine the types of the child tiles expanded from a parent. And the <em>only</em> thing itâs told about the parent tile is the list of answers to the current set of queries. From that alone, it must answer all the same queries about the child tiles.</p>
<p>In the case of the Awkward Squares system, it will find that it canât answer, for the reason shown in the previous section: if all you know is what large tiles borders the parent along its edges, you canât always know what smaller tiles border the children along <em>their</em> edges. So the âdetermine the child subtypesâ code will fail to return an answer â and instead, it will return a description of the question it <em>tried</em> to ask about the parent tile which wasnât answered.</p>
<p>These questions will in general be conditional on an answer to a previous question. For example, the question âWhatâs on the other side of parent edge 3?â might give a tile type as answer which tells the code it must ask about some edge of <em>that</em> tile in turn. So its new question will be along the lines of âGiven that the question about parent edge 3 turned out to be edge 5 of a type-<em>foo</em> tile, whatâs on the other side of edge 4 of <em>that?</em> â. In cases where the question about parent edge 3 has a different answer, the answer to that would be <code>None</code>, or whatever form of ânot applicableâ is appropriate to the programming language.</p>
<p>(These followup queries have to be conditional on the previous queries, because in many substitution systems, tiles arenât all the same shape. If you have to ask a followup question to traverse a spur, it will very likely be specific to the tile type. In Awkward Squares that doesnât come up, because both square types have the same shape of expansion, but in that respect, itâs not as awkward as some systems!)</p>
<p>Unfortunately, once a new query is identified, everything the code <em>thought</em> it knew about the subtypes of tiles becomes invalid, because it doesnât have the answer to the new query for any of them. So it must start all over again, this time including the new query in the list of things it wants to know, right from square one.</p>
<p>In the case of Awkward Squares, we end up with eight extra queries. Basically theyâre the obvious two: what are the upper-right and lower-left diagonal neighbours of the original tile? But the query list has to be different for each original tile type (tiles donât even necessarily have the same number of edges!), and for the type of each tile encountered in a previous query. So the 8 queries cover all combinations of the original tile type (red or blue), which neighbour we initially asked about, and which type it was.</p>
<h3 id="sometimes-you-have-to-refine-more-than-once">Sometimes you have to refine more than once!<a class="headerlink" href="#sometimes-you-have-to-refine-more-than-once" title="Permanent link">&para;</a></h3>
<p>After adding those 8 queries, the refiner restarts from the beginning, runs successfully to completion, and outputs a refined tiling. There are quite a lot of tiles in it, as it turns out: nine copies of the blue tile, and eight copies of the red one.</p>
<p>(That surprised me for an instant â wouldnât you expect the same number of each? But no: the substitution rules treat horizontal and vertical lines differently, so it shouldnât be surprising that tiles behave differently if their expansions are rotated 90Â° so that horizontal and vertical interchange.)</p>
<p>The <em>real</em> surprise came when I tried to make a transducer out of this refined Awkward Squares tiling. It still didnât work!</p>
<p>But all is not lost. On the theory that it was a very easy experiment and worth a try, I simply fed the refinerâs output straight back into <em>another</em> run of the refiner. This time, it cloned only four of the tile types, each into just two copies â¦ and the output of the second run, the doubly-refined tiling, <em>does</em> successfully produce a transducer. Phew!</p>
<p>I donât know that it will be particularly illuminating, but hereâs an example of one of the most difficult ambiguities in the Awkward Squares tiling. This was an ambiguity that the transducer-building code reported was <em>still</em> present in the tiling system even after the first refinement, and only went away in the second one: you can see that the infinite supertile in the bottom left is the same in both pictures except that the top tile on its right-hand edge changes its label between B3.1 and B3.2 â the two subtypes that the <em>second</em> refinement made out of the B3 tile generated by the first one.</p>
<p>Type 1<img alt="[awksq-1.svg]" src="awksq-1.svg" /> Type 2<img alt="[awksq-2.svg]" src="awksq-2.svg" /></p>
<p><img alt="" src="awksq-ambig-spacer.svg" /></p>
<p>Two Awkward Square tilings which the once-refined system still couldnât tell apart.<br />
Two-part tile types like B3.1 indicate that the second refinement split B3 into two.</p>
<p>I canât make much sense of that myself â Awkward Squares didnât include âreadily comprehensible to humansâ in its design goals! But it at least demonstrates the code to be doing what it said it did.</p>
<p>I was a bit surprised when the first run didnât make the tiling unambiguous, but not <em>too</em> surprised. After all, âmake it unambiguousâ was not in the softwareâs actual instructions. All I <em>told</em> the algorithm to do was to bake some conveniently reachable information about each tileâs neighbourhood into the tile type. If that conveniently reachable information wasnât enough to remove all ambiguities, well, who said it would be in the first place?</p>
<p>But if that <em>wasnât</em> enough, then it does make reasonable sense to me that running the refiner again should help. Because the first run included information in each tileâs type about the <em>unrefined</em> types in its neighbourhood â and then the second run includes information in each tileâs type about the types in its neighbourhood <em>as augmented by the first refinement</em>. So each tile now includes information from an even wider radius of the original tiling.</p>
<p>My conjecture is that <em>some</em> number of refinement runs always ought to be enough. Rationale: any infinitely long string of combinatorial coordinates of a tile indicates not only its immediate type, but the type of all its larger and larger supertiles. The more you refine the substitution system, the more information is included about the <em>neighbouring</em> large supertiles. Eventually, surely, youâll end up with the region determined by each coordinate growing on all sides, and then the union of all those regions must cover the whole plane â which is a sufficient criterion for the coordinate string unambiguously defining a single tiling of the whole plane, and not leaving any region less than fully determined.</p>
<p>But thatâs a pretty handwavy argument, and also, I have no idea <em>how many</em> refinements might be needed! It was a surprise to me that the maximum number was more than 1. Is it bounded at all? Who knows!</p>
<h3 id="the-test-case-that-wasnat-a-test-case">The test case that wasnât a test case<a class="headerlink" href="#the-test-case-that-wasnat-a-test-case" title="Permanent link">&para;</a></h3>
<p>One last silly story:</p>
<p>When I was initially testing this refiner, the very <em>first</em> tiling I tested it on wasnât the chair tiling shown above. It was the <a href="https://en.wikipedia.org/wiki/Ammann%E2%80%93Beenker_tiling">Ammann-Beenker tiling</a>: an aperiodic system with two tile types, discovered around the same time as the Penrose tilings, but less famous.</p>
<p>One of the tiles in the Ammann-Beenker tiling is a rhombus with 45Â° and 135Â° angles. Depending on your point of view, the other is either a square, or a pair of mirror-image right triangles which always join along their hypotenuses. Iâve seen both interpretations; I think the squares look nicer, but the triangles make an easier substitution system. (For much the same reason as sawing the Penrose tiles into two triangles â each tileâs expansion fills exactly the same area as the original tile.)</p>
<p>Just like the simple shapes in Penrose tilings, either of those shapes â or both together â could tile the plane periodically, if it werenât for some matching rules, shown by the arrows on the edges below:</p>
<p><img alt="[ammann-beenker-square.svg]" src="ammann-beenker-square.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[ammann-beenker-squareexp.svg]" src="ammann-beenker-squareexp.svg" /></p>
<p><img alt="[ammann-beenker-rhombus.svg]" src="ammann-beenker-rhombus.svg" /> <img alt="[arrow.svg]" src="../aperiodic-tilings/arrow.svg" /> <img alt="[ammann-beenker-rhombusexp.svg]" src="ammann-beenker-rhombusexp.svg" /></p>
<p>Substitution rules for Ammann-Beenker, with the square bisected</p>
<p>(If you prefer to think of the tiling as having one square instead of two triangles, then the double-arrow edges vanish completely, and you just have a square and a rhombus, with all edges being of the same type, and just different patterns of edge directions around the two tilesâ perimeters. Up to you.)</p>
<p>Iâve had this tiling description in my source repository for a year or more. My code wasnât able to build a transducer from it, and I didnât know how to solve that problem by myself, or know of any alternative substitution systems that might happen to eliminate the ambiguity. And itâs a small and simple system, so it made a good first test case â not too large, <em>and</em> if it worked Iâd get rid of a long-standing annoyance.</p>
<p>So I ran my draft refiner over the Ammann-Beenker tiling, and it worked, and generated me a refined tiling that did admit a transducer. Success!</p>
<p>What do you do once youâve built a transducer for a previously ambiguous tiling? You identify a specific ambiguous case from the unrefined substitution system, and use the new transducer to draw both versions of it, to demonstrate that you really have solved the problem. Thatâs what I did for the hat ambiguity, and further up this article I did the same for the chair tiling (and Awkward Squares).</p>
<p>But when I examined the transducer failure report to try to figure out the ambiguous case, I became suspicious. It didnât seem to make sense.</p>
<p>In fact, it turned out that my transducer-construction code simply had a bug: it had <em>given up too soon</em> when trying to build this transducer. The <em>original</em> Ammann-Beenker system, without any refinement, <em>does</em> admit a transducer after all, and it was only a bug in my code that made me think it didnât!</p>
<p>At that early stage, I hadnât written the part of the algorithm which automatically re-merges tile subtypes. So I got an over-refined tiling with lots of subtypes of each tile type, and had to re-merge as many as I could by hand, reverting any change that broke the transducer again. By the time Iâd finished that, I was back down to just one rhombus, and <em>two</em> squares; merging the last two squares caused the transducer construction to fail. But if Iâd had the <em>automated</em> tile-merging code at the time, it would have merged the last two squares anyway, which might have made me suspicious sooner!</p>
<p>Well, regardless of that, the upshot is that now I <em>do</em> have a working Ammann-Beenker transducer, when previously I didnât â even if the reason why wasnât quite what I expected it to be. So I should show some pretty pictures made from it, in celebration. But I canât triumphantly show the two versions of an ambiguous Ammann-Beenker instance, because as it turns out, there arenât any. So instead Iâll just show a couple of particularly symmetric tilings, which also contain infinite supertile boundaries, so it takes a transducer to render them conveniently:</p>
<p>2-way symmetric<img alt="[ammann-beenker-triangle.svg]" src="ammann-beenker-triangle.svg" /> 8-way symmetric<img alt="[ammann-beenker-rhombus0.svg]" src="ammann-beenker-rhombus0.svg" /></p>
<p><img alt="" src="ammann-beenker-spacer.svg" /></p>
<p>Two symmetric instances of the Ammann-Beenker tiling</p>
<p>This tiling is generated from the system shown above, with two rhombuses and a triangle, but I added a one-off mapping layer at the very bottom which maps one of the triangles to nothing and the other to a square. So the supertile boundaries âmorallyâ ought to be straight, but they just swerve around each square they come to.</p>
<h2 id="conclusion">Conclusion<a class="headerlink" href="#conclusion" title="Permanent link">&para;</a></h2>
<p>Iâm very pleased with this piece of work! Itâs a significant advance in the practical uses of substitution-tiling transducers. Now if I hear about a new substitution system and want to try generating instances of it, I donât have to worry if it turns out to be ambiguous. I can just run my new refiner, and most likely get a disambiguated version of it, without needing anyone else to have done the clever part for me.</p>
<p>For example, <a href="https://mathblock8128.wordpress.com/2025/07/13/turtle-tiles-footnote-1-altered-metatiles-and-half-inflations/">a July 2025 blog post by mathBlock</a> shows an interesting alternative substitution system for the hat tiling, which takes <em>two</em> iterations of deflation to have the same effect as a single deflation in any of the normal systems â that is, you can <em>half</em> -deflate a hat tiling, obtaining a tiling thatâs intermediate between the original tiling and its full deflation. That struck me as an interesting thing to investigate: what happens if you half-deflate some of the special instances of the tiling, like the <a href="../aperiodic-transducers/#hats-symm-picture">rotationally symmetric ones</a>, or the <a href="../aperiodic-followup/#hat-singular">âsingularâ nearly-symmetric ones</a>? But when I coded up mathBlockâs system in the form of one of my tiling description files, I tried to build a transducer, and sadly, found it was ambiguous.</p>
<p>That was what inspired me to try out this refiner idea â and it worked, so I was able to produce an unambiguous refinement of mathBlockâs substitution, and use that for my investigations. (And it turns out that some of the symmetric and singular hat patterns half-deflate to <em>each other</em> , which is an interesting finding, and perhaps would have been an alternative way to <em>discover</em> the singular patterns!)</p>







  
    
  
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="最后更新">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1zM12.5 7v5.2l4 2.4-1 1L11 13V7zM11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-iso_date" title="2026年2月5日 11:17:30 UTC">2026-02-05</span>
  </span>

    
    
    
    
  </aside>


  



  <form class="md-feedback" name="feedback" hidden>
    <fieldset>
      <legend class="md-feedback__title">
        这篇文章有帮助吗？
      </legend>
      <div class="md-feedback__inner">
        <div class="md-feedback__list">
          
            <button class="md-feedback__icon md-icon" type="submit" title="有帮助" data-md-value="1">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5 9v12H1V9zm4 12a2 2 0 0 1-2-2V9c0-.55.22-1.05.59-1.41L14.17 1l1.06 1.06c.27.27.44.64.44 1.05l-.03.32L14.69 8H21a2 2 0 0 1 2 2v2c0 .26-.05.5-.14.73l-3.02 7.05C19.54 20.5 18.83 21 18 21zm0-2h9.03L21 12v-2h-8.79l1.13-5.32L9 9.03z"/></svg>
            </button>
          
            <button class="md-feedback__icon md-icon" type="submit" title="没帮助" data-md-value="0">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 15V3h4v12zM15 3a2 2 0 0 1 2 2v10c0 .55-.22 1.05-.59 1.41L9.83 23l-1.06-1.06c-.27-.27-.44-.64-.44-1.06l.03-.31.95-4.57H3a2 2 0 0 1-2-2v-2c0-.26.05-.5.14-.73l3.02-7.05C4.46 3.5 5.17 3 6 3zm0 2H5.97L3 12v2h8.78l-1.13 5.32L15 14.97z"/></svg>
            </button>
          
        </div>
        <div class="md-feedback__note">
          
            <div data-md-value="1" hidden>
              
              
                
              
              
              
                
                
              
              感谢反馈！
            </div>
          
            <div data-md-value="0" hidden>
              
              
                
              
              
              
                
                
              
              感谢反馈！我们会改进。
            </div>
          
        </div>
      </div>
    </fieldset>
  </form>


                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2026 - OpenClaw
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        
<div class="md-social">
  
    
    
    
    
    <a href="https://github.com/mrgolftech" target="_blank" rel="noopener" title="GitHub" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../../..", "features": ["navigation.instant", "navigation.tracking", "navigation.tabs", "navigation.sections", "navigation.expand", "navigation.top", "search.suggest", "search.highlight", "search.share", "content.code.copy", "content.action.edit"], "search": "../../../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.79ae519e.min.js"></script>
      
    
  </body>
</html>