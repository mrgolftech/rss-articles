# Aperiodic Tilings V: the Refinable Frontier

**来源:** https://chiark.greenend.org.uk/~sgtatham
**链接:** https://www.chiark.greenend.org.uk/~sgtatham/quasiblog/aperiodic-refine/
**日期:** 2025-09-02T00:00:00+00:00

---

# Aperiodic Tilings V: the Refinable Frontier

[Simon Tatham, 2025-09-02]

[Part of a series: [Penrose and hats](../aperiodic-tilings/) | [Spectres](../aperiodic-spectre/) | [finite-state transducers](../aperiodic-transducers/) | [more transducers](../aperiodic-followup/) | **refining tilings** ]

  * Introduction
    * Recap
  * Ambiguous substitution systems
    * Refining the set of tile types
  * Making refined substitution systems from scratch
    * Clues to the secret
    * Neighbourhood-based refinement
    * Reducing the set of subtypes
  * Trying it out on real aperiodic tilings
    * The auto-refiner rediscovers HHTPFFF from first principles
    * It figures out the Spectre 9-hex system too
    * And now look what happens with hats!
  * Difficult cases
    * The âAwkward Squaresâ substitution system
    * Extendable list of queries
    * Sometimes you have to refine more than once!
    * The test case that wasnât a test case
  * Conclusion



## Introduction

(I know, I know. Iâm running out of title ideas.)

This is article #5 in my series about generating aperiodic tilings using string-processing techniques. Every time, thereâs more to recap from the previous ones. So Iâm just going to start with the introduction to _this_ article, and fill in the recap in a moment.

In the previous two articles Iâve talked about using a finite-state transducer to move around a tiling, tracking your current position as a string of combinatorial coordinates, and using the transducer to update the coordinate string as you step from each tile to the next. These transducers are ideally _deterministic_ , generating a unique output coordinate string given any legal input. But not every substitution system admits a deterministic transducer: different systems describing the same actual _tiling_ may or may not unambiguously identify the neighbouring coordinates of every tile in every situation.

What do you do if your substitution system _doesnât_ work with this technique? In the past, Iâve had to depend on luck. Some systems I wanted to use happened to work already; in cases where the system I started with didnât work, someone else found an alternative system that did (though I think that was luck too, and this wasnât the property they were specifically after).

In this article Iâm going to talk about a technique for solving the problem without needing to depend on luck: if you have an ambiguous substitution system, you can _construct_ a variation of it which is unambiguous, and make a transducer out of that instead.

### Recap

I just said that thereâs more to recap every time from previous articles. But itâs not _quite_ true, because some of those articles contained ideas that Iâve now decided are superseded by better thoughts I had later. If you were to go back and re-read the whole lot, there would be entire sections Iâd recommend skipping. So here Iâll try to summarise the _useful_ parts.

This whole project has focused on tilings of the plane generated by _substitution systems_. A substitution system is a set of rules that allow you to turn each tile of tiling _A_ into a cluster of tiles in tiling _B_ , in a consistent way (each _type_ of tile is transformed into the same cluster every time), and also specifies how those clusters fit next to each other when theyâre expanded from neighbouring tiles. (Examples from previous articles: [Penrose](../aperiodic-tilings/#ccoords-penrose), [Spectre](../aperiodic-spectre/#hextransitions), [hats](../aperiodic-transducers/#hats-nonoverlapping), [hats done differently](../aperiodic-transducers/#hat10).)

So in principle â in the ideal world of mathematics where infinite processes can be imagined â you can take an entire infinite tiling of the plane, and apply these substitution rules to make a different complete tiling derived from the first one. Iâve been calling this âexpansionâ; mathematicians often say âdeflationâ.

More practically, you can take just _one_ tile, and expand it repeatedly via the substitution system to turn it into a large patch of your tiling. This is a common technique for actually generating patches of (say) Penrose tilings in software.

But this series of articles has been about a better approach. If you have a tiling that was (or could have been) _generated_ by iterating a substitution system â and with the famous aperiodic tilings like Penrose and hats, _every_ tiling of the plane has this property â you can describe the _combinatorial_ position of a tile in terms of the substitution system, by describing its position in the hierarchy of expansions. First say what type the tile _T_ 0 itself is; then say how it was generated from its supertile _T_ 1, by giving the type of _T_ 1 and also saying which tile is _T_ 0 in the cluster of multiple tiles expanded from _T_ 1. Then describe how _T_ 1 was generated from its parent _T_ 2 in turn, via another (tile type, subtile index) pair, and so on.

Once you have a string of âcombinatorial coordinatesâ describing a tile _T_ , it turns out that you can calculate the coordinates of a neighbouring tile _U_ by several algorithms Iâve described in previous articles, all of which operate only on the string of coordinates, without having to think about geometry at all. So you can generate a patch of tiling that occupies a given region of the plane by generating each tile on demand as you find you need it, which is much more efficient than generating a much larger piece of tiling and then throwing most of its tiles away.

The [first of these algorithms](../aperiodic-tilings/#recursive-algorithm) is recursive: ascend the hierarchy until you find a single supertile whose expansion contains both _T_ and _U_ , so that the coordinates of _T_ and _U_ are identical from that point onwards; then unwind the algorithmâs stack, generating the new set of low-order coordinates that describe _U_. The low-order part of this procedureâs output tells you which type of tile _U_ actually is, and which edge of _T_ is adjacent to which edge of _U_ , so you know what tile to draw where in your output diagram. Then the rest of the output coordinate string contains enough information to run the algorithm again to step to _U_ âs neighbour in turn, and so on.

You can use that recursive algorithm directly in simple cases, but I prefer a more sophisticated technique based on finite state machines, which requires more setup but is faster and simpler at run time, and can also handle special cases in which the recursion would never terminate. The first step of that is to use data obtained from the recursive algorithm to [build](../aperiodic-followup/#adjrec-dsf) a thing I call an âadjacency recogniserâ. Thatâs a finite state machine which takes the coordinates of _two_ tiles _T_ and _U_ , as if combined by Python `zip()`, and accepts or rejects depending on whether the two coordinate strings describe neighbouring tiles.

You can also [imagine](../aperiodic-transducers/#nondeterministic-transducer) the adjacency recogniser as a state machine which takes _T_ alone as input, by reinterpreting the input _U_ as output. But this state machine is nondeterministic: there isnât a unique output for all possible inputs. So next you try to [transform it](../aperiodic-transducers/#determinisation) into a _deterministic_ finite-state transducer, and see if that works.

A deterministic transducer, if you can build one, is my current gold standard for the best way to generate patches of tiling. Itâs fast, simple (once youâve built it), never needs to backtrack, and can cross [âinfinite-order supertileâ boundaries](../aperiodic-transducers/#infinite-boundary) â a phenomenon that comes up in special cases of these tilings, where no finitely large supertile contains any two tiles on opposite sides of the boundary. The recursive algorithm canât handle a case like that at all, but a deterministic transducer can bypass one of those boundaries effortlessly, and find the unique infinite-order supertile that fits to the far side in such a way that every patch of tiling along the border is consistent with how the tiles normally fit together.

But for some systems you [canât build a deterministic transducer](../aperiodic-transducers/#hats-ambiguity), because not every infinite-order supertile boundary _has_ a unique neighbour: there exists some infinite string of coordinates which describes only part of the plane, and _multiple_ options for what goes on the other side. I call a substitution system of this kind _ambiguous_.

## Ambiguous substitution systems

In previous articles, Iâve shown two cases of this kind of ambiguity. [One occurred](../aperiodic-transducers/#htpf-ambiguity) in the original HTPF system of metatiles for the hat tiling; [the other](../aperiodic-followup/#spectre-h7h8-ambiguity) was in the minimalist H7Â /Â H8 substitution system for the Spectre tiling. In each case, thereâs an infinite-order supertile boundary (shown as a thick line in the diagrams), with one side of the boundary fixed, and multiple possibilities for the other side.

To refresh your memory, hereâs the hat example again:

(F,Â 5) and (H,Â 7) supertiles![\[hats-f5-h7.svg\]](hats-f5-h7.svg) (F,Â 5) and (H,Â 8) supertiles![\[hats-f5-h8.svg\]](hats-f5-h8.svg)

![](hats-f5-spacer.svg)

The two possible infinite hat supertiles that can go with (F,Â 5)

### Refining the set of tile types

What do you do if you want to use a deterministic transducer on one of those tilings? In both cases, my previous articles provide an answer: you can switch to a substitution system very like the previous one, but with additional types of tile. Iâm going to call this a _refinement_ of the previous system.

In the HTPF case, I presented a [substitution system of my own](../aperiodic-followup/#hhtpfff), which I called âHHTPFFFâ. It looks just like [the non-overlapping version of the standard HTPF system](../aperiodic-transducers/#hats-nonoverlapping-spec), except that the H tile type has been cloned into two subtypes H0 and H1, and the F tile has been cloned into three, F0, F1 and F2. (And the difficult part, which is mostly what Iâm going to end up discussing in this article, is deciding which version of H and F should appear in which expansion diagrams.)

![\[hat-hhtpfff-H0.svg\]](hat-hhtpfff-H0.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[hat-hhtpfff-H0exp.svg\]](hat-hhtpfff-H0exp.svg)

![\[hat-hhtpfff-H1.svg\]](hat-hhtpfff-H1.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[hat-hhtpfff-H1exp.svg\]](hat-hhtpfff-H1exp.svg)

![\[hat-hhtpfff-T.svg\]](hat-hhtpfff-T.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[hat-hhtpfff-Texp.svg\]](hat-hhtpfff-Texp.svg)

![\[hat-hhtpfff-P.svg\]](hat-hhtpfff-P.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[hat-hhtpfff-Pexp.svg\]](hat-hhtpfff-Pexp.svg)

![\[hat-hhtpfff-F0.svg\]](hat-hhtpfff-F0.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[hat-hhtpfff-F0exp.svg\]](hat-hhtpfff-F0exp.svg)

![\[hat-hhtpfff-F1.svg\]](hat-hhtpfff-F1.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[hat-hhtpfff-F1exp.svg\]](hat-hhtpfff-F1exp.svg)

![\[hat-hhtpfff-F2.svg\]](hat-hhtpfff-F2.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[hat-hhtpfff-F2exp.svg\]](hat-hhtpfff-F2exp.svg)

Substitution rules for the HHTPFFF hat system

If youâre using _this_ system, then what happens to the HTPF coordinate sequence that led to the ambiguity? The sequence in question was (F,5) repeated endlessly: that is, an F metatile which is child #5 of a larger F in turn, and so on forever. But in the more detailed HHTPFFF system, now you have to say _which_ kind of F metatile you mean: you can either have an F0 which is child #5 of another F0 forever, or an F1 which is child #5 of another F1. (Thereâs no third option involving type F2, because child #5 of F2 is an F1, not another F2.)

And whichever of those options you pick, the HHTPFFF system only allows _one_ possibility for the coordinates of the tile on the far side of the boundary. So weâve removed the ambiguity, by forcing the user to specify which version of (F,5) they meant.

(F1,Â 5) and (H0,Â 7) supertiles![\[hats-f5-refined-h7.svg\]](hats-f5-refined-h7.svg) (F0,Â 5) and (H1,Â 8) supertiles![\[hats-f5-refined-h8.svg\]](hats-f5-refined-h8.svg)

![](hats-f5-spacer.svg)

The same two hat tilings, specified in the HHTPFFF system.  
Each tile shows its containing metatile type and a hat index within that metatile.

(Of course, this doesnât mean that only one set of tiles fits _physically_ to the far side of the boundary. The infinite supertiles (F0,5) and (F1,5) occupy exactly the same shape of region in the plane, so each one fits perfectly to the other oneâs official neighbouring supertile. But if you fit one to the wrong neighbour, the tile types arenât consistent across the border: pairs of adjacent tiles occur which are never seen in any finitely large patch expanded from a single metatile. Transducers insist on maintaining _that_ type of consistency.)

In the case of the Spectre H7Â /Â H8 system, I didnât even have to make up a substitution system of my own. The discoverers of the Spectre tiling had long since done it for me: the system of 9 hexagonal metatiles in the original Spectre paper essentially _is_ a refinement of the H7Â /Â H8 system. And itâs already unambiguous in this sense, so it allows a transducer to be constructed.

## Making refined substitution systems from scratch

When I wrote the previous articles, I didnât know _how_ to construct an unambiguous refinement of an ambiguous substitution system.

That seems like an odd thing to say, given that I just said I _had_ constructed one myself â the HHTPFFF system. But I didnât do it from scratch: I had help. Bowen Ping and Brad Klee had already discovered [a completely different unambiguous system for hats](/aperiodic-transducers/#hat10) involving 10 types of hexagonal metatile. I derived the HHTPFFF system by looking at the correspondence between HTPF and those 10 hexagon types, and spotting that the H metatile in one system didnât always correspond to the same group of hexagons in the other â there were two different clusters of hexagons occupying the space of an H metatile, and three different clusters corresponding to an F.

In other words, I made an unambiguous HTPF-like system by combining the original HTPF system with another system that was already unambiguous. I didnât _create_ the lack of ambiguity: I just copied it from one place to another.

In fact, I had previously _tried_ to make an HHTPFFF-type system from scratch by hand, when I first discovered HTPFâs ambiguity. I was attempting exactly this kind of thing: split each tile into multiple types and somehow figure out which ones have to appear where in which expansion diagrams. I didnât manage to solve the problem by hand. In fact, I eventually began to suspect it wasnât possible, and gave up trying.

But it _was_ possible, as it turned out. I just hadnât found it by manually searching the large space of possible refinements, and I didnât know of any principled approach to finding it _without_ having to search a large space.

Well, now I do know! In fact, better than that: Iâve automated the process. Iâve found an _algorithm_ , and implemented it in software, which can make an unambiguous version of a substitution system, given an ambiguous one as input.

At least, itâs worked on every ambiguous system Iâve tried so far, including an extra-awkward one I made up myself.

### Clues to the secret

Iâll start by describing the clues that gave me the idea I ended up with.

After I published the previous article including a specification of the HHTPFFF tiling, I had a response on Mastodon from [mathBlock](https://mathstodon.xyz/@mathBlock), who had been studying a different property of the HTPF tiles, which they called â[drainage](https://mathstodon.xyz/@mathBlock/110653707540128465)â â if I havenât totally misunderstood, it was about interpreting the tile outlines as contour lines and imagining how rivers of water would run down them. mathBlock had found that the HTPF metatile system didnât provide quite enough information to determine the drainage: P metatiles always behaved in a consistent way, but F metatiles could do more than one thing, depending on where they appeared in the tiling. It turned out that my division of the F metatiles into F0, F1 and F2 seemed to match up to the different drainage behaviours.

I must admit that I never quite fully understood what the idea of drainage was useful for. But I know that what it _was_ had to do with the neighbourhood of the tiles. What distinguishes the F0, F1 and F2 metatiles is: after you expand each one into two hats, look at [two particular convex vertices](https://mathstodon.xyz/@mathBlock/112806677484242025) of the resulting shape. Each one either meets two convex vertices of other hats, or meets a concave vertex of a single hat. Depending on which of those vertices do which, the metatile is either F0, F1 or F2. Similarly, a single vertex on the edge of the expansion of the H metatile into hats distinguishes H0 from H1.

In fact, it turns out that in each case thereâs only one way that the neighbouring hat or hats around that vertex can be oriented. For example, here are the three subtypes of F, with the neighbouring hats around those vertices shown: 

F0![\[hats-f-subtypes-F0.svg\]](hats-f-subtypes-F0.svg) F1![\[hats-f-subtypes-F1.svg\]](hats-f-subtypes-F1.svg) F2![\[hats-f-subtypes-F2.svg\]](hats-f-subtypes-F2.svg)

![](hats-f-subtypes-spacer.svg)

The three subtypes of F, and their forced hat neighbours around two particular vertices

We can check those diagrams against the ambiguous pair of (F,5) tilings I showed earlier. Here are those ambiguous tilings again, this time zoomed in to show the two hats expanded from the âcentralâ F metatile (the one which is child #5 of another F all the way up), with the two critical vertices marked as shown in the diagrams above:

(F1,Â 5) and (H0,Â 7) supertiles![\[hats-f5-refined-zoom-h7.svg\]](hats-f5-refined-zoom-h7.svg) (F0,Â 5) and (H1,Â 8) supertiles![\[hats-f5-refined-zoom-h8.svg\]](hats-f5-refined-zoom-h8.svg)

![](hats-f5-spacer-zoom.svg)

Detail of the ambiguous supertile boundary, with crucial F vertices marked

You can see that the hats on the other side of the boundary meet this F metatile in a way thatâs consistent with the diagrams here. When the F metatile is an F1, the marked vertex of its hat #0 meets a concave corner of a hat (as it happens, labelled H0.0); when itâs F0, the same vertex meets convex corners of two hats (P.1 and H1.2). Meanwhile, the marked vertex of hat #1 meets convex corners of two hats in both cases, as weâd also expect from the previous diagrams (it would only meet a concave corner in the F2 subtype). So this even shows us _how_ specifying the subtype of F tile has disambiguated the far side of the boundary: of the two possibilities, each is only consistent with one of F0 and F1.

So this was my first clue that in one of these refined tilings, the subtype of a tile is related in some way to _what its neighbouring tiles are_.

What about the Spectre 9-hex system, which is pretty much a disambiguating refinement of the H7Â /Â H8 system?

The same is true there. In fact, the original Spectre paper says outright that the 9 hexagon types were _derived_ by looking at the neighbourhood of each tile in the overall tiling.

And this also makes perfect sense from first principles. What problem were we originally trying to solve? The existence of a tile coordinate with more than one possible neighbour. How might you solve that? By making two (or more) copies of the tile and simply _ruling_ that each one is only allowed to have a certain kind of neighbour. The F0 tile is the one which can be next to an H tile _this_ way round, and not _that_ way round; the F1 tile, _vice versa_.

That sounds like a pretty short thought process, now that I write it down. But initially these thoughts were very vague. (Not to mention that Iâd forgotten that detail from the Spectre paper, and had to go and read it again before I noticed it!) I turned them over in my head for months before becoming gradually more confident that this was an idea that would work. Then I had to get from the general idea of âlook at the neighbourhoods of the tilesâ to a concrete plan for how to determine those neighbourhoods and exactly what to do about them. And even then I didnât get round to trying it, until I heard of another ambiguous substitution system that I wanted to try it on.

### Neighbourhood-based refinement

The idea I settled on, as a technique for automated tiling refinement, was to make subtypes of each tile based on its _whole_ neighbourhood. For each tile type in your original system, make a lot of clones of it, one for each possible pattern of _all_ of its neighbouring tiles. Initially, by âneighbouring tilesâ, I mean: for each edge of the tile, what type of tile is on the other side of that edge, and in what orientation?

As a worked example, Iâm going to use a substitution system I havenât shown in these articles before, because itâs usually too simple to be interesting, but here itâs just the right size to not be overwhelming. Itâs the âchairâ substitution system from Chaim Goodman-Straussâs 1999 paper â[Aperiodic hierarchical tilings](https://strauss.hosted.uark.edu/papers/AHT.pdf)â. The chair system has just one type of tile, and a single substitution rule that tiles a chair with four half-sized chairs:

![\[chair-parent.svg\]](chair-parent.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[chair-exp.svg\]](chair-exp.svg)

The substitution rule for the chair tiling

(The chair tile isnât an _aperiodic tile_ , in the way that hats or Spectres are. It _can_ tile the plane non-periodically, but it doesnât _force_ non-periodicity: there are also periodic tilings using the same tile type. But the particular tilings generated by this substitution system are hierarchical rather than periodic.)

So our first task is to analyse this substitution system to find every possible way that a chair tile can be surrounded by other tiles, and make a different subtype of the chair tile for each pattern. In this case, it turns out that there are seven different patterns, shown here:

![\[chair-neighbourhood-chair1.svg\]](chair-neighbourhood-chair1.svg)

![\[chair-neighbourhood-chair2.svg\]](chair-neighbourhood-chair2.svg)

![\[chair-neighbourhood-chair3.svg\]](chair-neighbourhood-chair3.svg)

![\[chair-neighbourhood-chair4.svg\]](chair-neighbourhood-chair4.svg)

![\[chair-neighbourhood-chair5.svg\]](chair-neighbourhood-chair5.svg)

![\[chair-neighbourhood-chair6.svg\]](chair-neighbourhood-chair6.svg)

![\[chair-neighbourhood-chair7.svg\]](chair-neighbourhood-chair7.svg)

The seven different neighbourhoods of a chair tile

To be clear, those arenât _all_ of the possible patterns of chair tiles that can possibly surround another chair. Theyâre not even all the possible patterns that can arise in the context of a tiling of the whole plane. But theyâre all the patterns that can arise in a tiling _generated by iterating this substitution_ â they were found by analysing the substitution system itself, and only considering possibilities that that system can generate.

The above analysis tells us what subtypes need to _exist_. But in order to completely specify the refined system, we must also look at the expansion of each tile into smaller tiles, and for each smaller tile, specify which clone of the original type it is.

To do that, we look at the original tile, and whatever neighbours a particular subtype assigns it; expand all of those into their subtiles via the original substitution system; and then, typically, thatâs enough information to find all the neighbours of the subtiles we need to know.

For example, letâs take the above diagram for chair type 1 and its neighbours; expand all the tiles in the diagram into subtiles; and then we can determine the type of each of the central chairâs subtiles, based on its neighbours.

Supertiles![\[chair-classify-start.svg\]](chair-classify-start.svg) Subtiles![\[chair-classify-expand.svg\]](chair-classify-expand.svg) Bottom left![\[chair-classify-bl.svg\]](chair-classify-bl.svg) Bottom right![\[chair-classify-br.svg\]](chair-classify-br.svg) Top right![\[chair-classify-tr.svg\]](chair-classify-tr.svg) Middle![\[chair-classify-mid.svg\]](chair-classify-mid.svg)

![](chair-classify-spacer.svg)

Deciding the subtypes of smaller chairs for a type-1 larger chair

If we do that for the other six tile types too, we end up with this complete 7-tile substitution system:

![\[chair-unreduced-chair1.svg\]](chair-unreduced-chair1.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[chair-unreduced-chair1-exp.svg\]](chair-unreduced-chair1-exp.svg)

![\[chair-unreduced-chair2.svg\]](chair-unreduced-chair2.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[chair-unreduced-chair2-exp.svg\]](chair-unreduced-chair2-exp.svg)

![\[chair-unreduced-chair3.svg\]](chair-unreduced-chair3.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[chair-unreduced-chair3-exp.svg\]](chair-unreduced-chair3-exp.svg)

![\[chair-unreduced-chair4.svg\]](chair-unreduced-chair4.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[chair-unreduced-chair4-exp.svg\]](chair-unreduced-chair4-exp.svg)

![\[chair-unreduced-chair5.svg\]](chair-unreduced-chair5.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[chair-unreduced-chair5-exp.svg\]](chair-unreduced-chair5-exp.svg)

![\[chair-unreduced-chair6.svg\]](chair-unreduced-chair6.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[chair-unreduced-chair6-exp.svg\]](chair-unreduced-chair6-exp.svg)

![\[chair-unreduced-chair7.svg\]](chair-unreduced-chair7.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[chair-unreduced-chair7-exp.svg\]](chair-unreduced-chair7-exp.svg)

The chair tiling after refinement

And if we feed this refined version of the chair tiling to my transducer-building code, it works! The original chair tiling didnât admit a transducer, but the refined one does.

Why didnât the original tiling admit a transducer? Because there exists at least one infinite supertile boundary where itâs ambiguous whatâs on the far side. Hereâs one: expand a chair into four chairs, at every stage keeping the bottom right corner fixed, so that you occupy one quadrant of the plane.

0![\[chair-incremental-0.svg\]](chair-incremental-0.svg) 1![\[chair-incremental-1.svg\]](chair-incremental-1.svg) 2![\[chair-incremental-2.svg\]](chair-incremental-2.svg) 3![\[chair-incremental-3.svg\]](chair-incremental-3.svg) 4![\[chair-incremental-4.svg\]](chair-incremental-4.svg) 5![\[chair-incremental-5.svg\]](chair-incremental-5.svg)

![](chair-incremental-spacer.svg)

Building up an infinite supertile of chairs

In the refined system, in order to describe that infinite supertile in the first place, you have to choose which _subtype_ of chair youâre talking about at every level. Chair types 3 and 7 are the only two types that ever appear in the bottom right of another chair, and each of those has a bottom right subtile of the same type as itself. So you have the choice of a type-3 chair with type-3 supertiles forever, or a type-7 one with type-7 supertiles.

Either way, the ambiguity is removed, because each of those tile types embodies a strong opinion about what must appear to its bottom right. In the neighbourhood diagrams above, you can see that the type-3 chair tile appears âback to backâ with two other chairs, adjacent to each along a whole long edge. But the type-7 tile nestles in the concave corner of another chair. And in the diagrams below, if you look at the tile at the bottom right corner of the top-left quadrant, you can see that the same is true: when itâs type 3, there are two more type 3s back-to-back with it on the far side of the supertile boundary, but when itâs type 7, thereâs a type 4 cuddling its corner.

Type 3![\[chair-3.svg\]](chair-3.svg) Type 7![\[chair-7.svg\]](chair-7.svg)

![](chair-ambig-spacer.svg)

Tilings containing the two disambiguated versions of that infinite supertile

Similarly to previous cases ([Spectre](../aperiodic-followup/#spectre-h7h8-ambiguity), [hat 10-hex](../aperiodic-transducers/#hat10-ambig-diagram)), we can see that the far side of the boundary doesnât have the same infinite supertile structure in both cases. In the type 3 version of the picture, four identical supertiles meet back to back in a 4-way symmetric tiling of the plane; in the type 7 version, the supertile we started with occupies one quadrant of the plane, and a single neighbour supertile occupies the other three quadrants. (That other supertile is constructed in a very similar way to the first one, except that we keep the _concave_ vertex of the chair fixed at every stage instead of the bottom right vertex.)

Also similarly to previous cases, we see that _most_ of the variable side of the boundary doesnât actually vary! Almost all the chair tiles are the same in both diagrams, with the only changed ones being along a small number of narrow paths â in this case, three of the four diagonals out from the centre of the tiling (excluding the one in the top left, which belongs to the fixed supertile we started with).

That diagram is my excuse for this articleâs terrible pun title, incidentally. We had a substitution system we couldnât make a transducer for, meaning we couldnât find out what was on the other side of that infinite supertile boundary; then we applied our shiny new algorithm to refine the tiling, and that enabled us to build a transducer and use it to cross the barrier. Perhaps more specifically, it became possible to cross the barrier once weâd distinguished _which_ of two very similar barriers it actually was. So it _was_ a refinable frontier, so there.

### Reducing the set of subtypes

Thatâs proved the concept, at least. This refinement technique seems to _work_ : it produces a version of the original tiling which allows a deterministic transducer to be constructed, even if the original tiling didnât. (I have no proof that it works in all possible cases, but at this stage itâs worked in one, and thatâs one more than I previously knew how to do!)

But you end up with a _lot_ of tile subtypes. The reason I used the chair tiling as my example in the previous section is that anything bigger wouldnât have fitted. The results of running this algorithm on the HTPF system delivers a set of _21 tile types_ in total: 7 kinds of H, 5 kinds of P and 8 kinds of F (but still only one kind of T). And we _know_ thatâs more than we need, because Iâd already found the HHTPFFF system, with only one kind of P, and two H and three F!

Looking at the output, one thing I immediately noticed was that some of the output tile types had exactly the _same_ expansion as each other. For example, in the chair tiling shown above, chair types 1, 2 and 3 all expand to exactly the same pattern, and so do types 5, 6 and 7.

So that led to the idea: what if we postprocess the refined system by merging tile types that have identical expansions?

This _shouldnât_ reintroduce ambiguity, because the aim is to distinguish what happens at the _lowest_ level, in the final output tiling, and higher-order supertiles are only interesting in what they eventually expand to. (A handwave rather than a proof, but enough to make it look worth a try.)

Of course, merging some tile types might make _further_ expansion diagrams identical, if they only differed in subtile types which we just merged into one. So we iterate the merging process if necessary, until we reach a fixed point.

For example, after re-merging those sets of identical subtypes in the chair tiling, the 7 subtypes of chair tile are reduced to only 3:

![\[chair-reduced-chair1.svg\]](chair-reduced-chair1.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[chair-reduced-chair1-exp.svg\]](chair-reduced-chair1-exp.svg)

![\[chair-reduced-chair2.svg\]](chair-reduced-chair2.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[chair-reduced-chair2-exp.svg\]](chair-reduced-chair2-exp.svg)

![\[chair-reduced-chair3.svg\]](chair-reduced-chair3.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[chair-reduced-chair3-exp.svg\]](chair-reduced-chair3-exp.svg)

The chair tiling after refinement and reduction

The reduced set of tile types no longer encapsulate _all_ the information about each tileâs neighbourhood. But they still contain just enough of it to make a transducer work. To prove it, here are the same two tilings as above, regenerated using the reduced system:

Type 1![\[chair-1.svg\]](chair-1.svg) Type 2![\[chair-2.svg\]](chair-2.svg)

![](chair-ambig-spacer.svg)

The two chair tilings from above, in the reduced system

(I have to admit that the rainbow versions of these pictures in the previous section were prettier! But the system with fewer tile types is more practical.)

You might wonder: what do these reduced types _mean?_ We had a clear idea what the original seven chair subtypes meant: each one went with a specific diagram of how the chairs around it were arranged. But now that weâve merged some of those subtypes into one, what information does a merged subtype convey, apart from âthe tiles around it can be in one of [this potentially long list of patterns]â?

I think the answer is that a reduced tile type still tells you _something_ about the neighbourhood of the original tile â but it doesnât tell you everything about what tiles _of the same size_ surround it. Instead, weâve narrowed down to only saying something about the surrounding _smaller_ tiles, at the next expansion level down. You can see an example of this in an earlier section, where I showed the three subtypes of F in the HHTPFFF tiling: choosing one of those three subtypes doesnât nail down exactly what _metatiles_ surround the F, but it does tell you something about which _hats_ surround it. And not even on all sides: only at a small number of positions where the answers are crucial to telling the difference between something important.

## Trying it out on real aperiodic tilings

This is all very well, and has given us a pretty picture or two, but the chair tiling isnât all that interesting, because itâs not a _real_ aperiodic tile: there are plenty of other ways to tile the plane with chairs which arenât derived from the substitution system above, and many of those are periodic. In that respect itâs unlike Penrose tilings, or hats, or Spectres, which all have the property that the _only_ ways you can tile the plane with those tiles are derived from their substitution systems. So those are the interesting ones to study.

So, now weâve got a refinement algorithm that works on a small toy example of an ambiguous substitution system, how does it do when run on the cases we actually care about?

Answer: it does brilliantly!

### The auto-refiner rediscovers HHTPFFF from first principles

As I mentioned above, when I ran the _first_ stage of this refinement algorithm on the HTPF system of hat metatiles, it divided each metatile type into many more subtypes than necessary (apart from T, which remained unique). We got seven kinds of H, five P, and eight F, making 21 types of metatile in total.

But when I ran the postprocessing reduction pass, _most_ of those subtypes ended up merging with each other again. Guess how many we ended up with?

We ended up with exactly _seven_ tile types: the single T, two H, three F, and back down to a single P.

And thatâs exactly the same set of tile types as in the HHTPFFF system Iâd already found without this refinement algorithm. This automated analysis can do in a fraction of a second what I spent weeks failing to do in 2023: starting from _only_ the HTPF system itself, itâs able to construct an unambiguous, transducer-capable refinement of it, without needing any input from someone who had already discovered an unambiguous substitution system of any other kind. Moreover, it finds exactly the _same_ one: no pointless extra tile types. (On _either_ side.)

### It figures out the Spectre 9-hex system too

Iâve already mentioned a second ambiguous substitution system: the H7Â /Â H8 substitution system for the Spectre tiling. In [the previous article](../aperiodic-followup/#spectre-h7h8-ambiguity) I used the ambiguity to zero in on one of the particularly interesting instances of the Spectre tiling.

To recap the H7Â /Â H8 substitution system: it contains just two types of metatile. One is just a single Spectre; the other is the âMysticâ, two Spectres oriented at a 30Â° angle to each other and glued together into a double-sized tile. The expansion diagrams look like this:

![\[spectre-h7h8-Spectre.svg\]](spectre-h7h8-Spectre.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[spectre-h7h8-Spectreexp.svg\]](spectre-h7h8-Spectreexp.svg)

![\[spectre-h7h8-Mystic.svg\]](spectre-h7h8-Mystic.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[spectre-h7h8-Mysticexp.svg\]](spectre-h7h8-Mysticexp.svg)

Substitution rules for the Spectre H7Â /Â H8 system

A warning: these expansion diagrams are more complicated than they look, because â to put it mildly â itâs not obvious at all how the edges of the single Spectre or Mystic match up to the crinkly edges of the expansion. As well as the exterior spurs shown, thereâs also an interior spur in the Mystic expansion, and even a section of boundary which is traversed _three_ times, twice in one direction and once in the opposite direction in between. All of that detail is very difficult to show in a single diagram: if I labelled all the edges and sub-edges, as I did for the [HTPF system](../aperiodic-transducers/#hats-nonoverlapping-spec) in a previous article, the numbers would all overlap each other and it would still look horribly confusing. If you want to understand how the edges match up, my best suggestion is to go back to the [diagrams in my previous article](../aperiodic-followup/#h7h8-spectre-automorphism), where I showed the outline of each of these expansions being built up one edge at a time.

My _first_ attempt to write the auto-refiner algorithm couldnât handle this system at all, because when it was trying to find all the neighbour patterns it got stuck on even simple spurs â and this tiling has the worst spurs of all. Indeed, I wrote in an early commit message that this system (and its hat analogue) would be âthe boss levelâ of the concept. But then I found a better way to do the analysis which doesnât care about spurs, so I beat the boss fight in the end!

So my current refiner code runs quite happily, given this substitution system as input. It splits the plain Spectre metatile into eight versions, and leaves the Mystic unique, for a total of nine tile types. And it turns out that those nine tile types correspond _exactly_ to the nine hexagon types described in the Spectre paper. Iâve shown the refined system here with my own Latin-alphabet labels for the tile types (and the original Greek ones too in the large tile pictures, in case thatâs useful). And Iâve used the same colour scheme as I used in [my Spectre article in 2023](../aperiodic-spectre/#hextransitions). So you can go back to that older article and easily check that all the expansion maps agree, if you want.

![\[spectre-h7h8-refined-Mystic.svg\]](spectre-h7h8-refined-Mystic.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[spectre-h7h8-refined-Mysticexp.svg\]](spectre-h7h8-refined-Mysticexp.svg)

![\[spectre-h7h8-refined-Spectre1.svg\]](spectre-h7h8-refined-Spectre1.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[spectre-h7h8-refined-Spectre1exp.svg\]](spectre-h7h8-refined-Spectre1exp.svg)

![\[spectre-h7h8-refined-Spectre8.svg\]](spectre-h7h8-refined-Spectre8.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[spectre-h7h8-refined-Spectre8exp.svg\]](spectre-h7h8-refined-Spectre8exp.svg)

![\[spectre-h7h8-refined-Spectre4.svg\]](spectre-h7h8-refined-Spectre4.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[spectre-h7h8-refined-Spectre4exp.svg\]](spectre-h7h8-refined-Spectre4exp.svg)

![\[spectre-h7h8-refined-Spectre7.svg\]](spectre-h7h8-refined-Spectre7.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[spectre-h7h8-refined-Spectre7exp.svg\]](spectre-h7h8-refined-Spectre7exp.svg)

![\[spectre-h7h8-refined-Spectre3.svg\]](spectre-h7h8-refined-Spectre3.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[spectre-h7h8-refined-Spectre3exp.svg\]](spectre-h7h8-refined-Spectre3exp.svg)

![\[spectre-h7h8-refined-Spectre2.svg\]](spectre-h7h8-refined-Spectre2.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[spectre-h7h8-refined-Spectre2exp.svg\]](spectre-h7h8-refined-Spectre2exp.svg)

![\[spectre-h7h8-refined-Spectre6.svg\]](spectre-h7h8-refined-Spectre6.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[spectre-h7h8-refined-Spectre6exp.svg\]](spectre-h7h8-refined-Spectre6exp.svg)

![\[spectre-h7h8-refined-Spectre5.svg\]](spectre-h7h8-refined-Spectre5.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[spectre-h7h8-refined-Spectre5exp.svg\]](spectre-h7h8-refined-Spectre5exp.svg)

Substitution rules for the refined version of Spectre H7Â /Â H8

In other words, this automated algorithm has rediscovered exactly the Spectre 9-hex substitution system shown in the paper â except that it hasnât bothered simplifying the tile _shapes_ into hexagons. That wasnât in its brief. The refinerâs job is to leave the tile shapes unchanged, and do nothing except make more versions of each tile type.

It doesnât matter very much, either way. By the time youâve built a transducer out of this system, the distinction between hexagonal metatiles and ones shaped like Spectres and Mystics has more or less vanished anyway. The lowest-level tiles (the actual Spectres) are the same in both systems, and the transducer has encapsulated all the _combinatorial_ information about the metatiles, and didnât care about their geometry in the first place. The two transducers are interchangeable â you can feed the same coordinate string to either, and it will give the same answers.

### And now look what happens with hats!

Perhaps the most exciting result of this project was what happened when I ran the same refiner on the H7Â /Â H8 substitution system for the _hat_ tiling.

That system is very similar to the Spectre one, in that it has two types of metatile, one of which is a single ordinary hat, and the other is a fusion of two, including the unusual reflected one. As with the Spectre case above, Iâve left the details of which edge is which out of this diagram (and for the same reason â itâs horribly confusing), but my [previous article](../aperiodic-followup/#h7h8-hat-automorphism) has the missing detail in full.

![\[hat-h7h8-Hat.svg\]](hat-h7h8-Hat.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[hat-h7h8-Hatexp.svg\]](hat-h7h8-Hatexp.svg)

![\[hat-h7h8-Double.svg\]](hat-h7h8-Double.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[hat-h7h8-Doubleexp.svg\]](hat-h7h8-Doubleexp.svg)

Substitution rules for the hat H7Â /Â H8 system

In the previous two cases, when I ran my automated refiner, the output had been exactly identical to an unambiguous substitution system I already knew about. Here, I did already know of an unambiguous system that corresponds closely to the H7Â /Â H8 system for hats: Bowen Ping and Brad Kleeâs [system of 10 hexagonal metatiles](../aperiodic-transducers/#hat10). So I was expecting that my refiner would most likely recreate that from first principles, in the same way that it recreated both HHTPFFF and Spectre 9-hex.

But it surprised me, by doing _better!_ The output of my refiner, run on Hat H7Â /Â H8, is a system of only _eight_ tile types in total â the unique double-hat metatile and 7 subtypes of the single hat.

![\[hat-h7h8-refined-Hat1.svg\]](hat-h7h8-refined-Hat1.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[hat-h7h8-refined-Hat1exp.svg\]](hat-h7h8-refined-Hat1exp.svg)

![\[hat-h7h8-refined-Hat2.svg\]](hat-h7h8-refined-Hat2.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[hat-h7h8-refined-Hat2exp.svg\]](hat-h7h8-refined-Hat2exp.svg)

![\[hat-h7h8-refined-Hat3.svg\]](hat-h7h8-refined-Hat3.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[hat-h7h8-refined-Hat3exp.svg\]](hat-h7h8-refined-Hat3exp.svg)

![\[hat-h7h8-refined-Hat4.svg\]](hat-h7h8-refined-Hat4.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[hat-h7h8-refined-Hat4exp.svg\]](hat-h7h8-refined-Hat4exp.svg)

![\[hat-h7h8-refined-Hat5.svg\]](hat-h7h8-refined-Hat5.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[hat-h7h8-refined-Hat5exp.svg\]](hat-h7h8-refined-Hat5exp.svg)

![\[hat-h7h8-refined-Hat6.svg\]](hat-h7h8-refined-Hat6.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[hat-h7h8-refined-Hat6exp.svg\]](hat-h7h8-refined-Hat6exp.svg)

![\[hat-h7h8-refined-Hat7.svg\]](hat-h7h8-refined-Hat7.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[hat-h7h8-refined-Hat7exp.svg\]](hat-h7h8-refined-Hat7exp.svg)

![\[hat-h7h8-refined-Double.svg\]](hat-h7h8-refined-Double.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[hat-h7h8-refined-Doubleexp.svg\]](hat-h7h8-refined-Doubleexp.svg)

Substitution rules for the refined hat H7Â /Â H8 system

Is this a mistake, and the refined system doesnât admit a transducer? Of course that was the first thing I checked, but no, the transducer construction works fine.

So, how has my just-written algorithm managed to _beat_ Ping and Kleeâs system of ten tile types?

An obvious way to answer that question would be to match up the tile types in this system against the ones in the 10-hex diagrams. Unfortunately, they donât quite match correctly, because as I mentioned in the [previous article](../aperiodic-followup/#h7h8-hat-automorphism), there are actually _two_ ways you can set up the H7Â /Â H8 system for hats, depending on which neighbour you fuse the reflected hat with â and my presentation of Ping and Kleeâs 10-hex system, unfortunately, happened to pick the other one from the one in the hats paper, before I realised there was a right way to make that decision.

(Ping and Kleeâs _own_ presentation of their system was even stranger: it sawed the reflected hat in two, and assigned half of it to _each_ of the neighbouring tiles! So this poor choice was mine, and not theirs.)

Running the refiner again on the _other_ version of H7Â /Â H8 also generates 8 tile types rather than 10, and this time, it is possible to match them up one by one to the 10-hex system and see what happened. It turns out that the refiner has merged the B and C hex types into a single âBCâ tile, and similarly, merged the G and J hexes into one âGJâ.

If you go back and look in detail at the [10-hex diagrams](../aperiodic-transducers/#hat10), it is true that the B and C hexes expand to the same pattern of other _hexagons_. But the _edges_ match up differently: the B hex has a spur sticking out of its expansion, and the details of how the edges of the original hexagon map to the crinkly edge of the expansion are quite different from each other. Similarly, G and J expand to the same pattern of hexagons but with different edge mappings. In the final mapping to hats, the B and C hexagons donât work the same as each other either, and neither do G and J.

But in the H7Â /Â H8, there _are_ only two edge types in the whole system, corresponding to the long and short edges of hats. So in that system, the B and C tile types are _completely_ identical, because the difference in edge types isnât there. Theyâre just two tiles of the same shape with the same expansion. And similarly for G and J.

So it _looks_ , to me, as if the reason my refiner managed to get away with fewer tile types is actually _because_ it left the tile shapes as hats (and the fused double-hat), and didnât try to simplify them to hexagons with lots of different edge types. It seems to me that that simplification to hexagons creates extra complication!

By some measure, this is now the most economical substitution system for hats that I know of, among those which admit an unambiguous transducer at all. It uses only 8 metatile types, compared to Ping and Kleeâs 10. The HHTPFFF system gets away with one fewer â only 7 in total â but its metatiles are larger, with most of them expanding to 2 hats, and the two H metatiles expanding to 4. If you measure the systemâs overall complexity by âtotal number of hats in the expansion of all lowest-order metatilesâ â a metric that I only just made up but which seems to account for both types of complexity reasonably well â then this system is now the winner, at 9 hats total, to 11 for Ping and Kleeâs hexagons or 17 for HHTPFFF.

Just to demonstrate this 8-tile system in action, here are the two 6-way singular hat tilings from the [previous article](../aperiodic-followup/#hat-singular), regenerated using a transducer made from it. (Theyâre also the same pair of hat tilings shown in the example at the top of _this_ article, although there, I was focusing on the ambiguity for transducer purposes, rather than the six-way near-symmetry.) In terms of the new tiling system, one of these contains a type-2 hat tile which is the subtile of another type-2 hat forever, and the other contains a type-3 hat similarly. (In both cases, the subtileâs position within the supertileâs expansion is always the bottom right hat in the diagrams above.)

Type 2![\[hat-singular-2.svg\]](hat-singular-2.svg) Type 3![\[hat-singular-3.svg\]](hat-singular-3.svg)

![](hat-singular-spacer.svg)

Two six-way singular hat tilings, generated using the 8-tile refinement of H7Â /Â H8

## Difficult cases

I left a loose end somewhere back up there. My refinement algorithm starts by splitting each tile into subtypes depending on its neighbourhood, and I said that âinitiallyâ the neighbourhood would be defined as the tile on the other side of each edge (including which way round it is).

The main property we need from the concept of a âneighbourhoodâ is: _given the neighbourhood of a supertile, we need to be able to determine the neighbourhoods of all its subtiles_. For example, in the example above, I showed how you do this for a particular subtype of chair tile: draw in all the nearby large tiles according to the supertileâs type, and since all the smaller tiles bordering on each subtile are contained within those larger tiles, thatâs enough information to know the type of every smaller tile.

But I wasnât completely confident that that would be enough information in _every_ case. It worked fine for all the tilings Iâve discussed above, but I could see a way it might _not_ work, in principle.

Again it has to do with those awkward zero-thickness spurs that sometimes poke out of tile expansions. What if a tile _X_ has its neighbour on a particular edge being tile _Y_ , but when both are expanded into subtiles, the part of _Y_ âs expansion bordering _X_ turns out to be nothing but a zero-thickness spur? Then, if you were trying to ask our recursive coordinate transition algorithm what was on the other side of a particular edge of a subtile of _X_ , it might find the spur, and then have to recurse back out of the other side of it to find out what the _next_ large tile was. And that might not be one of _X_ âs immediate edge-to-edge neighbours at all.

This hasnât come up yet in any ârealâ aperiodic tile system. Any spur creates a situation where it _nearly_ happens. But usually, the tile whose spur is adjacent to some edge of _X_ also has some nonzero-thickness part of its expansion adjacent to another part of _X_ âs edge, which means that in spite of the spur you _do_ still have enough information to find out everything you need.

But I couldnât rule out this happening in some other more difficult tiling in future â and I wanted my algorithm to have an answer when it did. So I _invented_ a substitution system designed deliberately to have this annoying property, and then used it as a test case to make sure my code could cope.

### The âAwkward Squaresâ substitution system

The substitution I devised is a thing I called âAwkward Squaresâ. That was just the working filename I assigned it when I started trying to write one: I wanted it to be awkward to my refinement algorithm. In fact it ended up even more awkward than Iâd expected, so I decided it was a _good_ name, and could stay.

The basic idea of Awkward Squares is that each tile is a simple square. The squares come in two colours, red and blue. Both types of square expand to two red and two blue squares, but in one case, horizontally adjacent pairs of squares are the same colour, and in the other, vertically adjacent.

![\[awksq-red.svg\]](awksq-red.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[awksq-redexp.svg\]](awksq-redexp.svg)

![\[awksq-blue.svg\]](awksq-blue.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[awksq-blueexp.svg\]](awksq-blueexp.svg)

Substitution rules for the Awkward Squares system

This would be extremely boring, except for that spur poking out at the bottom. Thatâs the awkward part: I did something deliberately silly with the edge mappings.

To begin with, I assigned the horizontal and vertical edges different _types_ , so that each one could be expanded into sub-edges in a different way:

![\[awksq-square.svg\]](awksq-square.svg)

An Awkward Square, with colours and orientations marked on its edges

There are two distinct edge types here: the horizontal edges (drawn in green, with one arrow), and the vertical edges (in purple with two arrows). Both edge types have a direction, so that traversing them backwards reverses the order of the sub-edges they expand into.

The edge types and arrows also function as matching rules: they constrain the squares in the tiling to join together with the same type of edges meeting each other, and the arrows pointing in the same direction. In this case, the effect is simply to keep all the squares the same way up: rotating one square relative to another isnât allowed. (So far, still nothing awkward â thatâs going out of its way to be _simple!_)

To expand one square into a square of twice the edge length, the obvious thing would be to expand a horizontal edge into two horizontal edges end to end, and similarly for vertical edges. But instead, Iâve done something different. A horizontal edge expands into two horizontal edges _and a vertical one_.

On the other hand, the vertical edge behaves normally, expanding to two vertical edges as youâd expect:

![\[awksq-h.svg\]](awksq-h.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[awksq-hexp.svg\]](awksq-hexp.svg)

![\[awksq-v.svg\]](awksq-v.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[awksq-vexp.svg\]](awksq-vexp.svg)

The rules for expanding horizontal and vertical Awkward Square edges

So when you expand a square, you still _do_ get a larger square which can contain four of the smaller squares:

0![\[awksq-square-0.svg\]](awksq-square-0.svg)![\[arrow.svg\]](../aperiodic-tilings/arrow.svg)![\[awksq-squareexp-0.svg\]](awksq-squareexp-0.svg) 1![\[awksq-square-1.svg\]](awksq-square-1.svg)![\[arrow.svg\]](../aperiodic-tilings/arrow.svg)![\[awksq-squareexp-1.svg\]](awksq-squareexp-1.svg) 2![\[awksq-square-2.svg\]](awksq-square-2.svg)![\[arrow.svg\]](../aperiodic-tilings/arrow.svg)![\[awksq-squareexp-2.svg\]](awksq-squareexp-2.svg) 3![\[awksq-square-3.svg\]](awksq-square-3.svg)![\[arrow.svg\]](../aperiodic-tilings/arrow.svg)![\[awksq-squareexp-3.svg\]](awksq-squareexp-3.svg) 4![\[awksq-square-4.svg\]](awksq-square-4.svg)![\[arrow.svg\]](../aperiodic-tilings/arrow.svg)![\[awksq-squareexp-4.svg\]](awksq-squareexp-4.svg) Tiled![\[awksq-square-filled.svg\]](awksq-square-filled.svg)![\[arrow.svg\]](../aperiodic-tilings/arrow.svg)![\[awksq-squareexp-filled.svg\]](awksq-squareexp-filled.svg)

![](awksq-square-spacer.svg)![](../aperiodic-followup/arrow-spacer.svg)![](awksq-squareexp-spacer.svg)

Expansion of an Awkward Square outline, one edge at a time

But the effect of the knightâs-move expansion of the horizontal edge is that the next Awkward Square to the _right_ of this one will be placed one (smaller) square lower down, because in that expansion of the edges, the right-hand vertical edge has to start below the baseline of the output square, where the expansion of the bottom horizontal edge ended. So thatâs the part that matches up with the left edge of the next square.

You can also see that in the expansion diagrams above: the large circular blobs in the expansion of the R and B tile types show where the images of the original squareâs vertices are. And those are the points which must match between one tile and the next.

So, suppose you know the types of all four neighbours _L_ , _R_ , _U_ , _D_ of an Awkward Square _S_ of one size. Then hereâs what it tells you about the next size down:

![\[awksq-neighbours-big.svg\]](awksq-neighbours-big.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[awksq-neighbours-small.svg\]](awksq-neighbours-small.svg)

An Awkward Square with four neighbours, and its expansion

Whatâs on the right-hand side of the S3 sub-square? Or on the left-hand side of S0? You _canât_ answer this if all you know is which type of tile each of _L_ , _R_ , _U_ , and _D_ is. To tell whatâs on the right of S3, youâd need to know the type of the larger tile diagonally adjacent to _S_ , to the right of _U_ and above _R_. Similarly, you also need to know whatâs below _L_ and left of _D_.

_Formally_ , whatâs immediately on the right of S3 is the spur poking downwards from the expansion of the U square. Similarly, to the left of S0 is the downward spur from the L square. Itâs just that that doesnât help us find out the identity of the _smaller squares_ that must exist there in a full tiling.

So this is exactly an example of the scenario I suggested at the top of this section: we try to find out whatâs to the right of the S3 subtile, we find itâs a zero-thickness spur of one of the neighbouring supertiles, and then we need to know whatâs on the _other_ side of that spur before we can answer the original question.

### Extendable list of queries

My solution to this was to rewrite the part of the algorithm that determines all the necessary information about a tile to decide on its subtype.

In the initial version of the algorithm, that code simply looped over each edge, finding out what was on the far side of the edge. Now it has a list of more general _queries_ that it needs to answer about a tile.

Of course, the initial list of queries is exactly the same as before: whatâs on the far side of each edge? Thatâs the _minimum_ information needed to determine a tileâs subtype.

But then, another piece of code is asked to determine the types of the child tiles expanded from a parent. And the _only_ thing itâs told about the parent tile is the list of answers to the current set of queries. From that alone, it must answer all the same queries about the child tiles.

In the case of the Awkward Squares system, it will find that it canât answer, for the reason shown in the previous section: if all you know is what large tiles borders the parent along its edges, you canât always know what smaller tiles border the children along _their_ edges. So the âdetermine the child subtypesâ code will fail to return an answer â and instead, it will return a description of the question it _tried_ to ask about the parent tile which wasnât answered.

These questions will in general be conditional on an answer to a previous question. For example, the question âWhatâs on the other side of parent edge 3?â might give a tile type as answer which tells the code it must ask about some edge of _that_ tile in turn. So its new question will be along the lines of âGiven that the question about parent edge 3 turned out to be edge 5 of a type-_foo_ tile, whatâs on the other side of edge 4 of _that?_ â. In cases where the question about parent edge 3 has a different answer, the answer to that would be `None`, or whatever form of ânot applicableâ is appropriate to the programming language.

(These followup queries have to be conditional on the previous queries, because in many substitution systems, tiles arenât all the same shape. If you have to ask a followup question to traverse a spur, it will very likely be specific to the tile type. In Awkward Squares that doesnât come up, because both square types have the same shape of expansion, but in that respect, itâs not as awkward as some systems!)

Unfortunately, once a new query is identified, everything the code _thought_ it knew about the subtypes of tiles becomes invalid, because it doesnât have the answer to the new query for any of them. So it must start all over again, this time including the new query in the list of things it wants to know, right from square one.

In the case of Awkward Squares, we end up with eight extra queries. Basically theyâre the obvious two: what are the upper-right and lower-left diagonal neighbours of the original tile? But the query list has to be different for each original tile type (tiles donât even necessarily have the same number of edges!), and for the type of each tile encountered in a previous query. So the 8 queries cover all combinations of the original tile type (red or blue), which neighbour we initially asked about, and which type it was.

### Sometimes you have to refine more than once!

After adding those 8 queries, the refiner restarts from the beginning, runs successfully to completion, and outputs a refined tiling. There are quite a lot of tiles in it, as it turns out: nine copies of the blue tile, and eight copies of the red one.

(That surprised me for an instant â wouldnât you expect the same number of each? But no: the substitution rules treat horizontal and vertical lines differently, so it shouldnât be surprising that tiles behave differently if their expansions are rotated 90Â° so that horizontal and vertical interchange.)

The _real_ surprise came when I tried to make a transducer out of this refined Awkward Squares tiling. It still didnât work!

But all is not lost. On the theory that it was a very easy experiment and worth a try, I simply fed the refinerâs output straight back into _another_ run of the refiner. This time, it cloned only four of the tile types, each into just two copies â¦ and the output of the second run, the doubly-refined tiling, _does_ successfully produce a transducer. Phew!

I donât know that it will be particularly illuminating, but hereâs an example of one of the most difficult ambiguities in the Awkward Squares tiling. This was an ambiguity that the transducer-building code reported was _still_ present in the tiling system even after the first refinement, and only went away in the second one: you can see that the infinite supertile in the bottom left is the same in both pictures except that the top tile on its right-hand edge changes its label between B3.1 and B3.2 â the two subtypes that the _second_ refinement made out of the B3 tile generated by the first one.

Type 1![\[awksq-1.svg\]](awksq-1.svg) Type 2![\[awksq-2.svg\]](awksq-2.svg)

![](awksq-ambig-spacer.svg)

Two Awkward Square tilings which the once-refined system still couldnât tell apart.  
Two-part tile types like B3.1 indicate that the second refinement split B3 into two.

I canât make much sense of that myself â Awkward Squares didnât include âreadily comprehensible to humansâ in its design goals! But it at least demonstrates the code to be doing what it said it did.

I was a bit surprised when the first run didnât make the tiling unambiguous, but not _too_ surprised. After all, âmake it unambiguousâ was not in the softwareâs actual instructions. All I _told_ the algorithm to do was to bake some conveniently reachable information about each tileâs neighbourhood into the tile type. If that conveniently reachable information wasnât enough to remove all ambiguities, well, who said it would be in the first place?

But if that _wasnât_ enough, then it does make reasonable sense to me that running the refiner again should help. Because the first run included information in each tileâs type about the _unrefined_ types in its neighbourhood â and then the second run includes information in each tileâs type about the types in its neighbourhood _as augmented by the first refinement_. So each tile now includes information from an even wider radius of the original tiling.

My conjecture is that _some_ number of refinement runs always ought to be enough. Rationale: any infinitely long string of combinatorial coordinates of a tile indicates not only its immediate type, but the type of all its larger and larger supertiles. The more you refine the substitution system, the more information is included about the _neighbouring_ large supertiles. Eventually, surely, youâll end up with the region determined by each coordinate growing on all sides, and then the union of all those regions must cover the whole plane â which is a sufficient criterion for the coordinate string unambiguously defining a single tiling of the whole plane, and not leaving any region less than fully determined.

But thatâs a pretty handwavy argument, and also, I have no idea _how many_ refinements might be needed! It was a surprise to me that the maximum number was more than 1. Is it bounded at all? Who knows!

### The test case that wasnât a test case

One last silly story:

When I was initially testing this refiner, the very _first_ tiling I tested it on wasnât the chair tiling shown above. It was the [Ammann-Beenker tiling](https://en.wikipedia.org/wiki/Ammann%E2%80%93Beenker_tiling): an aperiodic system with two tile types, discovered around the same time as the Penrose tilings, but less famous.

One of the tiles in the Ammann-Beenker tiling is a rhombus with 45Â° and 135Â° angles. Depending on your point of view, the other is either a square, or a pair of mirror-image right triangles which always join along their hypotenuses. Iâve seen both interpretations; I think the squares look nicer, but the triangles make an easier substitution system. (For much the same reason as sawing the Penrose tiles into two triangles â each tileâs expansion fills exactly the same area as the original tile.)

Just like the simple shapes in Penrose tilings, either of those shapes â or both together â could tile the plane periodically, if it werenât for some matching rules, shown by the arrows on the edges below:

![\[ammann-beenker-square.svg\]](ammann-beenker-square.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[ammann-beenker-squareexp.svg\]](ammann-beenker-squareexp.svg)

![\[ammann-beenker-rhombus.svg\]](ammann-beenker-rhombus.svg) ![\[arrow.svg\]](../aperiodic-tilings/arrow.svg) ![\[ammann-beenker-rhombusexp.svg\]](ammann-beenker-rhombusexp.svg)

Substitution rules for Ammann-Beenker, with the square bisected

(If you prefer to think of the tiling as having one square instead of two triangles, then the double-arrow edges vanish completely, and you just have a square and a rhombus, with all edges being of the same type, and just different patterns of edge directions around the two tilesâ perimeters. Up to you.)

Iâve had this tiling description in my source repository for a year or more. My code wasnât able to build a transducer from it, and I didnât know how to solve that problem by myself, or know of any alternative substitution systems that might happen to eliminate the ambiguity. And itâs a small and simple system, so it made a good first test case â not too large, _and_ if it worked Iâd get rid of a long-standing annoyance.

So I ran my draft refiner over the Ammann-Beenker tiling, and it worked, and generated me a refined tiling that did admit a transducer. Success!

What do you do once youâve built a transducer for a previously ambiguous tiling? You identify a specific ambiguous case from the unrefined substitution system, and use the new transducer to draw both versions of it, to demonstrate that you really have solved the problem. Thatâs what I did for the hat ambiguity, and further up this article I did the same for the chair tiling (and Awkward Squares).

But when I examined the transducer failure report to try to figure out the ambiguous case, I became suspicious. It didnât seem to make sense.

In fact, it turned out that my transducer-construction code simply had a bug: it had _given up too soon_ when trying to build this transducer. The _original_ Ammann-Beenker system, without any refinement, _does_ admit a transducer after all, and it was only a bug in my code that made me think it didnât!

At that early stage, I hadnât written the part of the algorithm which automatically re-merges tile subtypes. So I got an over-refined tiling with lots of subtypes of each tile type, and had to re-merge as many as I could by hand, reverting any change that broke the transducer again. By the time Iâd finished that, I was back down to just one rhombus, and _two_ squares; merging the last two squares caused the transducer construction to fail. But if Iâd had the _automated_ tile-merging code at the time, it would have merged the last two squares anyway, which might have made me suspicious sooner!

Well, regardless of that, the upshot is that now I _do_ have a working Ammann-Beenker transducer, when previously I didnât â even if the reason why wasnât quite what I expected it to be. So I should show some pretty pictures made from it, in celebration. But I canât triumphantly show the two versions of an ambiguous Ammann-Beenker instance, because as it turns out, there arenât any. So instead Iâll just show a couple of particularly symmetric tilings, which also contain infinite supertile boundaries, so it takes a transducer to render them conveniently:

2-way symmetric![\[ammann-beenker-triangle.svg\]](ammann-beenker-triangle.svg) 8-way symmetric![\[ammann-beenker-rhombus0.svg\]](ammann-beenker-rhombus0.svg)

![](ammann-beenker-spacer.svg)

Two symmetric instances of the Ammann-Beenker tiling

This tiling is generated from the system shown above, with two rhombuses and a triangle, but I added a one-off mapping layer at the very bottom which maps one of the triangles to nothing and the other to a square. So the supertile boundaries âmorallyâ ought to be straight, but they just swerve around each square they come to.

## Conclusion

Iâm very pleased with this piece of work! Itâs a significant advance in the practical uses of substitution-tiling transducers. Now if I hear about a new substitution system and want to try generating instances of it, I donât have to worry if it turns out to be ambiguous. I can just run my new refiner, and most likely get a disambiguated version of it, without needing anyone else to have done the clever part for me.

For example, [a July 2025 blog post by mathBlock](https://mathblock8128.wordpress.com/2025/07/13/turtle-tiles-footnote-1-altered-metatiles-and-half-inflations/) shows an interesting alternative substitution system for the hat tiling, which takes _two_ iterations of deflation to have the same effect as a single deflation in any of the normal systems â that is, you can _half_ -deflate a hat tiling, obtaining a tiling thatâs intermediate between the original tiling and its full deflation. That struck me as an interesting thing to investigate: what happens if you half-deflate some of the special instances of the tiling, like the [rotationally symmetric ones](../aperiodic-transducers/#hats-symm-picture), or the [âsingularâ nearly-symmetric ones](../aperiodic-followup/#hat-singular)? But when I coded up mathBlockâs system in the form of one of my tiling description files, I tried to build a transducer, and sadly, found it was ambiguous.

That was what inspired me to try out this refiner idea â and it worked, so I was able to produce an unambiguous refinement of mathBlockâs substitution, and use that for my investigations. (And it turns out that some of the symmetric and singular hat patterns half-deflate to _each other_ , which is an interesting finding, and perhaps would have been an alternative way to _discover_ the singular patterns!)
