# Could Write­Process­Memory be made faster by avoiding the intermediate buffer?

**来源:** [devblogs.microsoft.com/oldnewthing](https://devblogs.microsoft.com/oldnewthing)
**发布时间:** Wed, 18 Feb 2026 15:00:00 +0000
**链接:** https://devblogs.microsoft.com/oldnewthing/20260218-00/?p=112069

---

{'type': 'text/html', 'language': None, 'base': 'https://devblogs.microsoft.com/oldnewthing/feed', 'value': '<p>A little while ago, we wondered <a href="https://devblogs.microsoft.com/oldnewthing/20251119-00/?p=111800" title="Is Write\xadProcess\xadMemory faster than shared memory for transferring data between two processes?"> whether <code>Write\xadProcess\xadMemory</code> was faster than shared memory for transferring data between two processes</a>, and the conclusion is that it wasn&#8217;t. Shared memory, as its name implies, shares the memory between two processes: The two processes are accessing the same memory; there are no copies. On the other hand, the implementation of <code>Write\xadProcess\xadMemory</code> allocates a transfer buffer, copies the data from the source to the transfer buffer, then changes memory context to the destination, and then copies the data from the transfer buffer to the destination. But could <code>Write\xadProcess\xadMemory</code> be optimized to avoid this copy?</p>\n<p>I mean, I guess you could do that in theory. I&#8217;m thinking, maybe create a memory descriptor list (MDL), lock and map the pages into kernel mode while in the context of the source, then change context to the destination and copy the memory to the destination. Repeat until all the memory has been copied. You don&#8217;t want to allocate a single MDL for the entire source block because the program might say that it wants to copy 100GB of memory, and if you didn&#8217;t cap the size of the transfer buffer, that would lock 100GB of RAM.</p>\n<p>But it seems overkill and unnecessary to lock the source pages. It&#8217;s fine for them to be pageable. We&#8217;re okay with them faulting in as necessary.</p>\n<p>I don&#8217;t know if there&#8217;s a way to map memory from one process into another except by locking it. I don&#8217;t spend a lot of time in kernel mode. But you do have to be careful that the mapping goes into the kernel address space and not the user-mode address space. Putting it in the user-mode address space would be a security vulnerability because the destination process can see the bytes on the source page that are not part of the memory being copied.¹</p>\n<p>But really, all of this effort is pointless. We saw that the purpose of the <code>Write\xadProcess\xadMemory</code> function is not inter-process communication (IPC) but <a href="https://devblogs.microsoft.com/oldnewthing/20120808-00/?p=6913" title="Of what possible legitimate use are functions like CreateRemoteThread, WriteProcessMemory, and VirtualProtectEx?"> to be a tool for debuggers</a>. Debuggers are typically writing just a few bytes at a time, say, to patch a breakpoint instruction, and <a href="https://devblogs.microsoft.com/oldnewthing/20181206-00/?p=100415" title="How is it that WriteProcessMemory succeeds in writing to read-only memory?"> the <code>Write\xadProcess\xadMemory</code> function actually goes out of its way to write the memory, even in the face of incompatible memory protections</a>, though it does so in a not-thread-safe way. But that&#8217;s okay because the destination process is presumably frozen by the debugger when it calls <code>Write\xadProcess\xadMemory</code>. A debugger is not going to patch a process while it&#8217;s actively running. The lack of atomicity means that patching a running process could result in the process seeing torn state, like a partly-patched variable or even a partly-patched instruction.</p>\n<p>In summary, <code>Write\xadProcess\xadMemory</code> was not intended to be used as an inter-process communication channel. Its intended client is a debugger that is using it to patch bytes in a process being debugged. The very high level of access required to call the function (<code>PROCESS_VM_WRITE</code>) is not suitable for an inter-process communication channel, since it basically gives the writer full pwnage over the process being written to. In the case of a debugger, you <i>want</i> the debugger to have complete and total control of the process being debugged. But in the case of IPC, you don&#8217;t want to give your clients that high a level of access to your process. And even if you get past that, the lack of atomicity and lack of control over the order in which the bytes become visible in the target process means that <code>Write\xadProcess\xadMemory</code> is not suitable as an IPC mechanism anyway. There&#8217;s no point trying to make a bad idea more efficient.</p>\n<p>¹ Or you could try it the other way: Map the destination into the source. But now you are giving the source read access to the destination bytes that share the same page as the destination buffer, even though the source may not have <code>PROCESS_VM_READ</code> access.</p>\n<p>The post <a href="https://devblogs.microsoft.com/oldnewthing/20260218-00/?p=112069">Could &lt;CODE&gt;Write&shy;Process&shy;Memory&lt;/CODE&gt; be made faster by avoiding the intermediate buffer?</a> appeared first on <a href="https://devblogs.microsoft.com/oldnewthing">The Old New Thing</a>.</p>'}

---

*抓取时间: 2026-02-21 00:09:53*
