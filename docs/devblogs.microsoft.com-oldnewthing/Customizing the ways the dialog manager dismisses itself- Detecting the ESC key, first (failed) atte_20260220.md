# Customizing the ways the dialog manager dismisses itself: Detecting the ESC key, first (failed) attempt

**来源:** [devblogs.microsoft.com/oldnewthing](https://devblogs.microsoft.com/oldnewthing)
**发布时间:** Fri, 20 Feb 2026 15:00:00 +0000
**链接:** https://devblogs.microsoft.com/oldnewthing/20260220-00/?p=112074

---

{'type': 'text/html', 'language': None, 'base': 'https://devblogs.microsoft.com/oldnewthing/feed', 'value': '<p>Suppose you want to distinguish between dismissing a dialog by pressing <kbd>ESC</kbd> and dismissing a dialog by clicking the Close button. One suggestion I saw was to call <code>Get\xadAsync\xadKey\xadState(VK_ESCAPE)</code> to check whether the <kbd>ESC</kbd> is down.</p>\n<p>In general, any time you see <code>Get\xadAsync\xadKey\xadState</code>, you should be suspicious, since <code>Get\xadAsync\xadKey\xadState</code> checks the state of the keyboard at the moment it is called, which might not be relevant to your window if it asynchronously lost keyboard focus, and which (from the point of view of your program) might even be from the future.</p>\n<p>Recall that the system maintains two types of keyboard states. One is the <i>synchronous</i> keyboard state, which represents the state of the keyboard as far as your program is aware. If your program received a <code>WM_KEYDOWN</code> for the space bar, then <code>Get\xadKey\xadState</code> will report that the space bar is pressed. Even if the user releases the space bar, <code>Get\xadKey\xadState</code> will continue to report that the space bar is pressed until the program receives a <code>WM_KEYUP</code> for the space bar.</p>\n<p>The idea here is that your program is processing an input stream, and due to the nature of multitasking and the physics of time, it&#8217;s possible that your program is catching up to input that actually occurred some time ago. For example, maybe the user typed ahead into the program while it was unresponsive, and now that the program has become responsive again, it is playing catch-up with all the typing that occurred 30 seconds ago.</p>\n<p>If the program receives, say, a press of the <kbd>F2</kbd> key and wants to know whether to do the <kbd>Ctrl</kbd>+<kbd>F2</kbd> hotkey, it doesn&#8217;t know want to know whether the <kbd>Ctrl</kbd> key is down at the moment it is processing its input backlog. It wants to know whether the <kbd>Ctrl</kbd> key was down at the time the <kbd>F2</kbd> was pressed.</p>\n<table border="1" cellpadding="3" cellspacing="0" style="border-collapse: collapse;">\n<tbody>\n<tr>\n<th>Time</th>\n<th>Event</th>\n</tr>\n<tr>\n<td>1</td>\n<td>User presses <kbd>Ctrl</kbd></td>\n</tr>\n<tr>\n<td>2</td>\n<td>User presses <kbd>F2</kbd></td>\n</tr>\n<tr>\n<td>3</td>\n<td>User releases <kbd>F2</kbd></td>\n</tr>\n<tr>\n<td>4</td>\n<td>User releases <kbd>Ctrl</kbd></td>\n</tr>\n<tr>\n<td>5</td>\n<td>Program receives <kbd>Ctrl</kbd> down</td>\n</tr>\n<tr>\n<td>6</td>\n<td>Program receives <kbd>F2</kbd> down</td>\n</tr>\n<tr>\n<td valign="top">7</td>\n<td>Program uses <code>Get\xadAsync\xadKey\xadState</code> to ask if <kbd>Ctrl</kbd> is down<br />\nAnswer: No<br />\nProgram does <kbd>F2</kbd> action instead of <kbd>Ctrl</kbd>+<kbd>F2</kbd></td>\n</tr>\n</tbody>\n</table>\n<p>When the program asks via <code>Get\xadAsync\xadKey\xadState</code> whether the <kbd>Ctrl</kbd> key is down, the answer is &#8220;No, it&#8217;s not down. It was released at some future point in time you haven&#8217;t learned about yet.&#8221; And so the program does its <kbd>F2</kbd> action instead of <kbd>Ctrl</kbd>+<kbd>F2</kbd>, and you get a bug report that goes like &#8220;When the program is under heavy load, the <kbd>Ctrl</kbd>+<kbd>F2</kbd> hotkey doesn&#8217;t work.&#8221;</p>\n<p>Suppose your program wants to discard changes when the user dismisses the dialog with <kbd>ESC</kbd> but wants to save changes when the user dismisses the dialog with the Close button. Checking the asynchronous state of the <kbd>ESC</kbd> key will tell you whether the <kbd>ESC</kbd> is down right now, but not whether the <kbd>ESC</kbd> was down at the time the system generated the <code>IDCANCEL</code>. You&#8217;re going to get bugs like, &#8220;When the program is under heavy load, pressing <kbd>ESC</kbd> to dismiss the dialog sometimes saves the changes instead of discarding them.&#8221;</p>\n<p>Of course, the bug report probably isn&#8217;t going to be so kind as to mention that the program was under heavy load or that the <kbd>ESC</kbd> accidentally saved the changes. It&#8217;ll probably just say &#8220;Sometimes I see changes that I&#8217;m sure I had discarded.&#8221; And you&#8217;ll have to figure out what the necessary conditions are for that bug to manifest itself.</p>\n<p><b>Bonus chatter</b>: I don&#8217;t know why people love to use <code>Get\xadAsync\xadKey\xadState</code> so much. It has a longer, more cumbersome name than the largely-ignored <code>Get\xadKey\xadState</code> function. Maybe people think that the longer, more cumbersome name means that it&#8217;s somehow &#8220;more fancy&#8221;.</p>\n<p>The post <a href="https://devblogs.microsoft.com/oldnewthing/20260220-00/?p=112074">Customizing the ways the dialog manager dismisses itself: Detecting the ESC key, first (failed) attempt</a> appeared first on <a href="https://devblogs.microsoft.com/oldnewthing">The Old New Thing</a>.</p>'}

---

*抓取时间: 2026-02-22 00:02:38*
