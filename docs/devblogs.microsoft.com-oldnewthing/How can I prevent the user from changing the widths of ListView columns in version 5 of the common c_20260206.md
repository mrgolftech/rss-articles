# How can I prevent the user from changing the widths of ListView columns in version 5 of the common controls?, part 2

**来源:** [devblogs.microsoft.com/oldnewthing](https://devblogs.microsoft.com/oldnewthing)
**发布时间:** Fri, 06 Feb 2026 15:00:00 +0000
**链接:** https://devblogs.microsoft.com/oldnewthing/20260206-00/?p=112045

---

{'type': 'text/html', 'language': None, 'base': 'https://devblogs.microsoft.com/oldnewthing/feed', 'value': '<p>Last time, we had figured out how to <a href="https://devblogs.microsoft.com/oldnewthing/20260205-00/?p=112042" title="How can I prevent the user from changing the widths of ListView columns in version 5 of the common controls?"> prevent the version 5 ListView Win32 common control from resizing columns</a>, but we noticed that the cursor still changes to a resize cursor that doesn&#8217;t work. How can we avoid misleading the user?</p>\n<p>I had a few ideas but decided that the easiest way would be to subclass the header control and override its <code>WM_SET\xadCURSOR</code> message with one that just sets the arrow cursor.</p>\n<pre>LRESULT CALLBACK AlwaysArrowSubclassProc(\n    HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam,\n    [[maybe_unused]] UINT_PTR uIdSubclass,\n    [[maybe_unused]] DWORD_PTR dwRefData)\n{\n    switch (uMsg) {\n    case WM_SETCURSOR:\n        SetCursor(LoadCursor(nullptr, IDC_ARROW));\n        return 1;\n    }\n    return DefSubclassProc(hWnd, uMsg, wParam, lParam);\n}\n\n    case WM_CREATE: // or WM_INITDIALOG if this is a dialog procedure\n        ⟦ ... ⟧\n\n        SetWindowSubclass(ListView_GetHeader(hwndLV),\n                          AlwaysArrowSubclassProc, 1, 0);\n\n        ⟦ ... ⟧\n        return 0;\n\n    case WM_DESTROY:\n        RemoveWindowSubclass(ListView_GetHeader(hwndLV),\n                             AlwaysArrowSubclassProc, 1);\n\n        ⟦ ... ⟧\n        return 0;\n</pre>\n<p>Alternatively, we could have the subclass procedure be self-destroying.</p>\n<pre>LRESULT CALLBACK AlwaysArrowSubclassProc(\n    HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam,\n    UINT_PTR uIdSubclass, [[maybe_unused]] DWORD_PTR dwRefData)\n\n{\n    switch (uMsg) {\n    <span style="border-bottom: none;">case WM_NCDESTROY:                                                   </span>\n    <span style="border-style: none solid;">    RemoveWindowSubclass(hWnd, AlwaysArrowSubclassProc, uIdSubclass);</span>\n    <span style="border-top: none;">    break;                                                           </span>\n    case WM_SETCURSOR:\n        SetCursor(LoadCursor(nullptr, IDC_ARROW));\n        return 1;\n    }\n    return DefSubclassProc(hWnd, uMsg, wParam, lParam);\n}\n\n    case WM_CREATE: // or WM_INITDIALOG if this is a dialog procedure\n        ⟦ ... ⟧\n\n        SetWindowSubclass(ListView_GetHeader(hwndLV),\n                          AlwaysArrowSubclassProc, 1, 0);\n\n        ⟦ ... ⟧\n        return 0;\n\n    case WM_DESTROY:\n        // <span style="text-decoration: line-through;">RemoveWindowSubclass(ListView_GetHeader(hwndLV),</span>\n        // <span style="text-decoration: line-through;">                     AlwaysArrowSubclassProc, 1);</span>\n\n        ⟦ ... ⟧\n        return 0;\n</pre>\n<p>We could generalize this subclass procedure so it always sets the cursor to one specified in its <code>dwRefData</code>.</p>\n<pre>LRESULT CALLBACK <span>FixedCursorSubclassProc</span>(\n    HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam,\n    UINT_PTR uIdSubclass, [[maybe_unused]] DWORD_PTR dwRefData)\n\n{\n    switch (uMsg) {\n    case WM_NCDESTROY:\n        RemoveWindowSubclass(hWnd, <span>FixedCursorSubclassProc</span>, uIdSubclass);\n        break;\n    case WM_SETCURSOR:\n        SetCursor(<span>(HCURSOR)dwRefData</span>);\n        return 1;\n    }\n    return DefSubclassProc(hWnd, uMsg, wParam, lParam);\n}\n\n    case WM_CREATE: // or WM_INITDIALOG if this is a dialog procedure\n        ⟦ ... ⟧\n\n        SetWindowSubclass(ListView_GetHeader(hwndLV),\n                          <span>FixedCursorSubclassProc</span>, 1,\n                          <span>(DWORD_PTR)LoadCursor(nullptr, IDC_ARROW)</span>);\n\n        ⟦ ... ⟧\n        return 0;\n</pre>\n<p>And then I realized that I don&#8217;t need to set the cursor at all. The default window procedure sets the cursor to the class cursor. We just have to call it.</p>\n<pre>LRESULT CALLBACK <span>ClassCursorSubclassProc</span>(\n    HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam,\n    UINT_PTR uIdSubclass, [[maybe_unused]] DWORD_PTR dwRefData)\n\n{\n    switch (uMsg) {\n    case WM_NCDESTROY:\n        RemoveWindowSubclass(hWnd, <span>ClassCursorSubclassProc</span>, uIdSubclass);\n        break;\n    case WM_SETCURSOR:\n        <span>return DefWindowProc(hWnd, uMsg, wParam, lParam);</span>\n    }\n    return DefSubclassProc(hWnd, uMsg, wParam, lParam);\n}\n\n    case WM_CREATE: // or WM_INITDIALOG if this is a dialog procedure\n        ⟦ ... ⟧\n\n        SetWindowSubclass(ListView_GetHeader(hwndLV),\n                          <span>ClassCursorSubclassProc</span>, 1, <span>0</span>);\n\n        ⟦ ... ⟧\n        return 0;\n</pre>\n<p>Recall that all of this work is just to work around the lack of support for the <code>HDS_NO\xadSIZING</code> style in the version 5 common controls library. If you are using version 6 (and really, you should be), then just set the <code>HDS_NO\xadSIZING</code> style onto the ListView&#8217;s header control, and you&#8217;re all done.</p>\n<p>The post <a href="https://devblogs.microsoft.com/oldnewthing/20260206-00/?p=112045">How can I prevent the user from changing the widths of ListView columns in version 5 of the common controls?, part 2</a> appeared first on <a href="https://devblogs.microsoft.com/oldnewthing">The Old New Thing</a>.</p>'}

---

*抓取时间: 2026-02-07 09:36:38*
