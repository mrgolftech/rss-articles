# Intercepting messages before Is­Dialog­Message can process them

**来源:** [devblogs.microsoft.com/oldnewthing](https://devblogs.microsoft.com/oldnewthing)
**发布时间:** Wed, 25 Feb 2026 15:00:00 +0000
**链接:** https://devblogs.microsoft.com/oldnewthing/20260225-00/?p=112087

---

{'type': 'text/html', 'language': None, 'base': 'https://devblogs.microsoft.com/oldnewthing/feed', 'value': '<p>Last time, we looked at <a href="https://devblogs.microsoft.com/oldnewthing/20260224-00/?p=112082" title="Customizing the ways the dialog manager dismisses itself: Isolating the Close pathway"> recognizing that the user clicked the Close button (or equivalent nonclient gestures) on a dialog</a>. The other system-provided pathway to dismissing a dialog is pressing <kbd>ESC</kbd>, and we saw in our flow diagram that this is done by the <code>Is\xadDialog\xadMessage</code> function.</p>\n<p>If your dialog box doesn&#8217;t have an <code>IDCANCEL</code> button, then you can detect that the user hit <kbd>ESC</kbd> by simply recognizing that they didn&#8217;t click the Close button. If you shut off the <code>WM_CLOSE</code> pathway, then the only other source of <code>IDCANCEL</code> is the <kbd>ESC</kbd> key.</p>\n<p>Now, you might be concerned that additional pathways for system-provided dialog dismissal may be added later. (Who knows, maybe a new touch gesture will be invented.) But you can&#8217;t predict what pathway that future system-provide dismissal will take, so you have nothing to code to. All you can do is cover the pathways that you know and hope that any future dismissal mechanisms will follow one of them.</p>\n<p>We saw from our diagram that the <kbd>ESC</kbd> pathway consists of the <code>Is\xadDialog\xadMessage</code> function processing a <code>WM_KEY\xadDOWN</code> for the <kbd>ESC</kbd> key and turning it into a <code>WM_COMMAND</code> button click for <code>IDCANCEL</code>. By the time it is converted into a fake button click message, it&#8217;s too late to know what the source was, so we&#8217;ll have to do the work before then.</p>\n<p>One way to do this is to recognize the <kbd>ESC</kbd> key <i>before</i> calling <code>IsDialogMessage</code>. If your dialog was created as a modeless dialog, then you already have a custom dialog message loop. And if it was created as a modal dialog, you can <a href="https://devblogs.microsoft.com/oldnewthing/20050404-48/?p=35983" title="The dialog manager, part 5: Converting a non-modal dialog box to modal"> convert it to a modeless one with a dialog message loop</a>. Once that&#8217;s done, you can <a href="https://devblogs.microsoft.com/oldnewthing/20050407-00/?p=35953" title="The dialog manager, part 8: Custom navigation in dialog boxes"> treat the <kbd>ESC</kbd> key as if it were custom navigation</a>.</p>\n<p>Your first try might go like this:</p>\n<pre>while (⟦ dialog still active ⟧ &amp;&amp;\n       GetMessage(&amp;msg, NULL, 0, 0, 0)) {\n if (msg.message == WM_KEYDOWN &amp;&amp;\n     msg.wParam == VK_ESCAPE) {\n  ⟦ do custom ESC key handling ⟧\n } else if (!IsDialogMessage(hdlg, &amp;msg)) {\n  TranslateMessage(&amp;msg);\n  DispatchMessage(&amp;msg);\n }\n}\n</pre>\n<p>However, this fails to honor controls that declare <code>DLGC_WANT\xadALL\xadKEYS</code> or <code>DLGC_WANT\xadMESSAGE</code>. We&#8217;ll have to check with the focus control to see if it wants to use the <kbd>ESC</kbd> key for its own purposes. While we&#8217;re at it, we&#8217;ll also ensure that we are stealing <kbd>ESC</kbd> keys only from our own dialog. The code is getting complex enough that we&#8217;ll break it out into a helper function.</p>\n<pre>bool IsDialogESC(HDLG hdlg, MSG const* msg)\n{\n    if (msg-&gt;message != WM_KEYDOWN ||\n        msg-&gt;wParam != VK_ESCAPE) {\n        return false;\n    }\n\n    if (msg-&gt;hwnd != hdlg &amp;&amp;\n        !IsChild(hdlg, msg-&gt;hwnd)) {\n        return false;\n    }\n\n    auto code = SendMessage(msg-&gt;hwnd, WM_GETDLGCODE,\n                            msg-&gt;wParam, (LPARAM)msg);\n    if (code &amp; (DLGC_WANTALLKEYS | DLGC_WANTMESSAGE)) {\n        return false;\n    }\n\n    return true;\n}\n</pre>\n<p>In order for this to be a potential dialog-dismissing <kbd>ESC</kbd>, the message must be a <code>WM_KEY\xadDOWN</code> of <code>VK_ESCAPE</code>, and the message must target the dialog or a child of the dialog. And the target window also must decline to handle the message itself.</p>\n<p>I carefully ordered the tests so that we can early-out as quickly as possible. Checking for the <kbd>ESC</kbd> key can be done by inspecting the message. Checking that the target window is acceptable is a little more work, but not too bad. Checking whether the target window wants to handle the message is the most expensive test, so we do that last.</p>\n<p>Now we can incorporate this helper function into our custom message loop.</p>\n<pre>while (⟦ dialog still active ⟧ &amp;&amp;\n       GetMessage(&amp;msg, NULL, 0, 0, 0)) {\n if (<span>IsDialogESC(hdlg, &amp;msg)</span>) {\n  ⟦ do custom ESC key handling ⟧\n } else if (!IsDialogMessage(hdlg, &amp;msg)) {\n  TranslateMessage(&amp;msg);\n  DispatchMessage(&amp;msg);\n }\n}\n</pre>\n<p>This all sounds great, but you might not be able to make this change. For example, maybe the dialog box&#8217;s dialog procedure uses <code>End\xadDialog()</code> to dismiss the dialog. The fact that it has been called is not exposed by the dialog box infrastructure. Or maybe you don&#8217;t control the code that calls <code>Dialog\xadBox</code> in the first place, so you can&#8217;t make them switch to a modeless dialog box with a custom dialog loop.</p>\n<p>We&#8217;ll study this problem next time.</p>\n<p>The post <a href="https://devblogs.microsoft.com/oldnewthing/20260225-00/?p=112087">Intercepting messages before &lt;CODE&gt;Is&shy;Dialog&shy;Message&lt;/CODE&gt; can process them</a> appeared first on <a href="https://devblogs.microsoft.com/oldnewthing">The Old New Thing</a>.</p>'}

---

*抓取时间: 2026-02-27 02:38:48*
