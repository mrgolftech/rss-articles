# Intercepting messages inside Is­Dialog­Message, fine-tuning the message filter

**来源:** [devblogs.microsoft.com/oldnewthing](https://devblogs.microsoft.com/oldnewthing)
**发布时间:** Fri, 27 Feb 2026 15:00:00 +0000
**链接:** https://devblogs.microsoft.com/oldnewthing/20260227-00/?p=112094

---

{'type': 'text/html', 'language': None, 'base': 'https://devblogs.microsoft.com/oldnewthing/feed', 'value': '<p>Last time, we <a href="https://devblogs.microsoft.com/oldnewthing/20260226-00/?p=112090" title="Intercepting messages inside Is\xadDialog\xadMessage, installing the message filter"> used a <code>MSGF_DIALOG\xadBOX</code> message filter</a> to hook into the <code>Is\xadDialog\xadMessage</code> so that we had the option to grab the <kbd>ESC</kbd> before it gets turned into an <code>IDCANCEL</code>. There are some problems with our initial foray.</p>\n<p>One is the problem of recursive dialogs. If the first dialog shows another copy of itself (for example, a certificate dialog showing a dialog for its parent certificate), then the thread-local variable gets overwritten, and the first dialog&#8217;s information is lost.</p>\n<p>We could solve that by having each dialog remember the original value and restore it when the dialog dismisses. Alternatively, we could maintain an explicit stack of dialogs, pushing when a new dialog is created and popping when it is destroyed.</p>\n<p>However, this fails to handle the case where the dialog is modeless. In that case, the two dialogs could be running concurrently rather than recursively. Instead of a stack, we really need a per-thread <i>set</i> of active dialogs.</p>\n<p>Another thing to worry about is that if this code is put into a static library, and two components in the same thread both use that static library, then you have to be careful that the two copies of the library don&#8217;t conflict with each other.</p>\n<p>I came up with this initial idea:</p>\n<pre>#define DIALOG_WANTS_ESC_PROP TEXT("DialogWantsEsc")\n\nLRESULT CALLBACK DialogEscHookProc(int nCode, WPARAM wParam, LPARAM lParam)\n{\n    if (nCode == MSGF_DIALOGBOX) {\n        auto msg = (MSG*)lParam;\n        if (msg-&gt;message == WM_KEYDOWN &amp;&amp;\n            msg-&gt;wParam == VK_ESCAPE) {\n            auto hdlg = GetAncestor(msg-&gt;hwnd, GA_ROOT);\n            auto customMessage = PtrToUint(GetProp(hdlg,\n                                           DIALOG_WANTS_ESC_PROP));\n            if (customMessage &amp;&amp;\n                !(SendMessage(msg-&gt;hwnd, WM_GETDLGCODE,\n                             msg-&gt;wParam, lParam) &amp;\n                         (DLGC_WANTALLKEYS | DLGC_WANTMESSAGE))) {\n                return SendMessage(hdlg, customMessage, 0, lParam);\n            }\n        }\n    }\n    return CallNextHookEx(nullptr, nCode, wParam, lParam);\n}\n</pre>\n<p>The idea here is that instead of having to manage a table of per-thread registrations, we just let dialogs self-register by setting the <code>DIALOG_WANTS_ESC_PROP</code> property to the message number they want to receive when the user presses <kbd>ESC</kbd>.</p>\n<p>If there are two copies of this hook installed, then the <code>Dialog\xadEsc\xadHook\xadProc</code> is called twice. The first one sends the custom message and gets the dialog&#8217;s response, and returns it; it never passes the message down the hook chain. Therefore, the second and subsequent hooks never get to run, so we don&#8217;t have a problem of the custom message getting sent multiple times for the same call to <code>Is\xadDialog\xadMessage</code>.</p>\n<p>This design has the advantage that multiple DLLs using this pattern can coexist because the first hook (whichever it is) does all the work for everybody.</p>\n<p>An alternate, more complex, design would pass the call down the chain if the dialog box declined to handle the <kbd>ESC</kbd> key, in case some other hook wanted to do something special. The catch is that if there are multiple copies of this hook installed, each one will send the custom message to the dialog, which would be bad if the handler for the custom message had side effects like showing a confirmation dialog.</p>\n<p>So we can add the rule that the custom message must be safe to call multiple times if it returns <code>FALSE</code>. This means that if it wants to display a confirmation dialog, it should always return <code>TRUE</code> even if the user cancels.</p>\n<pre>LRESULT CALLBACK DialogEscHookProc(int nCode, WPARAM wParam, LPARAM lParam)\n{\n    if (code == MSGF_DIALOGBOX) {\n        auto msg = (MSG*)lParam;\n        if (msg-&gt;message == WM_KEYDOWN &amp;&amp;\n            msg-&gt;wParam == VK_ESCAPE) {\n            auto hdlg = GetAncestor(msg-&gt;hwnd, GA_ROOT);\n            auto customMessage = PtrToUInt(GetProp(hdlg,\n                                           DIALOG_WANTS_ESC_PROP));\n            if (customMessage &amp;&amp;\n                !(SendMessage(msg-&gt;hwnd, WM_GETDLGCODE,\n                             msg-&gt;wParam, msg) &amp;\n                         (DLGC_WANTALLKEYS | DLGC_WANTMESSAGE)) &amp;&amp;\n                 <span style="border-bottom: none;">SendMessage(hdlg, customMessage, 0, lParam)) {</span>\n                 <span style="border-top: none;">return TRUE;                                  </span>\n            }\n        }\n    }\n    return CallNextHookEx(nullptr, nCode, wParam, lParam);\n}\n</pre>\n<p>Or we can have the first hook leave a note for the other hooks that the message has already been handled and that they shouldn&#8217;t try to handle it again.</p>\n<pre>#define DIALOG_WANTS_ESC_PROP TEXT("DialogWantsEsc")\n#define CURRENT_MESSAGE_PROP TEXT("DialogWantsEscCurrentMessage")\n\nLRESULT CALLBACK DialogEscHookProc(int nCode, WPARAM wParam, LPARAM lParam)\n{\n    if (code == MSGF_DIALOGBOX) {\n        auto msg = (MSG*)lParam;\n        if (msg-&gt;message == WM_KEYDOWN &amp;&amp;\n            msg-&gt;wParam == VK_ESCAPE) {\n            auto hdlg = GetAncestor(msg-&gt;hwnd, GA_ROOT);\n            auto customMessage = PtrToUInt(GetProp(hdlg,\n                                           DIALOG_WANTS_ESC_PROP));\n            if (customMessage) {\n                <span style="border-bottom: none;">auto previous = GetProp(hdlg, CURRENT_MESSAGE_PROP);</span>\n                <span style="border-top: none;">if (previous != msg &amp;&amp;                              </span>\n                    !(SendMessage(msg-&gt;hwnd, WM_GETDLGCODE,\n                                 msg-&gt;wParam, msg) &amp;\n                             (DLGC_WANTALLKEYS | DLGC_WANTMESSAGE))) {\n                    return SendMessage(hdlg, customMessage, 0, lParam);\n                }\n                <span style="border-bottom: none;">SetProp(hdlg, CURRENT_MESSAGE_PROP, msg);                     </span>\n                <span style="border-style: none solid;">auto result = CallNextHookEx(nullptr, nCode, wParam, lParam); </span>\n                <span style="border-style: none solid;">SetProp(hdlg, CURRENT_MESSAGE_PROP, previous);                </span>\n                <span style="border-top: none;">return result;                                                </span>\n            }\n        }\n    }\n    return CallNextHookEx(nullptr, nCode, wParam, lParam);\n}\n</pre>\n<p>The first hook will send the message to the dialog. and if the dialog declines to handle it, it passes the messages to the other hooks, but setes the &#8220;current message&#8221; property to the message that was already handled, so that other hooks won&#8217;t try to handle it again.</p>\n<p>The last part of the puzzle is installing the hook. Since we are assuming that we cannot alter the dialog loop, the hook has to be installed by the dialog itself.</p>\n<p>Let&#8217;s assume that this dialog box already allocates other dialog state, so we can add the hook handle to the state structure.</p>\n<pre>struct DIALOGSTATE\n{\n    wil::unique_hhook escapeHook;\n    ⟦ other stuff ⟧\n};\n\n// each dialog can choose its own custom message\n#define DM_ESCPRESSED (WM_USER+1000)\n\nINT_PTR CALLBACK DialogProc(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    switch (message) {\n    case WM_INITDIALOG:\n        {\n            DIALOGSTATE* state = new(std:nothrow) DIALOGSTATE();\n            if (!state) { EndDialog(hdlg, -1); return FALSE; }\n            SetWindowLongPtr(hdlg, DWLP_USER, (LONG_PTR)state);\n            <span style="border-bottom: none;">state-&gt;escapeHook.reset(SetWindowsHookEx(WM_MSGFILTER,     </span>\n            <span style="border-style: none solid;">                 DialogEscHookProc,                        </span>\n            <span style="border-style: none solid;">                 nullptr, GetCurrentThreadId()));          </span>\n            <span style="border-style: none solid;">SetProp(hdlg, DIALOG_WANTS_ESC_PROP,                       </span>\n            <span style="border-top: none;">        IntToPtr(DM_ESCPRESSED));                          </span>\n            ⟦ other dialog initialization as before ⟧\n            ⟦ ending with "return (whatever)" ⟧\n        }\n\n    case DM_ESCPRESSED:\n        if (⟦ we want to process the ESC key ourselves ⟧) {\n            ⟦ do custom ESC key processing ⟧\n            SetWindowLongPtr(hdlg, DWLP_MSGRESULT, TRUE);\n            return TRUE;\n        }\n        break;\n\n    case WM_DESTROY:\n        {\n            auto state = (DLGSTATE*)GetWindowLongPtr(hdlg, DWLP_USER);\n            delete state;\n        }\n        break;\n\n    ⟦ handle other messages ⟧\n    }\n    return FALSE;\n}\n</pre>\n<p>The dialog installs the hook when it is created and removes it when it is destroyed. The hook has become an implementation detail of the dialog.</p>\n<p>Now, I don&#8217;t recommend doing all this. Better is to just treat with the <kbd>ESC</kbd> like any other press of the (possibly imaginary) Cancel button. One of the few scenarios I can think of where this could be useful is if you want to display an extra confimation for the Close button (since its meaning is potentially ambiguous). This is still nonstandard, but at least it&#8217;s not <i>too</i> nonstandard. And for that, you can just intercept <code>WM_CLOSE</code> instead of trying to intercept the <kbd>ESC</kbd>. Intercepting the <kbd>ESC</kbd> was really just an excuse to show off message filters, which tend to be unappreciated.</p>\n<p>The post <a href="https://devblogs.microsoft.com/oldnewthing/20260227-00/?p=112094">Intercepting messages inside &lt;CODE&gt;Is&shy;Dialog&shy;Message&lt;/CODE&gt;, fine-tuning the message filter</a> appeared first on <a href="https://devblogs.microsoft.com/oldnewthing">The Old New Thing</a>.</p>'}

---

*抓取时间: 2026-02-28 06:11:59*
