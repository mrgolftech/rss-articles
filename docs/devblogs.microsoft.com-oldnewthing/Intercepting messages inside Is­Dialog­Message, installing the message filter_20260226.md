# Intercepting messages inside Is­Dialog­Message, installing the message filter

**来源:** [devblogs.microsoft.com/oldnewthing](https://devblogs.microsoft.com/oldnewthing)
**发布时间:** Thu, 26 Feb 2026 15:00:00 +0000
**链接:** https://devblogs.microsoft.com/oldnewthing/20260226-00/?p=112090

---

{'type': 'text/html', 'language': None, 'base': 'https://devblogs.microsoft.com/oldnewthing/feed', 'value': '<p>Last time, we saw that one way to intercept the <kbd>ESC</kbd> in the standard dialog message loop is <a href="https://devblogs.microsoft.com/oldnewthing/20260225-00/?p=112087" title="Intercepting messages before IsDialogMessage can process them"> to use your own dialog message loop</a>. However, you might not be able to do this, say, because the dialog procedure uses <code>End\xadDialog()</code>, and the dialog exit code is not retrievable from a custom message loop.</p>\n<p>The <code>Is\xadDialog\xadMessage</code> includes an extensibility point that lets you hook into the message processing. You can register a message filter hook and listen for <code>MSGF_DIALOG\xadBOX</code>.</p>\n<p>Before processing a message, the <code>Is\xadDialog\xadMessage</code> function does a <code>Call\xadMsg\xadFilter</code> with the message that it is about to process and the filter code <code>MSGF_DIALOG\xadBOX</code>. If the filter result is nonzero (indicating that one of the hooks wanted to block default processing), then the <code>Is\xadDialog\xadMessage</code> returns without doing anything. This lets us grab the <kbd>ESC</kbd> from <code>Is\xadDialog\xadMessage</code> before it turns into an <code>IDCANCEL</code>.</p>\n<p>Here&#8217;s our first attempt. (There will be more than one.)</p>\n<pre>HWND hdlgHook;\n#define DM_ESCPRESSED (WM_USER + 100)\n\nLRESULT CALLBACK DialogEscHookProc(int nCode, WPARAM wParam, LPARAM lParam)\n{\n    if (code == MSGF_DIALOGBOX) {\n        auto msg = (MSG*)lParam;\n        if (IsDialogESC(hdlgHook, msg)) {\n            return SendMessage(hdlg, DM_ESCPRESSED, 0, lParam);\n        }\n    }\n    return CallNextHookEx(nullptr, nCode, wParam, lParam);\n}\n</pre>\n<p>Our hook procedure first checks that it&#8217;s being called by <code>Is\xadDialog\xadMessage</code>. if so, and the message is a press of the <kbd>ESC</kbd> key destined for our dialog box (or a control on that dialog box), then send the dialog box a <code>DM_ESC\xadPRESSED</code> message to ask it what it thinks. The dialog procedure can return <code>TRUE</code> to block default processing or <code>FALSE</code> to allow default processing to continue.</p>\n<p>Here is the handler in the dialog procedure itself:</p>\n<pre>INT_PTR CALLBACK DialogProc(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    switch (message) {\n    case WM_INITDIALOG:\n        hdlgHook = hdlg;\n        ⟦ other dialog initialization as before ⟧\n        ⟦ ending with "return (whatever)" ⟧\n\n    case DM_ESCPRESSED:\n        if (⟦ we want to process the ESC key ourselves ⟧) {\n            ⟦ do custom ESC key processing ⟧\n            SetWindowLongPtr(hdlg, DWLP_MSGRESULT, TRUE);\n            return TRUE;\n        }\n        break;\n    ⟦ handle other messages ⟧\n    }\n    return FALSE;\n}\n</pre>\n<p>When the dialog initializes, remember its handle as the dialog for which the <code>Dialog\xadEsc\xadHook\xadProc</code> is operating.</p>\n<p>When the dialog is informed that the <kbd>ESC</kbd> key was pressed, we decide whether we want to process the <kbd>ESC</kbd> key ourselves. If so, then we do that custom processing and set up to return <code>TRUE</code> from the window procedure. For dialog procedures, this is done by setting the message result to the desired window procedure result and then returning <code>TRUE</code> to block default dialog box message processing and instead return the value we set (which is <code>TRUE</code>) from the window procedure.</p>\n<p>Finally, we install the message hook before we create the dialog box and remove it when the dialog box dismisses.</p>\n<pre>auto hook = SetWindowsHookEx(WM_MSGFILTER, DialogEscHookProc,\n                             nullptr, GetCurrentThreadId());\nauto result = DialogBox(hinst, MAKEINTRESOURCE(IDD_WHATEVER),\n                        hwndOwner, DialogProc);\nUnhookWindowsHookEx(hook);\n</pre>\n<p>This is the basic idea, but we see that there are a few problems.</p>\n<p>One is that we are communicating the dialog box handle through a global variable. This means that we can&#8217;t have multiple threads using this hook at the same time. Fortunately, that can be fixed by changing the variable to be <code>thread_local</code>, although this does drag in the cost of thread-local variables.</p>\n<p>But even if we do that, we have a problem if two copies of this dialog box are shown <i>by the same thread</i>. For example, one of the controls in the dialog might launch another copy of this dialog, but with different parameters. For example, a &#8220;View certificate&#8221; dialog might have a button called &#8220;View parent certificate&#8221;.</p>\n<p>We&#8217;ll take up these issues (and others) next time.</p>\n<p>The post <a href="https://devblogs.microsoft.com/oldnewthing/20260226-00/?p=112090">Intercepting messages inside &lt;CODE&gt;Is&shy;Dialog&shy;Message&lt;/CODE&gt;, installing the message filter</a> appeared first on <a href="https://devblogs.microsoft.com/oldnewthing">The Old New Thing</a>.</p>'}

---

*抓取时间: 2026-02-27 02:38:48*
