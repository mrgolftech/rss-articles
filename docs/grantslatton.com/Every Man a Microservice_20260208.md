# Every Man a Microservice

**来源:** [grantslatton.com](https://grantslatton.com)
**发布时间:** Sun, 8 Feb 2026 17:54:20 +0000
**链接:** https://grantslatton.com/every-man-a-microservice

---

{'type': 'text/html', 'language': None, 'base': 'https://grantslatton.com/rss.xml', 'value': '<h1>Every Man a Microservice</h1>\n<blockquote>\n<p>Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations.</p>\n<p>—\u200aMelvin E. Conway, How Do Committees Invent?</p>\n</blockquote>\n<p>Conway\'s law appears true if you observe organizations and systems as they are, <strong>but the causality is reversed</strong>.</p>\n<p>Systems are not <em>conceived</em> by organizations, but by a single individual or a tight-knit cabal.</p>\n<p>As such, there is no communication structure to emulate. The initial idea is conjured as a gestalt and an organization <em>is built around</em> the system as it comes into existence and operates.</p>\n<p><strong>And thus we invert Conway\'s law</strong>: A system\'s design informs the communication structure of the organization that is built around it.</p>\n<p>With this in mind, we can ask: what design facilitates the most effective organization?</p>\n<p>There\'s a whole landscape of solutions here, but I just want to focus on one that I saw work <em>extremely</em> well in the earlier years of AWS.</p>\n<h3>The right way</h3>\n<p>The idea is your system is made up of person-sized services. A person-sized service is one whose codebase is in the realm of a few tens of thousands of lines of code.</p>\n<p>This scale is such that a single developer, working on that codebase full-time, can keep the whole codebase in their head.</p>\n<p><em>N.B. By "codebase in head" I don\'t mean they literally know every line of code. I mean they have a complete picture of all the modules, interfaces, data structures, scaling dimensions, tradeoffs, design decisions, etc.</em></p>\n<p>You want there to be a 1-to-1 mapping between each service and an individual who has that service\'s code completely loaded into their brain.</p>\n<p>The advantages of having the whole service loaded into an individual brain is hard to overstate.</p>\n<p><strong>It enables a ton of offline mulling</strong>. Your devs know their domain so well, they\'ll have regular shower-thoughts about how to optimize their service.</p>\n<p><strong>You reach consensus on improvements faster</strong>. Alice has an idea in a shower. She wants Bob\'s system to start batching requests to hers to improve her cache hit ratio. She tells Bob the idea in the morning. Bob calls over Charlie, whose service would also be affected. In 20 minutes they agree on a path forward. The code is shipped after lunch.</p>\n<p><strong>You actually have fewer outages and issues</strong>. You might think an organization that designs features in 20 minutes and ships them after lunch is going to break things by moving so fast. But in practice, a single engineer with 100% context will anticipate and design around issues better than a design review by a whole team of devs who each have 50% context.</p>\n<p><strong>Quality goes up</strong>. Each owner has a narrative for the health of their codebase: aspirations for future improvements, haunted by lingering jank. They take this holistic view into account when considering all ideas. They have the familiarity needed to do deep, refactoring integrations, but also to safely add hacks when the business needs it.</p>\n<p><strong>Architectural changes are politically manageable</strong>. It\'s much easier for technical management (i.e. principal engineers) to rearchitect the system, because individual devs have essentially no political power or desire for such. They won\'t defend their service if it becomes vestigial as long as you give them something else to own.</p>\n<p><strong>Engineers develop faster</strong>. Take a college-hire and give them one of the smaller services. Tell them "this service is yours, and you are this service, you are one". This is a sink-or-swim tactic, but a good one. Engineers that can\'t take individual ownership are toxic to the long-term health of the org. Those that can have a much higher likelihood of evolving into high-value <a href="https://blog.sbensu.com/posts/lieutenants/">lieutenants</a>.</p>\n<h3>The wrong way</h3>\n<p>If you\'ve worked at a traditional company, you\'ve probably seen the inverse of all this. Services aren\'t owned by individuals, but by whole teams. A team of 8 people might own 3 services. Everyone is kind of vaguely familiar with all of them, but nobody is a master of any one.</p>\n<p>Because nobody is a master, people will tend to implement changes in a purely accretive way. They\'re afraid to do deeper refactors to integrate changes more holistically.</p>\n<p>And for good reason! When they attempt such deeper refactors without a complete understanding of the service they\'re operating on, they\'re stumbling in the dark and cause outages. They do design reviews with the team to try to mitigate this, but nobody knows enough to contribute more than surface-level concerns.</p>\n<p>Managers in charge of teams will resist deprecation of the services their team owns. Not only will they do this, but they will actually invent new services that don\'t need to exist to justify increasing their headcount (which increases their status).</p>\n<h3>Risks</h3>\n<p><strong>What happens when the owner of a system gets hit by a bus?</strong> Or, less dramatically, leaves the company.</p>\n<p>In practice, engineers in such an org don\'t <em>only</em> have context on their single service. They\'ll typically have a decent amount of context on the services theirs touches, and vice versa. After all, who is doing code reviews for whom?</p>\n<p>Most of the devs who\'ve been around for a while will have owned a few different services at different points in their career. When they joined as a college-hire, they were given a tiny metadata caching service. Then someone left and they were given that guy\'s medium-sized service. Then they had an idea for a brand new system, built it, and now own it as a senior engineer.</p>\n<p>The effect is a senior engineer in the org will have somewhat-stale but easily-refreshable context on a handful of services. It\'s like riding a bike. This is useful both for bus-factor situations, and also mentoring the juniors who own those services.</p>\n<p>So in a bus-factor situation, there are usually enough seniors around who can keep the lights on until a new owner is found. And in this kind of org, you\'ll always have a cohort of bright up-and-coming juniors who passed the sink-or-swim test and are ready to take ownership of a bigger service.</p>\n<p><strong>How to manage such an org?</strong> That is, what is the place for managers in this brave world?</p>\n<p>Such a system only needs a few managers, because it won\'t have <em>that</em> many engineers. It won\'t have that many engineers because there simply don\'t exist very many systems that <em>need</em> that many services.</p>\n<p>For context, <a href="https://en.wikipedia.org/wiki/Amazon_S3">AWS S3</a> was built and operated by fewer than 20 engineers in the early years. And if you were to design a storage service on a whiteboard, you might find yourself with 20 or so boxes. There\'s the storage node, the webserver, the caching layer, the index, the corruption scanner, etc etc etc. It all adds up. Almost no system needs more than a few dozen boxes on the whiteboard.</p>\n<p>In such a world, you only need a handful of managers, and you definitely don\'t need many layers of management. You want the person in charge of the whole org, a small handful of managers, and then all the engineers.</p>\n<p>The person in charge of the whole org should rely on senior technical <a href="https://blog.sbensu.com/posts/lieutenants/">lieutenants</a> as much as (and perhaps more than) management to maintain visibility.</p>'}

---

*抓取时间: 2026-02-09 06:02:18*
