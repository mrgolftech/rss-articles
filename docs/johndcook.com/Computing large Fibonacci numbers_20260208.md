# Computing large Fibonacci numbers

**来源:** [johndcook.com](https://johndcook.com)
**发布时间:** Sun, 08 Feb 2026 13:51:25 +0000
**链接:** https://www.johndcook.com/blog/2026/02/08/computing-large-fibonacci-numbers/

---

{'type': 'text/html', 'language': None, 'base': 'https://www.johndcook.com/blog/feed/', 'value': '<p>The previous post discussed two ways to compute the <em>n</em>th Fibonacci number. The first is to compute all the Fibonacci numbers up to the\xa0<em>n</em>th iteratively using the defining property of Fibonacci numbers</p>\n<p style="padding-left: 40px;"><em>F</em><sub><em>n</em> + 2</sub> = <em>F</em><sub><em>n</em></sub> + <em>F</em><sub><em>n</em> + 1</sub></p>\n<p>with extended integer arithmetic.</p>\n<p>The second approach is to use Binet&#8217;s formula</p>\n<p style="padding-left: 40px;"><em>F</em><sub><em>n</em></sub> = round( φ<sup><em>n</em></sup> / √ 5 )</p>\n<p>where φ is the golden ratio.</p>\n<p>It&#8217;s not clear which approach is more efficient. You could say that the iterative approach has run time\xa0<em>O</em>(<em>n</em>) while Binet&#8217;s formula is\xa0<em>O</em>(1). That doesn&#8217;t take into account how much work goes into each step, but it does suggest that eventually Binet wins.</p>\n<p>The relative efficiency of each algorithm depends on how it is implemented. In this post I will compare using Python&#8217;s integer arithmetic and the <code>mpmath</code> library for floating point. Here&#8217;s my code for both methods.</p>\n<pre>from math import log10\nimport mpmath as mp\n\ndef fib_iterate(n):\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a\n\ndef digits_needed(n):\n\n    phi = (1 + 5**0.5) / 2\n    return int(n*log10(phi) - 0.5*log10(5)) + 1\n\ndef fib_mpmath(n, guard_digits=30):\n\n    digits = digits_needed(n)\n\n    # Set decimal digits of precision\n    mp.mp.dps = digits + guard_digits\n\n    sqrt5 = mp.sqrt(5)\n    phi = (1 + sqrt5) / 2\n    x = (phi ** n) / sqrt5\n\n    return int(mp.nint(x))\n</pre>\n<p>Next, here&#8217;s some code to compare the run times.</p>\n<pre>def compare(n):\n    \n    start = time.perf_counter()\n    x = fib_iterate(n)\n    elapsed = time.perf_counter() - start\n    print(elapsed)\n\n    start = time.perf_counter()\n    y = fib_mpmath(n)\n    elapsed = time.perf_counter() - start\n    print(elapsed)\n\n    if (x != y):\n        print("Methods produced different results.")\n</pre>\n<p>This code shows that the iterate approach is faster for\xa0<em>n</em> = 1,000 but Binet&#8217;s method is faster for <em>n</em> = 10,000.</p>\n<pre>&gt;&gt;&gt; compare(1_000)\n0.0002502090001144097\n0.0009207079999669077\n&gt;&gt;&gt; compare(10_000)\n0.0036547919999065925\n0.002145750000181579\n</pre>\n<p>For larger <em>n</em>, the efficiency advantage of Binet&#8217;s formula becomes more apparent.</p>\n<pre>\n&gt;&gt;&gt; compare(1_000_000)\n11.169050417000108\n2.0719056249999994\n</pre>\n<h2>Guard digits and correctness</h2>\n<p>There is one unsettling problem with the function <code>fib_mpmath</code> above: how many guard digits do you need? To compute a number correctly to 100 significant figures, for example, requires more than 100 digits of working precision. How many more? It depends on the calculation. What about our calculation? </p>\n<p>If we compute the 10,000th Fibonacci number using <code>fib_mpmath(10_000, 2)</code>, i.e. with 2 guard digits, we get a result that is incorrect in the last digit. To compute the 1,000,000th Fibonacci number correctly, we need 5 guard digits.</p>\n<p>We don&#8217;t need many guard digits, but we&#8217;re guessing at how many we need. How might we test whether we&#8217;ve guessed correctly? One way would be to compute the result using <code>fib_iterate</code> and compare results, but that defeats the purpose of using the more efficient <code>fib_mpmath</code>. </p>\n<p>If floating point calculations produce an incorrect result, the error is likely to be in the least significant digits. If we knew that the last digit was correct, that would give us more confidence that all the digits are correct. More generally, we could test the result mod <em>m</em>. I discussed Fibonacci numbers mod <em>m</em> in <a href="https://www.johndcook.com/blog/2017/11/24/distribution-of-fibonacci-numbers-mod-m/">this post</a>. </p>\n<p>When <em>m</em> = 10, the last digits of the Fibonacci numbers have a cycle of 60. So the Fibonacci numbers with index <em>n</em> and with index <em>n</em> mod 60 should be the same.</p>\n<p>The post I just mentioned links to a paper by Niederreiter that says the Fibonacci numbers ore evenly distributed mod <em>m</em> if and only if <em>m</em> is a power of 5, in which case the cycle length is 4<em>m</em>.</p>\n<p>The following code could be used as a sanity check on the result of <code>fig_mpmath</code>.</p>\n<pre>\ndef mod_check(n, Fn):\n    k = 3\n    base = 5**k\n    period = 4*base\n    return Fn % base == fib_iterate(n % period) % base\n</pre>\n<p>With <em>k</em> = 3, we are checking the result of our calculation mod 125. It is unlikely that an incorrect result would be correct mod 125. It&#8217;s hard to say just how unlikely. Naively we could say there&#8217;s 1 chance in 125, but that ignores the fact that the errors are most likely in the least significant bits. The chances of an incorrect result being correct mod 125 would be much less than 1 in 125. For more assurance you could use a larger power of 5.</p>The post <a href="https://www.johndcook.com/blog/2026/02/08/computing-large-fibonacci-numbers/">Computing large Fibonacci numbers</a> first appeared on <a href="https://www.johndcook.com/blog">John D. Cook</a>.'}

---

*抓取时间: 2026-02-09 06:02:18*
