# Wagon’s algorithm in Python

**来源:** [johndcook.com](https://johndcook.com)
**发布时间:** Sat, 14 Feb 2026 23:06:41 +0000
**链接:** https://www.johndcook.com/blog/2026/02/14/wagons-algorithm-in-python/

---

{'type': 'text/html', 'language': None, 'base': 'https://www.johndcook.com/blog/feed/', 'value': '<p>The last three posts have been about Stan Wagon&#8217;s algorithm for finding <em>x</em> and <em>y</em> satisfying</p>\n<p style="padding-left: 40px;"><em>x</em>² + <em>y</em>² = <em>p</em></p>\n<p>where <em>p</em> is an odd prime.</p>\n<p>The <a href="https://www.johndcook.com/blog/2026/02/12/pythagorean-primes/">first post</a> in the series gives Gauss&#8217; formula for a solution, but shows why it is impractical for large <em>p</em>. The bottom of this post introduces Wagon&#8217;s algorithm and says that it requires two things: finding a quadratic non-residue mod <em>p</em> and a variation on the Euclidean algorithm.</p>\n<p>The <a href="https://www.johndcook.com/blog/2026/02/14/finding-a-non-square/">next post</a> shows how to find a quadratic non-residue.</p>\n<p>The reason Wagon requires a non-residue is because he needs to find a square root of −1 mod <em>p</em>. The <a href="https://www.johndcook.com/blog/2026/02/14/square-root-minus-1-mod-p/">previous post</a> showed how that&#8217;s done.</p>\n<p>In this post we will complete Wagon&#8217;s algorithm by writing the modified version of the euclidean algorithm.</p>\n<p>Suppose <em>p</em> is an odd prime, and we&#8217;ve found <em>x</em> such that <em>x</em>² = −1 mod <em>p</em> as in the previous posts. The last step in Wagon&#8217;s algorithm is to apply the Euclidean algorithm to <em>x</em> and <em>p</em> and stop when the numbers are both less than √<em>p</em>.</p>\n<p>When we&#8217;re working with large integers, how do we find square roots? Maybe <em>p</em> and even √<em>p</em> are too big to represent as a floating point number, so we can&#8217;t just apply the <code>sqrt</code> function. Maybe <em>p</em> is less than the largest floating point number (around 10<sup>308</sup>) but the <code>sqrt</code> function doesn&#8217;t have enough precision. Floats only have 53 bits of precision, so an integer larger than 2<sup>53</sup> cannot necessarily be represented entirely accurately.</p>\n<p>The solution is to use the <code>isqrt</code> function, introduced in Python 3.8. It returns the largest integer less than the square root of its argument.</p>\n<p>Now we have everything necessary to finish implementing Wagon&#8217;s algorithm.</p>\n<pre>from sympy import legendre_symbol, nextprime\nfrom math import isqrt\n\ndef find_nonresidue(p):\n    q = 2\n    while legendre_symbol(q, p) == 1:\n        q = nextprime(q)\n    return q\n\ndef my_euclidean_algorithm(a, b, stop):\n    while a &gt; stop:\n        a, b = b, a % b\n    return (a, b)\n\ndef find_ab(p):\n    assert(p % 4 == 1)\n    k = p // 4\n    c = find_nonresidue(p)\n    x = pow(c, k, p)\n    return my_euclidean_algorithm(p, x, isqrt(p))\n</pre>\n<p>Let&#8217;s use this to find\xa0<em>a</em> and\xa0<em>b</em> such that <em>x</em>² + <em>y</em>² = <em>p</em> where <em>p</em> = 2<sup>255</sup> − 19.</p>\n<pre>&gt;&gt;&gt; a, b = find_ab(p := 2**255 - 19)\n&gt;&gt;&gt; a\n230614434303103947632580767254119327050\n&gt;&gt;&gt; b\n68651491678749784955913861047835464643\n&gt;&gt;&gt; a**2 + b**2 - p\n0\n</pre>\n<p><span lang="fr">Finis</span>.</p>The post <a href="https://www.johndcook.com/blog/2026/02/14/wagons-algorithm-in-python/">Wagon’s algorithm in Python</a> first appeared on <a href="https://www.johndcook.com/blog">John D. Cook</a>.'}

---

*抓取时间: 2026-02-18 18:04:21*
