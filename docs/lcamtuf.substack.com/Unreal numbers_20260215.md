# Unreal numbers

**来源:** [lcamtuf.substack.com](https://lcamtuf.substack.com)
**发布时间:** Sun, 15 Feb 2026 20:49:15 GMT
**链接:** https://lcamtuf.substack.com/p/unreal-numbers

---

{'type': 'text/html', 'language': None, 'base': 'https://lcamtuf.substack.com/feed', 'value': '<p>A while ago, I posted an article about the 19th and early 20th century quest to <a href="https://lcamtuf.substack.com/p/how-has-mathematics-gotten-so-abstract">derive mathematics from the principles of formal logic</a>. We kicked off with Peano arithmetic, which built natural numbers from two ad-hoc constructs: an element representing zero and an abstract &#8220;successor&#8221; function <em>S(&#8230;)</em>.</p><p>Later, we leaned on set theory to encode the underlying structure of these symbols. This netted us a hierarchy of set-theoretic natural numbers known as <em>ordinals</em>. It also led to an interesting insight: if we allowed the existence of infinite sets, then the set of all natural numbers (&#8469;) itself had the structure of an ordinal. In the article, we labeled this infinite number <em>&#969;</em> and demonstrated that it could be manipulated using the same arithmetic rules as finite numbers, but that it sometimes behaved in wacky ways. For example, we established that <em>&#969;</em> + 1<em> </em>&#8800; 1 + <em>&#969;</em>.</p><p>We also touched on various methods of reasoning about the magnitude of ordinals and showed that these approaches diverge from each other in the realm of infinities. In particular, we talked about Georg Cantor&#8217;s notion of <em>cardinality</em>, which put many distinct infinite ordinals in the same size class, but indicated that there&#8217;s a fundamental difference in scale between the set of natural numbers and the set of reals (&#8477;).</p><p>If you haven&#8217;t read the article but are intrigued, I strongly encourage you to give it a go (<a href="https://lcamtuf.substack.com/p/how-has-mathematics-gotten-so-abstract">link</a>). I think it&#8217;s an excellent and accessible introduction; if you need an endorsement, the brain trust over at HN called it <em>&#8220;watered down&#8221;</em> and <em>&#8220;slop&#8221;</em>.</p><p>If you&#8217;re up to speed, there might be one thing that&#8217;s bugging you: we carefully defined natural numbers from first principles, but then pulled reals out of a hat. This is a gap worth addressing, because as it turns out, real numbers are <em>profoundly</em> weird.</p><h3>Natural numbers (&#8469;)</h3><p>As a reminder, in the earlier article, we constructed a succession of natural numbers by conjuring an object representing zero and then successively applying function <em>S(&#8230;)</em> to it:</p><div class="latex-rendered"></div><p>The &#8220;:=&#8221; operator means &#8220;is defined as&#8221;. Elsewhere, you might see this written as &#8797;, &#8796;, or a regular =.</p><p>In Peano arithmetic, the label &#8220;0&#8221; and the successor function <em>S(&#8230;)</em> have no deeper meaning: they are just &#8220;things&#8221; with a couple of common-sense properties spelled out. All the notation indicates is that every subsequent label has some fixed relationship to the one that came before. In the set-theoretic approach we switched to later, we defined these concepts with more precision, but this detail doesn&#8217;t matter now.</p><p>The important point is that in both models, the successor relationship allowed us to define the behavior of the &#8220;+&#8221; operator using a pair of simple substitution rules:</p><div class="latex-rendered"></div><p>This ruleset lets anyone solve problems such as 2 + 2 without any assumptions about the fundamental meaning of &#8220;2&#8221; or &#8220;+&#8221;. </p><p>First, from the definition of Peano numbers, we note that &#8220;2&#8221; is the same as S(1), so 2 + 2 can be restated as 2 + S(1). Switching to that form allows us to apply rule #2, in turn rewriting 2 + S(1) as S(2 + 1):</p><div class="latex-rendered"></div><p>After that, we can apply the same steps again to expand the nested 2 + 1 sum:</p><div class="latex-rendered"></div><p>We now have a doubly-nested sum involving zero, so we can apply rule #1, getting rid of the sum (2 + 0 = 2) and &#8220;unwinding&#8221; the successor functions to arrive at the result:</p><div class="latex-rendered"></div><p>Again, if you&#8217;re interested in a more detailed walkthrough, including C code that explains the process in programmer-friendly terms, check out the article linked earlier on.</p><p>What we haven&#8217;t covered in that article is that we can use a similar approach to recursively define multiplication for natural numbers:</p><div class="latex-rendered"></div><p>In effect, without having to explicitly define subtraction, we&#8217;re saying that <em>a &#183; b</em> can be rewritten as <em>a &#183; (b-1) + a</em>, and that this expansion should be continued until we get to <em>a</em> <em>&#183; </em>0. At that point, the multiplication part works out to zero, so we just unwind the stack and gather all the &#8220;+ <em>a</em>&#8221; terms. This will come in handy in a while.</p><h3>Integers (&#8484;)</h3><p>A major hurdle on our path toward a complete system of arithmetic is that natural numbers can&#8217;t represent negative values. This means that if we attempt to define subtraction, many results will not have an in-system representation, throwing a wrench in the works.</p><p>To extend &#8469; to negative numbers, we could futz around with a way to encode the minus sign and then special-case it in the arithmetic rulesets. That said, a better approach is to define integers as a separate hierarchy of numbers, each integer <em>i </em>consisting of an ordered pair of naturals: <em>i =</em> <em>(a, b). </em>The first element of the pair represents the positive component while the second represents the negative part. That is, integer +5 can be encoded as (5, 0) while integer -5 becomes (0, 5).</p><p>You might be wondering if we just pulled the concept of an &#8220;ordered pair&#8221; out of thin air. Yes and no: it&#8217;s new here, but in set theory, these pairs are mapped to normal sets, except we design the mapping so that <em>(a, b)</em> differs from <em>(b, a)</em>. This can be done in a number of ways, but a common approach devised by Kazimierz Kuratowski is:</p><div class="latex-rendered"></div><p>In essence, the pair is represented by a two-element set, but the second element also includes a copy of the first, so the result is different depending on the order of the elements in the pair.</p><p>Coming back to integers: to sum two integers, we can simply add the positive and negative parts separately. Since the underlying elements are natural numbers, we already know how to add them, and we can write: </p><div class="latex-rendered"></div><p>In the same vein, because each integer effectively expresses the difference between two underlying naturals, the result of multiplying two integers (<em>a, b)</em> and <em>(c, d)</em> will follow the school-taught pattern of <em>(a - b) &#183; (c - d) = ac - ad - bc + bd. </em>We split the positive and negative parts of the solution and write:</p><div class="latex-rendered"></div><p>These rules work, sort of. For example, adding integer +5 and -5 nets us:</p><div class="latex-rendered"></div><p>The result (5, 5) <em>seems</em> to be saying &#8220;zero&#8221;, but is not what we&#8217;d choose as the canonical representation of that value; we would have preferred (0, 0). More generally, we&#8217;d say that any two pairs <em>(a, b)</em> and <em>(c, d)</em> represent the same integer if <em>a - b = c - d</em>. Yet, our system doesn&#8217;t take this property into account.</p><p>Because we still haven&#8217;t defined subtraction, we must first shuffle the terms around to express the &#8220;sameness&#8221; criterion in terms of addition:</p><div class="latex-rendered"></div><p>With this pair equivalence relationship defined, we assign integer labels such as &#8220;+5&#8221; not to a specific pair, but to an entire <em>equivalence class</em>: a collection of ordered pairs that satisfy the same criteria. In this model, our new hierarchy of numbers looks the following way:</p><div class="latex-rendered"></div><p>We&#8217;re mostly done with integers, but before we wrap up, let&#8217;s ponder if the set of integers is &#8220;larger&#8221; than the set of natural numbers. By some metrics, you could argue it is. That said, as hinted in the earlier article, every integer can be mapped to a natural number without the risk of running out of naturals:</p><div class="captioned-image-container"><figure><a class="image-link image2 is-viewable-img" href="https://substackcdn.com/image/fetch/$s_!sROe!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe949bc4d-f2a9-4f30-a0be-64c07da5b857_2000x800.jpeg" target="_blank"><div class="image2-inset"><source type="image/webp" /><img alt="" class="sizing-normal" height="582" src="https://substackcdn.com/image/fetch/$s_!sROe!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe949bc4d-f2a9-4f30-a0be-64c07da5b857_2000x800.jpeg" width="1456" /><div class="image-link-expand"><div class="pencraft pc-display-flex pc-gap-8 pc-reset"><button class="pencraft pc-reset pencraft icon-container restack-image" tabindex="0" type="button"><svg fill="none" height="20" stroke="var(--color-fg-primary)" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 20 20" width="20" xmlns="http://www.w3.org/2000/svg"><g><title></title><path d="M2.53001 7.81595C3.49179 4.73911 6.43281 2.5 9.91173 2.5C13.1684 2.5 15.9537 4.46214 17.0852 7.23684L17.6179 8.67647M17.6179 8.67647L18.5002 4.26471M17.6179 8.67647L13.6473 6.91176M17.4995 12.1841C16.5378 15.2609 13.5967 17.5 10.1178 17.5C6.86118 17.5 4.07589 15.5379 2.94432 12.7632L2.41165 11.3235M2.41165 11.3235L1.5293 15.7353M2.41165 11.3235L6.38224 13.0882"></path></g></svg></button><button class="pencraft pc-reset pencraft icon-container view-image" tabindex="0" type="button"><svg class="lucide lucide-maximize2 lucide-maximize-2" fill="none" height="20" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="20" xmlns="http://www.w3.org/2000/svg"><polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" x2="14" y1="3" y2="10"></line><line x1="3" x2="10" y1="21" y2="14"></line></svg></button></div></div></div></a><figcaption class="image-caption"><em>A simple mapping between &#8484; and &#8469;.</em></figcaption></figure></div><p>There&#8217;s seemingly nothing stopping us from taking this route, so we say that the sets have the same cardinality.</p><h3>Rationals (&#8474;)</h3><p>Rational numbers are values that can be expressed as a ratio of two integers: <em>a / b</em>. In the previous section, we defined integers using an ordered pair that effectively encoded subtraction: <em>a - b</em>. So, here&#8217;s the cool part: nothing stops us from taking two integers and fashioning them into a new type of a pair that encodes division. Each of these pairs forms a new hierarchy of rational numbers: <em>q = (a, b)</em>.</p><p>In this model, we consider rational pairs <em>(a, b)</em> and <em>(c, d) </em>to be equivalent if the underlying integers satisfy the criterion <em>a / b = c / d. </em>We don&#8217;t have division defined yet, but we know how to multiply integers, so we can restate the equivalence rule as:</p><div class="latex-rendered"></div><p>This nets us the following taxonomy:</p><div class="latex-rendered"></div><p>The multiplication rule for two pairs representing rational numbers is just a trivial restatement of <em>a/b &#183; c/d = ac/(bd)</em>:</p><div class="latex-rendered"></div><p>The addition of these pairs is equally straightforward and follows the normal <em>a/b + c/d = (ad + cb) / (bd) </em>pattern:</p><div class="latex-rendered"></div><p>What&#8217;s the &#8220;size&#8221; of &#8474;? Well, again, depends on how we look at it, but we can show that the cardinality of  is not greater than &#8469;. One visual approach is to construct a two-dimensional array of fractions in the form of <em>x/y</em>:</p><div class="captioned-image-container"><figure><a class="image-link image2 is-viewable-img" href="https://substackcdn.com/image/fetch/$s_!ECAr!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F4e573715-620f-42e0-9259-2be71f3c9bd4_2000x1084.jpeg" target="_blank"><div class="image2-inset"><source type="image/webp" /><img alt="" class="sizing-normal" height="789" src="https://substackcdn.com/image/fetch/$s_!ECAr!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F4e573715-620f-42e0-9259-2be71f3c9bd4_2000x1084.jpeg" width="1456" /><div class="image-link-expand"><div class="pencraft pc-display-flex pc-gap-8 pc-reset"><button class="pencraft pc-reset pencraft icon-container restack-image" tabindex="0" type="button"><svg fill="none" height="20" stroke="var(--color-fg-primary)" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" viewBox="0 0 20 20" width="20" xmlns="http://www.w3.org/2000/svg"><g><title></title><path d="M2.53001 7.81595C3.49179 4.73911 6.43281 2.5 9.91173 2.5C13.1684 2.5 15.9537 4.46214 17.0852 7.23684L17.6179 8.67647M17.6179 8.67647L18.5002 4.26471M17.6179 8.67647L13.6473 6.91176M17.4995 12.1841C16.5378 15.2609 13.5967 17.5 10.1178 17.5C6.86118 17.5 4.07589 15.5379 2.94432 12.7632L2.41165 11.3235M2.41165 11.3235L1.5293 15.7353M2.41165 11.3235L6.38224 13.0882"></path></g></svg></button><button class="pencraft pc-reset pencraft icon-container view-image" tabindex="0" type="button"><svg class="lucide lucide-maximize2 lucide-maximize-2" fill="none" height="20" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="20" xmlns="http://www.w3.org/2000/svg"><polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" x2="14" y1="3" y2="10"></line><line x1="3" x2="10" y1="21" y2="14"></line></svg></button></div></div></div></a><figcaption class="image-caption"><em>Laying out and traversing &#8474;.</em></figcaption></figure></div><p>It should be evident that because <em>x </em>and <em>y</em> coordinates go through every possible natural number, the array contains all positive rational fractions. Some of the tiles are redundant (e.g., 2 is the same as 4/2), but this is not important for the proof.</p><p>With the rationals laid out, we can traverse this grid in a way that lets us assign every tile to an integer without leaving any gaps and without ever running out of members of &#8469;. The start of one such traversal pattern is indicated by arrows in the figure. We start in the top left corner, move one tile to the right, take a a sharp turn to and start moving diagonally until we hit the vertical edge, move one tile down, and then follow a diagonal pattern back. Rinse, repeat. By analogy to what we&#8217;ve done for integers, the result doesn&#8217;t change if we toss negative rationals into the mix.</p><h3>Computable numbers</h3><p>Not every number can be expressed as an integer fraction. The two examples of irrational numbers that every reader should be familiar with are &#8730;2, which can be expressed in polynomial terms, and <em>&#960;</em>, which cannot.</p><p>Although these numbers can&#8217;t be represented as simple fractions, they can be explained in terms of an algorithm you need to follow to approximate them to an arbitrary degree. For example, the sum of the following terms starting at <em>n = </em>0 will slowly but surely converge to <em>&#960;</em> as the count of summed elements grows:</p><div class="latex-rendered"></div><p>Within the bounds of the precision of floating-point numbers, you can observe the behavior by running the following C code (<a href="https://godbolt.org/z/1qdd1TqvT">demo link</a>):</p><blockquote><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n\nint main() {\n  double sum = 0;\n  for (uint64_t n = 0, pos = 0; n &lt;= 65536; n++) {\n    sum += 8.0 / ((4*n + 1) * (4*n + 3));\n    if (n &gt;&gt; pos) { printf("[%5ld] %.05f\\n", n, sum); pos++; }\n  }\n}</code></pre><p></p></blockquote><p>At first blush, it would appear that any well-specified irrational number of our choice can be expressed as an approximation algorithm. This leads to a concept that should appeal to any geek: <em> computable numbers</em>. It&#8217;s the set of all numbers that can be approximated to an arbitrary precision in finite time by a theoretical model of a computer known as a Turing machine. In effect, the number <em>is </em>the algorithm.</p><p>Interestingly, the cardinality of the set of computable numbers is still the same as the cardinality of &#8469;. An intuitive explanation is that there are only as many computable numbers as there are Turing machines that could generate them. The ruleset of every Turing machine can be encoded as a finite natural number &#8212; you could just write it down and then convert the spec to ASCII values &#8212; so we&#8217;re still in the realm of countable infinities.</p><h3>Reals (&#8477;)</h3><p>Of course, we don&#8217;t teach about computable numbers in school. Instead, the most common &#8220;upgrade&#8221; from &#8474; are reals: an idealized continuum on which, to put in a hand-wavy way, <em>every number exists</em> whether we know how to algorithmically approximate it or not.</p><p>Of course, my phrasing is severely deficient. It&#8217;s not a free-for-all: &#129364; (a potato) is not a real number, and to avoid a variety of complications, neither is &#8730;-1. The set &#8477; extends &#8474;, but it does so only in the immediate vicinity of rationals. Pick any real and I can find a rational fraction that&#8217;s arbitrarily close.</p><p>To describe the underlying structure of real numbers, we can turn to <em>Dedekind cuts</em>. Informally, the idea is that we can unambiguously identify each real number by associating it with the set of all rationals that come before it. To describe real number <em>x, </em>we could take the set of rational numbers and partition it into an ordered pair of sets <em>(A, B)</em>, such that set <em>A </em>contains every rational <em>q </em>&lt; <em>x</em> and set B contains every <em>q &#8805; x</em>.</p><p>At first blush, this description may seem circular: to build the representation of a real number, we need to know where to make the cut. That said, the point isn&#8217;t that the method lets you find the exact spot for <em>&#960;</em>. It&#8217;s that the universe of real numbers is built by taking every possible Dedekind cut of &#8474;. The numbers <em>are</em> the cuts, and <em>&#960; </em>is somewhere out there.</p><p>To be fair, for some irrational numbers, we can describe the partition in pretty intuitive terms. For example, to describe the cut<em> </em>for &#8731;3, we can say that set <em>A </em>consists of every rational <em>q</em> such that <em>q&#179;</em> &lt; 3 and set <em>B</em> contains every <em>q</em> such that <em>q&#179;</em> &#8805; 3. But again: the existence of a real number doesn&#8217;t depend on us being able to specify where it lies.</p><p>Once we have numbers expressed in terms of Dedekind cuts, we can define arithmetic operations, too. For example, to add real <em>(A, B)</em> to <em>(C, D)</em>, we construct a new number <em>(E, F)</em> such that for every possible rational <em>a</em> selected from <em>A </em>and every rational <em>c </em>selected from <em>C, </em>the sum <em>a + c </em>is placed in <em>E. </em>In the same vein, for every <em>b </em>in <em>B</em> and <em>d </em>in<em> D, </em>the sum <em>b + d </em>goes into <em>F</em>. </p><p>I&#8217;ll spare you the abstract set notation, but as a practical example, if <em>(A, B) </em>represents 2 and (<em>C, D)</em> represents 3, we know that every <em>a </em>selected from <em>A</em> will be less than 2 and every <em>c</em> chosen from <em>C </em>will be less than 3. Therefore, every <em>a + c </em>value placed in <em>E</em> will be always less than 5. Similarly, every <em>b + d </em>that goes into <em>F </em>will be greater or equal than 5. The resulting pair <em>(E, F)</em> is therefore the same as the cut representing the number 5.</p><p>We now have a continuum that contains numbers that are allowed to exist regardless of whether they can be described by an effective, finite procedure. As an unexpected consequence, the cardinality of &#8477; is higher than &#8469;. </p><p>We explored this property in the earlier article, but to briefly recap the argument, imagine an arbitrary, infinite mapping that assigns every integer to a real:</p><div class="latex-rendered"></div><p>For every real number in the mapping, I underlined a successive decimal position. Equipped with this, we can imagine a new real that could be built by looking at each of the underlined digits and then placing a <em>different</em> digit in the corresponding position of the newly-constructed value.</p><p>By construction, this new real necessarily differs by at least one digit from every existing entry in the mapping. This means we still have a value &#8212; or really, an infinite supply of values &#8212; left over after assigning every natural number to a real. It would appear that there is a fundamentally higher &#8220;number&#8221; of reals than naturals &#8212; an uncountable infinity.</p><h3>So what?</h3><p>Well&#8230; from the earlier discussion, recall that the cardinality of computable numbers was the same as the cardinality of &#8469;. The cardinality of &#8477; &#8212; the &#8220;magnitude&#8221; of the set of reals &#8212; is fundamentally greater than that. In other words, we could assert that most reals are uncomputable.</p><p>But what would be an example of an uncomputable number? That&#8217;s a good question. Most obviously, we could be talking about numbers that encode the solution to the halting problem. It would <a href="https://lcamtuf.substack.com/p/monkeys-typewriters-and-busy-beavers">lead to a paradox</a> to have a computer program that allows us to decide, in the general case, whether a given computer program halts. So, if a procedure to approximate a particular real necessarily requires solving the halting problem, we can&#8217;t have that.</p><p>If you&#8217;re interested in a more thorough exploration of the idea, check out my earlier article on <a href="https://lcamtuf.substack.com/p/monkeys-typewriters-and-busy-beavers">busy beavers and the limits of algorithmic knowledge</a>. But to cut to the chase, there are those who believe that the universe is functionally a computer &#8212; that is, that its rules are deterministic and can be simulated by a Turing machine. If so, that would imply that uncomputable numbers can&#8217;t be zeroed in on by any physical process, including human thought. They would be truly out of reach&#8230; and again, this would apply to almost every member of &#8477;.</p><p>Cue the <em>Twilight Zone</em> theme music &#8212; and see you in a bit.</p><p class="button-wrapper"><a class="button primary" href="https://lcamtuf.substack.com/subscribe"><span>Subscribe now</span></a></p>'}

---

*抓取时间: 2026-02-18 18:04:21*
