# GitButler CLI Is Really Good

**来源:** [matduggan.com](https://matduggan.com)
**发布时间:** Mon, 09 Feb 2026 12:33:02 GMT
**链接:** https://matduggan.com/gitbutler-cli-is-really-good/

---

{'type': 'text/html', 'language': None, 'base': 'https://matduggan.com/rss/', 'value': '<p>My workflow has remained mostly the same for over a decade. I write everything in Vim using the configuration found <a href="https://github.com/braintreeps/vim_dotfiles" rel="noreferrer">here</a>. I run Vim from inside of tmux with a configuration found <a href="https://github.com/braintreeps/vim_dotfiles/blob/master/tmux_example.conf" rel="noreferrer">here</a>. I write things on a git branch, made with the <code>git</code> CLI, then I add them with <code>git add --patch</code> to that branch, trying to run all of the possible linting and tests with <code>git hooks</code> before I waste my time on GitHub Actions. Then I run <code>git up</code> which is an alias to <code>pull --rebase --autostash</code>. Finally I successfully commit, then I copy paste the URL returned by GitHub to open a PR. Then I merge the PR and run <code>git ma</code> to go back to the primary branch, which is an alias to <code>ma = &quot;!f() {git checkout $(git primary) &amp;&amp;git pull;}; f&quot;</code>.</p><p>This workflow, I think, is pretty familiar for anyone working with GitHub a lot. Now you&apos;ll notice I&apos;m not saying <code>git</code> because almost nothing I&apos;m doing has anything to do with <code>git</code>. There&apos;s no advantage to my repo being local to my machine, because everything I need to actually merge and deploy code lives on GitHub. The CI runs there, the approval process runs there, the monitoring of the CI happens there, the injection of secrets happens there. If GitHub is down my local repo does, effectively, nothing. </p><p>My source of truth is always remote, which means I pay the price for <code>git</code> complexity locally but I don&apos;t benefit from it. At most jobs:</p><ul><li>You can&apos;t merge without GitHub (PRs are the merge mechanism)</li><li>You can&apos;t deploy without GitHub (Actions is the deployment trigger)</li><li>You can&apos;t get approval without GitHub (code review lives there)</li><li>Your commits are essentially &quot;drafts&quot; until they exist on GitHub</li></ul><p>This means the following is also true:</p><ul><li>You never work disconnected intentionally</li><li>You don&apos;t use local branches as long-lived divergent histories</li><li>You don&apos;t merge locally between branches (GitHub PRs handle this)</li><li>You don&apos;t use <code>git log</code> for archaeology &#x2014; you use GitHub&apos;s blame/history UI (I often use git log personally but I have determined I&apos;m in the minority on this). </li></ul><p>Almost all the features of <code>git</code> are wasted on me in this flow. Now because this tool serves a million purposes and is designed to operate in a way that almost nobody uses it for, we all pay the complexity price of <code>git</code> and never reap any of the benefits. So instead I keep having to add more aliases to paper over the shortcomings of <code>git</code>. </p><p>These are all the aliases I use at least once a week. </p><pre><code>[alias]\n  up = pull --rebase --autostash\n  l = log --pretty=oneline -n 20 --graph --abbrev-commit\n  # View the current working tree status using the short format\n  s = status -s\n  p = !&quot;git pull; git submodule foreach git pull origin master&quot;\n  ca = !git add -A &amp;&amp; git commit -av\n  # Switch to a branch, creating it if necessary\n  go = &quot;!f() { git checkout -b \\&quot;$1\\&quot; 2&gt; /dev/null || git checkout \\&quot;$1\\&quot;; }; f&quot;\n  # Show verbose output about tags, branches or remotes\n  tags = tag -l\n  branches = branch -a\n  remotes = remote -v\n  dm = &quot;!git branch --merged | grep -v &apos;\\\\*&apos; | xargs -n 1 git branch -d&quot;\n  contributors = shortlog --summary --numbered\n  st = status\n  primary = &quot;!f() { \\\n    git branch -a | \\\n    sed -n -E -e &apos;/remotes.origin.ma(in|ster)$/s@remotes/origin/@@p&apos;; \\\n  }; f&quot;\n  # Switch to main or master, whichever exists, and update it.\n  ma = &quot;!f() { \\\n    git checkout $(git primary) &amp;&amp; \\\n    git pull; \\\n  }; f&quot;\n  mma = &quot;!f() { \\\n    git ma &amp;&amp; \\\n    git pull upstream $(git primary) --ff-only &amp;&amp; \\\n    git push; \\\n  }; f&quot;</code></pre><h3 id="enter-gitbutler-cli">Enter GitButler CLI</h3><p><strong>Git&apos;s offline-first design creates friction for online-first workflows, and GitButler CLI eliminates that friction by being honest about how we actually work.</strong></p><p>(Edit: I forgot to add this disclaimer. I am not, nor have ever been an employee/investor/best friends with anyone from GitButler. They don&apos;t care that I&apos;ve written this and I didn&apos;t communicate with anyone from that team before I wrote this.)</p><p>So let&apos;s take the most basic command as an example. This is my flow that I do 2-3 times a day without my aliases. </p><pre><code>git checkout main\ngit pull\ngit checkout -b my-feature\n# or if you&apos;re already on a branch:\ngit pull --rebase --autostash \ngit status</code></pre><p>I do this because <code>git</code> can&apos;t make assumptions about the state of the world. </p><ul><li>Your local repo might be offline for days or weeks</li><li>The &quot;remote&quot; might be someone else&apos;s laptop, not a central server</li><li>Divergent histories are expected and merging is a deliberate, considered act</li></ul><p>However because GitButler is designed with the assumption that I&apos;m working online, we can skip a lot of this nonsense. </p><figure class="kg-card kg-image-card"><img alt="alt" class="kg-image" height="488" src="https://matduggan.com/content/images/2026/02/image-8.png" width="1586" /></figure><p>It&apos;s status command understands that there is always a remote main that I care about and that when I run a status that I need to understand my status <em>relative</em> to the remote main as it exists right now. Not how it existed the last time I remembered to pull. </p><p>However this is far from the best trick it has up its sleeve. </p><h2 id="parallel-branches-the-problem-git-cant-solve"><strong>Parallel Branches: The Problem Git Can&apos;t Solve</strong></h2><p>You&apos;re working on a feature, notice an unrelated bug, and now you have to stash, checkout, fix, commit, push, checkout back, stash pop. Context switching is expensive and error-prone. </p><p>GitButler effectively hacks a solution into <code>git</code> that fixes this with multiple branches applied simultaneously. Assign files to different branches without leaving your workspace. What do I mean by that. Let&apos;s start again with my status </p><figure class="kg-card kg-image-card"><img alt="alt" class="kg-image" height="482" src="https://matduggan.com/content/images/2026/02/image-9.png" width="1582" /></figure><p>Great looks good. Alright so lets say I make 2 new branches. I&apos;m working on a new feature for adding auth and while I&apos;m working on that, I see a typo I need to fix in a YAML. </p><figure class="kg-card kg-image-card"><img alt="alt" class="kg-image" height="912" src="https://matduggan.com/content/images/2026/02/image-10.png" width="1586" /></figure><p>I can work on both things at the same time:</p><pre><code>but stage istar_metrics_text.py feature-auth\nbut stage example.txt bugfix-typo</code></pre><figure class="kg-card kg-image-card"><img alt="alt" class="kg-image" height="804" src="https://matduggan.com/content/images/2026/02/image-11.png" width="1590" /></figure><p>And easily commit to both at the same time without doing <em>anything weird</em>. </p><figure class="kg-card kg-image-card"><img alt="alt" class="kg-image" height="946" src="https://matduggan.com/content/images/2026/02/image-12.png" width="1588" /></figure><h3 id="stacked-prs-without-the-rebase-nightmare">Stacked PRs Without the Rebase Nightmare</h3><p>Stacked PRs are the &quot;right&quot; way to break up large changes so people on your team don&apos;t throw up at being asked to review 2000 lines, but Git makes them miserable. When the base branch gets feedback, you have to rebase every dependent branch, resolve conflicts, force-push, and pray. Git doesn&apos;t understand branch dependencies. It treats every branch as independent, so <em>you</em> have to manually maintain the stack.</p><p>GitButler solves this problem with First-class stacked branches. The dependency is explicit, and updates propagate automatically.</p><p>So what do I mean. Let&apos;s say I make a new API endpoint in some Django app. First I make the branch. </p><pre><code>but branch new api-endpoints\n# Then add my stuff to it\nbut commit -m &quot;add REST endpoints&quot; api-endpoints\n# Create a stacked branch on top\nbut branch new --anchor api-endpoints api-tests\n</code></pre><figure class="kg-card kg-image-card"><img alt="alt" class="kg-image" height="216" src="https://matduggan.com/content/images/2026/02/image-14.png" width="630" /></figure><p>So let&apos;s say I&apos;m working on the <code>api-endpoints</code> branch and get some good feedback on my PR. It&apos;s easy to resolve the comments there while leaving my <code>api-tests</code> branched off this <code>api-endpoints</code> as a stacked thing that understands the relationship back to the first branch as shown here. </p><figure class="kg-card kg-image-card"><img alt="alt" class="kg-image" height="276" src="https://matduggan.com/content/images/2026/02/image-15.png" width="762" /></figure><p>In practice this is just a much nicer way of dealing with a super common workflow. </p><h3 id="easy-undo">Easy Undo</h3><p>Maybe the most requested feature from new <code>git</code> users I encounter is an easier undo. When you mess up in Git, recovery means diving into <code>git reflog</code>, understanding the cryptic output, and hoping you pick the right <code>HEAD@{n}</code>. One wrong move and you&apos;ve made it worse.</p><p>GitButlers <code>oplog</code> is just easier to use. So the basic undo functionality is super simple to understand. </p><figure class="kg-card kg-image-card"><img alt="alt" class="kg-image" height="388" src="https://matduggan.com/content/images/2026/02/image-16.png" width="896" /></figure><p><code>but undo</code> rolls me back one operation. </p><figure class="kg-card kg-image-card"><img alt="alt" class="kg-image" height="558" src="https://matduggan.com/content/images/2026/02/image-17.png" width="1104" /></figure><p>To me the mental model of a snapshot makes a lot more sense than the git history model. I do an action, I want to undo that action. This is better than the git option of:</p><pre><code>git log --oneline                 # figure out what you committed\ngit reset --soft HEAD~1           # undo commit, keep changes staged\ngit stash                         # stash the changes\ngit checkout correct-branch       # switch branches\ngit stash pop                     # restore changes (hope no conflict)\ngit add .                         # re-stage\ngit commit -m &quot;message&quot;           # recommit</code></pre><h3 id="very-exciting-tool">Very exciting tool</h3><p>I&apos;ve been using GitButler in my daily work since I got the email that the CLI was available and I&apos;ve really loved it. I&apos;m a huge fan of what this team is doing to effectively remodel and simplify Git operations in a world where almost nobody is using it in the way the tool was originally imagined to be used. I strongly encourage folks go check it out for free at: <a href="https://docs.gitbutler.com/cli-guides/cli-tutorial/tutorial-overview">https://docs.gitbutler.com/cli-guides/cli-tutorial/tutorial-overview</a>. It does a ton of things (like help you manage PRs) that I didn&apos;t even touch on here. </p><p>Let me know if you find something cool that I forgot at: <a href="https://c.im/@matdevdug">https://c.im/@matdevdug</a></p>'}

---

*抓取时间: 2026-02-10 00:04:12*
