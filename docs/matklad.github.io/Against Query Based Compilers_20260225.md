# Against Query Based Compilers

**Êù•Ê∫ê:** [matklad.github.io](https://matklad.github.io)
**ÂèëÂ∏ÉÊó∂Èó¥:** 2026-02-25T00:00:00+00:00
**ÈìæÊé•:** https://matklad.github.io/2026/02/25/against-query-based-compilers.html

---

{'type': 'text/html', 'language': None, 'base': 'https://matklad.github.io/2026/02/25/against-query-based-compilers.html', 'value': '<header>\n  <h1>Against Query Based Compilers</h1>\n  <time class="meta" datetime="2026-02-25">Feb 25, 2026</time>\n</header>\n<p><a href="https://thunderseethe.dev/posts/compiler-education-deserves-a-revoluation/">Query based compilers are all the rage</a>\nthese days, so it feels only appropriate to chart some treacherous shoals in those waters.</p>\n<p>A query-based compiler is a straightforward application of the idea of incremental computations to,\nyou guessed it, compiling. A compiler is just a simple text transformation program, implemented as a\nlot of functions. You could visualize a <em>run</em> of a compiler on a particular input source code as a\ngraph of function calls:</p>\n\n<figure>\n\n<img alt="" src="https://matklad.github.io/assets/2026-02-25-against-query-based-compilers/1.svg" />\n</figure>\n<p>Here, schematically, squares are inputs like file text or compiler‚Äôs command line arguments, <code>g</code> is\nan intermediate function (e.g, type checking), which is called twice, with different arguments, and\n<code>f</code> and <code>h</code> are top-level functions (compile executable, or compute completions for LSP).</p>\n<p>Looking at this picture, it‚Äôs obvious how to make our compiler ‚Äúincremental‚Äù ‚Äî if an input changes,\nit‚Äôs enough to re-compute only the results on path from the changed input to the root ‚Äúquery‚Äù:</p>\n\n<figure>\n\n<img alt="" src="https://matklad.github.io/assets/2026-02-25-against-query-based-compilers/2.svg" />\n</figure>\n<p>A little more thinking, and you can derive ‚Äúearly cutoff‚Äù optimization:</p>\n\n<figure>\n\n<img alt="" src="https://matklad.github.io/assets/2026-02-25-against-query-based-compilers/3.svg" />\n</figure>\n<p>If an input to the function changes, but its result doesn‚Äôt (e.g, function type is not affected by\nwhitespace change), you can stop change propagation early.</p>\n<p>And that‚Äôs ‚Ä¶ basically it. The beauty of the scheme is its silvery-bullety hue ‚Äî it can be\napplied without thinking to any computation, and, with a touch of meta programming, you won‚Äôt even\nhave to change code of the compiler significantly.</p>\n<p><a href="https://simon.peytonjones.org/assets/pdfs/build-systems-jfp.pdf"><em>Build Systems √† la Carte</em></a> is the\ncanonical paper to read here. In a build system, a query is an opaque process whose inputs and\noutputs are file. In a query-based compiler, queries are just functions.</p>\n<hr />\n<p>The reason why we want this in the first place is incremental compilation ‚Äî in IDE context\nspecifically, the compiler needs to react to a stream of tiny edits, and its time budget is about\n100ms. Big-O thinking is useful here: the time to react to the change should be proportional to the\nsize of the change, and not the overall size of the codebase. O(1) change leads to O(1) update\nof the O(N) codebase.</p>\n<p>Similar big-O thinking also demonstrates the principal limitation of the scheme ‚Äî the update work\ncan‚Äôt be smaller than the change in the result.</p>\n<p>An example. Suppose our ‚Äúcompiler‚Äù makes a phrase upper-case:</p>\n\n<figure class="code-block">\n\n\n<pre><code><span class="line">compile(&quot;hello world&quot;) == &quot;HELLO WORLD&quot;</span></code></pre>\n\n</figure>\n<p>This is easy to incrementalize, as changing a few letters in the input changes only a few letters in\nthe output:</p>\n\n<figure class="code-block">\n\n\n<pre><code><span class="line">compile(&quot;hallo world&quot;) == &quot;HALLO WORLD&quot;</span></code></pre>\n\n</figure>\n<p>But suppose now our ‚Äúcompiler‚Äù is a hashing or encryption function:</p>\n\n<figure class="code-block">\n\n\n<pre><code><span class="line">compile(&quot;hello world&quot;) == &quot;a948904f2f0&quot;</span>\n<span class="line">compile(&quot;hallo world&quot;) == &quot;a7336983eca&quot;</span></code></pre>\n\n</figure>\n<p>This is provably impossible to make usefully incremental. The encryption <em>can</em> be implemented\nas a graph of function calls, and you <em>can</em> apply the general incremental recipe to it. It just\nwon‚Äôt be very fast.</p>\n<p>The reason for that is the avalanche property ‚Äî for good encryption, a change in any bit of input\nshould flip roughly half of the bits of the output. So just the work of changing the output\n(completely ignoring the work to compute what needs to be changed) is O(N), not O(1).</p>\n\n<figure class="blockquote">\n<blockquote><p>The effectiveness of query-based compiler is limited by\nthe dependency structure of the source language.</p>\n</blockquote>\n\n</figure>\n<p>A particularly nasty effect here is that even if you have only <em>potential</em> avalanche, where a\ncertain kind of change <em>could</em> affect large fraction of the output, even if it usually doesn‚Äôt, your\nincremental engine likely will spend some CPU time or memory to confirm the absence of dependency.</p>\n<hr />\n<p>In my</p>\n<p><span class="display"><a href="https://rust-analyzer.github.io/blog/2020/07/20/three-architectures-for-responsive-ide.html"><em>Three Architectures For Responsive IDE</em></a>,</span>\nquery-based compilation is presented as a third, fall-back option. I still think that that‚Äôs\nbasically true: as a language designer, I think it‚Äôs worth listening to your inner\n<a href="https://grugbrain.dev">Grug</a> and push the need for queries as far down the compilation pipeline as\npossible, sticking to more direct approaches. <em>Not</em> doing queries is simpler, faster, and simpler to\nmake faster (profiling a query-based compiler is a special genre of hurdle racing).</p>\n<p>Zig and Rust provide for a nice comparison. In Zig, every file can be parsed completely in\nisolation, so compilation starts by parsing all files independently and in parallel. Because in Zig\nevery name needs to be explicitly declared (there‚Äôs no <code>use *</code>), name resolution also can run on a\nper-file basis, without queries. Zig goes even further, and directly converts untyped AST into IR,\nemitting a whole bunch of errors in the process (e.g, ‚Äú<code>var</code> doesn‚Äôt need to be mutable‚Äù). See\n<span class="display"><a href="https://mitchellh.com/zig/astgen"><em>Zig AstGen: AST =&gt; ZIR</em></a></span>\nfor details. By the time compiler gets to tracked queries, the data it has to work with is already\npretty far from the raw source code, but only because Zig <em>language</em> is carefully designed to allow\nthis.</p>\n<p>In contrast, you can‚Äôt really parse a file in Rust. Rust macros generate new source code, so parsing\ncan‚Äôt be finished until all the macros are expanded. Expanding macros requires name resolution,\nwhich, in Rust, is a crate-wide, rather than a file-wide operation. Its a fundamental property of\nthe language that typing something in <code>a.rs</code> can change parsing results for <code>b.rs</code>, and that forces\nfine-grained dependency tracking and invalidation to the very beginning of the front-end.</p>\n<p>Similarly, the nature of the trait system is such that <code>impl</code> blocks relevant to a particular method\ncall can be found almost anywhere. For every trait method call, you get a dependency on the <code>impl</code>\nblock that supplies the implementation, but you <em>also</em> get a dependency on non-existence of\nconflicting <code>impl</code>s in every other file!</p>\n<p>Again, refer to the\n<a href="https://rust-analyzer.github.io/blog/2020/07/20/three-architectures-for-responsive-ide.html"><em>Three Architectures</em></a>\nfor positive ideas, but the general trick is to leverage language semantics to manually cut the\ncompilation tasks into somewhat coarse-grained chunks which are independent by definition (of the\nsource language). Grug builds an incremental map-reduce compiler for his language:</p>\n<ul>\n<li>\n<p>Recursive directory walk finds all files to be compiled.</p>\n</li>\n<li>\n<p>In parallel, independently, each file is parsed, name-resolved, and lowered. As much as possible,\nlanguage features (and errors) are syntax driven and not type driven, and can be processed at this\nstage.</p>\n</li>\n<li>\n<p>In parallel, a ‚Äúsummary‚Äù is extracted from each file, which is essentially just a list of types\nand signatures, with function bodies empty.</p>\n</li>\n<li>\n<p>Sequentially, a ‚Äúsignature evaluation‚Äù phase is run on this set of summaries, which turns type\nreferences in signatures into actual types, dealing with mutual dependencies between files. This\nphase is re-run whenever a summary of a file changes. Conversely, changes to the body of any\nfunction do not invalidate resolved signatures.</p>\n</li>\n<li>\n<p>In parallel, every function‚Äôs body is type-checked, and lowered to type-and-layout resolved IR,\napplying function-local optimizations.</p>\n</li>\n<li>\n<p>Sequentially, a thin-lto style set of analyses are run on compiled functions, making inlining\ndecisions and computing call-graph dependent attributes like function purity.</p>\n</li>\n<li>\n<p>In parallel, each function is codegened to machine code with unresolved references to other\nfunctions (relocations).</p>\n</li>\n<li>\n<p>Sequentially, functions are concatenated into an executable file, receiving an address.</p>\n</li>\n<li>\n<p>In parallel, all relocations are resolved to now known addresses.</p>\n</li>\n</ul>\n<p>The above scheme works only if the language has a property that changing the body of function <code>foo</code>\n(not touching its signature) can‚Äôt introduce type errors into an unrelated function <code>bar</code>.</p>\n<hr />\n<p>Another trick that becomes less available if you blindly apply queries are in-place updates.\nConsider a language with package declarations and fully qualified names, like Kotlin:</p>\n\n<figure class="code-block">\n\n\n<pre><code><span class="line"><span class="hl-keyword">package</span> org.example</span>\n<span class="line"></span>\n<span class="line"><span class="hl-function"><span class="hl-keyword">fun</span> <span class="hl-title">printMessage</span><span class="hl-params">()</span></span> { <span class="hl-comment">/*...*/</span> }</span>\n<span class="line"><span class="hl-keyword">class</span> <span class="hl-title class_">Message</span> { <span class="hl-comment">/*...*/</span> }</span></code></pre>\n\n</figure>\n<p>A compiler for this language probably wants to maintain a map of all public declarations, where the\nkeys are fully qualified names, and values are declarations themselves. If you approach the problem\nof computing this map with query eyes, you might have a base per-file query that returns a map of\nfile‚Äôs declarations, and then a recursive per-directory query. And you‚Äôll probably have some kind of\nstructural sharing of the maps, such that changing a single file updates only the ‚Äúspine‚Äù, without\nactually copying most of the other entries.</p>\n<p>But there‚Äôs a more direct way to make this sort of structure responsive to changes. You need only\ntwo ‚Äúqueries‚Äù ‚Äî per file, and global. When a file changes, you look at the <em>previous</em> version of\nthe map for this file, compute a diff of added or removed declarations, and then apply this diff to\nthe global map.</p>\n<p>Zig is planning to use a similar approach to incrementalize linking ‚Äî rather than producing a new\nbinary gluing mostly unchanged chunks of machine code, the idea is to in-place patch the previous\nbinary.</p>\n<hr />\n<p>If you like this article, you might be interested in some other adjacent stuff I‚Äôve written over the\nyears, roughly in the order of importance:</p>\n<ul>\n<li>\n<a href="https://rust-analyzer.github.io/blog/2020/07/20/three-architectures-for-responsive-ide.html">Three Architectures for a Responsive IDE</a>\n</li>\n<li>\n<a href="https://rust-analyzer.github.io/blog/2023/07/24/durable-incrementality.html">Durable Incrementality</a>\n</li>\n<li>\n<a href="https://matklad.github.io/2023/05/06/zig-language-server-and-cancellation.html">Zig Language Server And Cancellation</a>\n</li>\n<li>\n<a href="https://matklad.github.io/2023/05/21/resilient-ll-parsing-tutorial.html">Resilient LL Parsing Tutorial</a>\n</li>\n<li>\n<a href="https://rust-analyzer.github.io/blog/2019/11/13/find-usages.html">Find Usages</a>\n</li>\n<li>\n<a href="https://rust-analyzer.github.io/blog/2023/12/26/the-heart-of-a-language-server.html">The Heart of a Language Server</a>\n</li>\n<li>\n<a href="https://rust-analyzer.github.io/blog/2020/09/28/how-to-make-a-light-bulb.html">How to Make a üí°?</a>\n</li>\n<li>\n<a href="https://matklad.github.io/2023/10/12/lsp-could-have-been-better.html">LSP could have been better</a>\n</li>\n<li>\n<a href="https://matklad.github.io/2023/08/01/on-modularity-of-lexical-analysis.html">On Modularity of Lexical Analysis</a>\n</li>\n<li>\n<a href="https://matklad.github.io/2020/11/11/yde.html">Why an IDE?</a>\n</li>\n</ul>'}

---

*ÊäìÂèñÊó∂Èó¥: 2026-02-27 02:38:52*
