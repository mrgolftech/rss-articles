# Diagnostics Factory

**来源:** [matklad.github.io](https://matklad.github.io)
**发布时间:** 2026-02-16T00:00:00+00:00
**链接:** https://matklad.github.io/2026/02/16/diagnostics-factory.html

---

{'type': 'text/html', 'language': None, 'base': 'https://matklad.github.io/2026/02/16/diagnostics-factory.html', 'value': '<header>\n  <h1>Diagnostics Factory</h1>\n  <time class="meta" datetime="2026-02-16">Feb 16, 2026</time>\n</header>\n<p>In\n<span class="display"><a href="https://matklad.github.io/2025/11/06/error-codes-for-control-flow.html"><em>Error Codes For Control Flow</em></a>,</span>\nI explained that Zig’s strongly-typed error codes solve the “handling” half of error management,\nleaving “reporting” to the users. Today, I want to describe my personal default approach to\nthe reporting problem, that is, showing the user a useful error message.</p>\n<p>The approach is best described in the negative: <em>avoid</em> thinking about error payloads, and what\nthe type of error should be. Instead, provide a set of functions for constructing errors.</p>\n<p>To give a concrete example, in TigerBeetle’s\n<a href="https://github.com/tigerbeetle/tigerbeetle/blob/0.16.73/src/tidy.zig#L54-L188"><code>tidy.zig</code></a>\n(a project-specific linting script, another useful meta-pattern), we define errors as follows:</p>\n\n<figure class="code-block">\n\n\n<pre><code><span class="line"><span class="hl-keyword">const</span> Errors = <span class="hl-keyword">struct</span> {</span>\n<span class="line">    <span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span><span class="hl-function"> add_long_line</span>(</span>\n<span class="line">        errors: <span class="hl-operator">*</span>Errors,</span>\n<span class="line">        file: SourceFile,</span>\n<span class="line">        line_index: <span class="hl-type">usize</span>,</span>\n<span class="line">    ) <span class="hl-type">void</span> { ... }</span>\n<span class="line"></span>\n<span class="line">    <span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span><span class="hl-function"> add_banned</span>(</span>\n<span class="line">        errors: <span class="hl-operator">*</span>Errors,</span>\n<span class="line">        file: SourceFile,</span>\n<span class="line">        offset: <span class="hl-type">usize</span>,</span>\n<span class="line">        banned_item: []<span class="hl-keyword">const</span> <span class="hl-type">u8</span>,</span>\n<span class="line">        replacement: []<span class="hl-keyword">const</span> <span class="hl-type">u8</span>,</span>\n<span class="line">    ) <span class="hl-type">void</span> { ... }</span>\n<span class="line"></span>\n<span class="line">    <span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span><span class="hl-function"> add_dead_declaration</span>(...) <span class="hl-type">void</span> { ... }</span>\n<span class="line"></span>\n<span class="line">    ...</span>\n<span class="line">};</span></code></pre>\n\n</figure>\n<p>and the call-site looks like this:</p>\n\n<figure class="code-block">\n\n\n<pre><code><span class="line"><span class="hl-keyword">fn</span><span class="hl-function"> tidy_file</span>(file: SourceFile, errors: <span class="hl-operator">*</span>Errors) <span class="hl-type">void</span> {</span>\n<span class="line">    <span class="hl-comment">// ...</span></span>\n<span class="line">    <span class="hl-keyword">var</span> line_index: <span class="hl-type">usize</span> = <span class="hl-numbers">0</span>;</span>\n<span class="line">    <span class="hl-keyword">while</span> (lines.next()) <span class="hl-operator">|</span>line<span class="hl-operator">|</span> : (line_index <span class="hl-operator">+=</span> <span class="hl-numbers">1</span>) {</span>\n<span class="line">        <span class="hl-keyword">const</span> line_length = line_length(line);</span>\n<span class="line">        <span class="hl-keyword">if</span> (line_length &gt; <span class="hl-numbers">100</span> <span class="hl-keyword">and</span> <span class="hl-operator">!</span>contains_url(line)) {</span>\n<span class="line">            errors.add_long_line(file, line_index);</span>\n<span class="line">        }</span>\n<span class="line">    }</span>\n<span class="line">}</span></code></pre>\n\n</figure>\n<p>In this case, I collect multiple errors so I don’t return right away. Fail fast would look like\nthis:</p>\n\n<figure class="code-block">\n\n\n<pre><code><span class="line">errors.add_long_line(file, line_index);</span>\n<span class="line"><span class="hl-keyword">return</span> <span class="hl-keyword">error</span>.Tidy;</span></code></pre>\n\n</figure>\n<p>Note that the error code is intentionally independent of the specific error produced.</p>\n<hr />\n<p>Some interesting properties of the solution:</p>\n<ul>\n<li>\nThe error representation is a set of constructor functions, the calling code doesn’t care what\n<em>actually</em> happens inside. This is why the error factory is my <em>default</em> solution — I don’t have\nto figure out up-front what I’ll do with the errors, and I can change my mind later.\n</li>\n<li>\nThere’s a natural place to convert information from the form available at the place where we emit\nthe error to a form useful for the user. In <code>add_banned</code> above, the caller passes in a absolute\noffset in a file, and it is resolved to line number and column inside (tip: use <code>line_index</code> for\n0-based internal indexes, and <code>line_number</code> for user-visible 1-based ones). Contrast this with a\ntraditional error as sum-type approach, where there’s a sharp syntactic discontinuity between\nconstructing a variant directly and calling a helper function.\n</li>\n<li>\nThis syntactic uniformity in turn allows easily grepping for all error locations:\n<span class="display"><code>rg \'errors.add_\'</code>.</span>\n</li>\n<li>\nSimilarly, there’s one central place that enumerates all possible errors (which is either a\nbenefit or a drawback).\n</li>\n</ul>\n<p>A less trivial property is that this structure enables polymorphism. In fact, in the <code>tidy.zig</code>\ncode, there are two different representations of errors. When running the script, errors are\ndirectly emitted to stderr. But when testing it, errors are collected into an in-memory buffer:</p>\n\n<figure class="code-block">\n\n\n<pre><code><span class="line"><span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span><span class="hl-function"> add_banned</span>(</span>\n<span class="line">    errors: <span class="hl-operator">*</span>Errors,</span>\n<span class="line">    file: SourceFile,</span>\n<span class="line">    offset: <span class="hl-type">usize</span>,</span>\n<span class="line">    banned_item: []<span class="hl-keyword">const</span> <span class="hl-type">u8</span>,</span>\n<span class="line">    replacement: []<span class="hl-keyword">const</span> <span class="hl-type">u8</span>,</span>\n<span class="line">) <span class="hl-type">void</span> {</span>\n<span class="line">    errors.emit(</span>\n<span class="line">        <span class="hl-string">&quot;{s}:{d}: error: {s} is banned, use {s}<span class="hl-string">\\n</span>&quot;</span>,</span>\n<span class="line">        .{</span>\n<span class="line">            file.path, file.line_number(offset),</span>\n<span class="line">            banned_item, replacement,</span>\n<span class="line">        },</span>\n<span class="line">    );</span>\n<span class="line">}</span>\n<span class="line"></span>\n<span class="line"><span class="hl-keyword">fn</span><span class="hl-function"> emit</span>(</span>\n<span class="line">    errors: <span class="hl-operator">*</span>Errors,</span>\n<span class="line">    <span class="hl-keyword">comptime</span> fmt: []<span class="hl-keyword">const</span> <span class="hl-type">u8</span>,</span>\n<span class="line">    args: <span class="hl-type">anytype</span>,</span>\n<span class="line">) <span class="hl-type">void</span> {</span>\n<span class="line">    <span class="hl-keyword">comptime</span> assert(fmt[fmt.len <span class="hl-operator">-</span> <span class="hl-numbers">1</span>] <span class="hl-operator">==</span> <span class="hl-string">&#x27;<span class="hl-string">\\n</span>&#x27;</span>);</span>\n<span class="line">    errors.count <span class="hl-operator">+=</span> <span class="hl-numbers">1</span>;</span>\n<span class="line">    <span class="hl-keyword">if</span> (errors.captured) <span class="hl-operator">|</span><span class="hl-operator">*</span>captured<span class="hl-operator">|</span> {</span>\n<span class="line">        captured.writer(errors.gpa).print(fmt, args)</span>\n<span class="line">            <span class="hl-keyword">catch</span> <span class="hl-built_in">@panic</span>(<span class="hl-string">&quot;OOM&quot;</span>);</span>\n<span class="line">    } <span class="hl-keyword">else</span> {</span>\n<span class="line">        std.debug.print(fmt, args);</span>\n<span class="line">    }</span>\n<span class="line">}</span></code></pre>\n\n</figure>\n<p>There isn’t a giant <code>union(enum)</code> of all errors, because it’s not needed for the present use-case.</p>\n<p>This pattern can be further extended to a full-fledged diagnostics framework with error builders,\nspans, ANSI colors and such, but that is tangential to the main idea here: even when “programming in\nthe small”, it might be a good idea to avoid constructing enums directly, and mandate an\nintermediate function call.</p>\n<hr />\n<p>Two more meta observations here:</p>\n<p><em>First</em>, the entire pattern is of course the expression of duality between a sum of two types and a\nproduct of two functions (the visitor pattern)</p>\n\n<figure class="code-block">\n\n\n<pre><code><span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">foo</span>() <span class="hl-punctuation">-&gt;</span> <span class="hl-type">Result</span>&lt;T, E&gt;;</span>\n<span class="line"></span>\n<span class="line"><span class="hl-keyword">fn</span> <span class="hl-title function_">bar</span>(ok: <span class="hl-keyword">impl</span> <span class="hl-title class_">FnOnce</span>(T), err: <span class="hl-keyword">impl</span> <span class="hl-title class_">FnOnce</span>(E));</span></code></pre>\n\n</figure>\n\n<figure class="code-block">\n\n\n<pre><code><span class="line"><span class="hl-keyword">enum</span> <span class="hl-title class_">Result</span>&lt;T, E&gt; {</span>\n<span class="line">    <span class="hl-title function_ invoke__">Ok</span>(T),</span>\n<span class="line">    <span class="hl-title function_ invoke__">Err</span>(E),</span>\n<span class="line">}</span>\n<span class="line"></span>\n<span class="line"><span class="hl-keyword">trait</span> <span class="hl-title class_">Result</span>&lt;T, E&gt; {</span>\n<span class="line">    <span class="hl-keyword">fn</span> <span class="hl-title function_">ok</span>(<span class="hl-keyword">self</span>, T);</span>\n<span class="line">    <span class="hl-keyword">fn</span> <span class="hl-title function_">err</span>(<span class="hl-keyword">self</span>, E);</span>\n<span class="line">}</span></code></pre>\n\n</figure>\n<p><em>Second</em>, every abstraction is a thin film separating two large bodies of code. Any interface has\ntwo sides, the familiar one presented to the user, and the other, hidden one, presented to the\nimplementor. Often, default language machinery pushes you towards using the same construct for both\nbut that can be suboptimal. It’s natural for the user and the provider of the abstraction to\ndisagree on the optimal interface, and to evolve independently. Using a single big enum for errors\ncouples error emitting and error reporting code, as they have to meet in the middle. In contrast,\nthe factory solution is optimal for producer (they literally just pass whatever they already have on\nhand, without any extra massaging of data), and is flexible for consumer(s).</p>'}

---

*抓取时间: 2026-02-18 18:04:21*
