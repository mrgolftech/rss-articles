# Justifying text-wrap: pretty

**来源:** [matklad.github.io](https://matklad.github.io)
**发布时间:** 2026-02-14T00:00:00+00:00
**链接:** https://matklad.github.io/2026/02/14/justifying-text-wrap-pretty.html

---

{'type': 'text/html', 'language': None, 'base': 'https://matklad.github.io/2026/02/14/justifying-text-wrap-pretty.html', 'value': '<header>\n  <h1>Justifying text-wrap: pretty</h1>\n  <time class="meta" datetime="2026-02-14">Feb 14, 2026</time>\n</header>\n\n<p>Something truly monumental happened in the world of software development in 2025. Safari shipped a\nreasonable implementation of <code>text-wrap: pretty</code>:\n<span class="display"><a class="url" href="https://webkit.org/blog/16547/better-typography-with-text-wrap-pretty/">https://webkit.org/blog/16547/better-typography-with-text-wrap-pretty/</a>.</span> We are getting\ncloser and closer to the cutting-edge XV-century technology. Beautiful paragraphs!</p>\n\n<figure>\n\n<img alt="Gutenberg bible Old Testament Epistle of St Jerome" height="2877" src="https://upload.wikimedia.org/wikipedia/commons/2/27/Gutenberg_bible_Old_Testament_Epistle_of_St_Jerome.jpg" width="2009" />\n</figure>\n<p>We are not quite there yet, hence the present bug report.</p>\n<hr />\n<p>A naive way to break text into lines to form a paragraph of a given width is greediness: add the\nnext word to the current line if it fits, otherwise start a new line. The result is unlikely to be\npretty — sometimes it makes sense to try to squeeze one more word on a line to make the lines more\nbalanced overall. Johannes Gutenberg did this sort of thing manually, to produce a beautiful page\nabove. In 1981, Knuth and Plass figured out a way to teach computer to do this, using dynamic\nprogramming, for line breaking in TeX.</p>\n<p>Inexplicably, until 2025, browsers stuck with the naive greedy algorithm, subjecting generations of\nweb users to ugly typography. To be fair, the problem in a browser is harder version than the one\nsolved by Gutenberg, Plass, and Knuth. In print, the size of the page is fixed, so you can compute\noptimal line breaking once, offline. In the web context, the window width is arbitrary and even\nchanges dynamically, so the line-breaking has to be “online”. On the other hand, XXI century\nbrowsers have a bit more compute resources than we had in 1980 or even 1450!</p>\n<hr />\n<p>Making lines approximately equal in terms of number of characters is only half-way through towards a\nbeautiful paragraph. No matter how you try, the length won’t be exactly the same, so, if you want\nboth the left and the right edges of the page to be aligned, you also need to fudge the spaces\nbetween the words a bit. In CSS,\n<span class="display"><code>text-wrap: pretty</code></span>\nasks the browser to select line breaks in an intelligent way to make lines roughly equal, and\n<span class="display"><code>text-align: justify</code></span>\nadjusts whitespace to make them equal exactly.</p>\n<p>Although Safari is the first browser to ship a non-joke implementation of <code>text-wrap</code>, the\ncombination with <code>text-align</code> looks ugly, as you can see in this very blog post. To pin the ugliness\ndown, the whitespace between the words is blown out of proportion. Here’s the same justified\nparagraph with and without <code>text-wrap: pretty</code>:</p>\n<figure class="two-col">\n    <img alt="" height="202" src="https://github.com/user-attachments/assets/adf77eec-9e33-4900-b761-23a604892b2f" style="border: 1px solid black;" width="375" />\n    <img alt="" height="202" src="https://github.com/user-attachments/assets/75a7e7a8-0d34-448a-877c-4368567fe598" style="border: 1px solid black;" width="375" />\n</figure>\n<p>The paragraph happens to look ok with greedy line-breaking. But the “smart” algorithm decides to add\nan entire line to it, which requires inflating all the white space proportionally. By itself, either\nof</p>\n\n<figure class="code-block">\n\n\n<pre><code><span class="line"><span class="hl-selector-tag">p</span> {</span>\n<span class="line">    text-wrap: pretty;</span>\n<span class="line">    <span class="hl-attribute">text-align</span>: justify;</span>\n<span class="line">}</span></code></pre>\n\n</figure>\n<p>looks alright. It’s just the combination of the two that is broken.</p>\n<hr />\n<p>This behavior is a natural consequence of implementation. My understanding is that the dynamic\nprogramming scoring function aims to get each line close to the target width, and is penalized for\ndeviations. Crucially, the actual max width of a paragraph is fixed: while a line can be arbitrary\nshorter, it can’t be any longer, otherwise it’ll overflow. For this reason, the dynamic programming\nsets the target width to be a touch narrower than the paragraph. That way, it’s possible to both\nunder and overshoot, leading to better balance overall. As per\n<a href="https://webkit.org/blog/16547/better-typography-with-text-wrap-pretty/#:~:text=And%20here’s%20how%20the%20same%20text%20looks">original article</a>:</p>\n\n<figure class="blockquote">\n<blockquote><p>The browser aims to wrap each line sooner than the maximum limit of the text box. It wraps\nwithin the range, definitely after the magenta line, and definitely before the red line.</p>\n\n<figure>\n\n<img alt="" height="1099" src="https://webkit.org/wp-content/uploads/demo-2-light.png" width="1728" />\n</figure>\n</blockquote>\n\n</figure>\n<p>But if you subsequently justify all the way to the red line, the systematic overshoot will manifest\nitself as too wide inter-word space!</p>\n<p>WebKit devs, you are awesome for shipping this feature ahead of everyone else, please fix this small\nwrinkle such that I can make my blog look the way I had intended all along ;-)</p>'}

---

*抓取时间: 2026-02-18 18:04:21*
