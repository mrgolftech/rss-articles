# An AI agent coding skeptic tries AI agent coding, in excessive detail

**来源:** [minimaxir.com](https://minimaxir.com)
**发布时间:** Fri, 27 Feb 2026 10:00:00 -0800
**链接:** https://minimaxir.com/2026/02/ai-agent-coding/

---

{'type': 'text/html', 'language': None, 'base': 'https://minimaxir.com/index.xml', 'value': '<p><span></span></p>\n<p>You&rsquo;ve likely seen many blog posts about AI agent coding/<a href="https://en.wikipedia.org/wiki/Vibe_coding">vibecoding</a> where the author talks about all the wonderful things agents can now do supported by vague anecdata, how agents will lead to the atrophy of programming skills, how agents impugn the sovereignty of the human soul, etc etc. This is <strong>NOT</strong> one of those posts. You&rsquo;ve been warned.</p>\n<p>Last May, I wrote a blog post titled <a href="https://minimaxir.com/2025/05/llm-use/">As an Experienced LLM User, I Actually Don&rsquo;t Use Generative LLMs Often</a> as a contrasting response to the hype around the rising popularity of agentic coding. In that post, I noted that while LLMs are most definitely not useless and they can answer simple coding questions faster than it would take for me to write it myself with sufficient accuracy, agents are a tougher sell: they are unpredictable, expensive, and the hype around it was wildly disproportionate given the results I had seen in personal usage. However, I concluded that I was open to agents if LLMs improved enough such that all my concerns were addressed and agents were more dependable.</p>\n<p>In the months since, I continued my real-life work as a Data Scientist while keeping up-to-date on the latest LLMs popping up on <a href="https://openrouter.ai">OpenRouter</a>. In August, Google <a href="https://developers.googleblog.com/introducing-gemini-2-5-flash-image/">announced</a> the release of their Nano Banana generative image AI with a <a href="https://ai.google.dev/gemini-api/docs/image-generation">corresponding API</a> that&rsquo;s difficult to use, so I open-sourced the <a href="https://github.com/minimaxir/gemimg">gemimg Python package</a> that serves as an API wrapper. It&rsquo;s not a thrilling project: there&rsquo;s little room or need for creative implementation and my satisfaction with it was the net present value with what it enabled rather than writing the tool itself. Therefore as an experiment, I plopped the feature-complete code into various up-and-coming LLMs on OpenRouter and prompted the models to identify and fix any issues with the Python code: if it failed, it&rsquo;s a good test for the current capabilities of LLMs, if it succeeded, then it&rsquo;s a software quality increase for potential users of the package and I have no moral objection to it. The LLMs actually were helpful: in addition to adding good function docstrings and type hints, it identified more Pythonic implementations of various code blocks.</p>\n<p>Around this time, my coworkers were pushing <a href="https://github.com/features/copilot">GitHub Copilot</a> within <a href="https://code.visualstudio.com">Visual Studio Code</a> as a coding aid, particularly around then-new <a href="https://www.anthropic.com/news/claude-sonnet-4-5">Claude Sonnet 4.5</a>. For my data science work, Sonnet 4.5 in Copilot was not helpful and tended to create overly verbose Jupyter Notebooks so I was not impressed. However, in November, Google then <a href="https://blog.google/innovation-and-ai/products/nano-banana-pro/">released</a> Nano Banana Pro which necessitated an immediate update to <code>gemimg</code> for compatibility with the model. After experimenting with Nano Banana Pro, I discovered that the model can <a href="https://minimaxir.com/2025/12/nano-banana-pro/#grid">create images with arbitrary grids</a> (e.g. 2x2, 3x2) as an extremely practical workflow, so I quickly <a href="https://github.com/minimaxir/gemimg/issues/15">wrote a spec</a> to implement support and also slice each subimage out of it to save individually. I knew this workflow is relatively simple-but-tedious to implement using <a href="https://pypi.org/project/pillow/">Pillow</a> shenanigans, so I felt safe enough to ask Copilot to <code>Create a grid.py file that implements the Grid class as described in issue #15</code>, and it did just that although with some errors in areas not mentioned in the spec (e.g. mixing row/column order) but they were easily fixed with more specific prompting. Even accounting for handling errors, that&rsquo;s enough of a material productivity gain to be more <em>optimistic</em> of agent capabilities, but not nearly enough to become an AI hypester.</p>\n<p>In November, just a few days before Thanksgiving, Anthropic <a href="https://www.anthropic.com/news/claude-opus-4-5">released Claude Opus 4.5</a> and naturally my coworkers were curious if it was a significant improvement over Sonnet 4.5. It was very suspicious that Anthropic released Opus 4.5 right before a major holiday since companies typically do that in order to bury underwhelming announcements as your prospective users will be too busy gathering with family and friends to notice. Fortunately, I had no friends and no family in San Francisco so I had plenty of bandwidth to test the new Opus.</p>\n<h2 id="a-foreword-on-agentsmd">A Foreword on AGENTS.md</h2>\n<p>One aspect of agents I hadn&rsquo;t researched but knew was necessary to getting good results from agents was the concept of the <a href="https://agents.md">AGENTS.md</a> file: a file which can control specific behaviors of the agents such as code formatting. If the file is present in the project root, the agent will automatically read the file and in theory obey all the rules within. This is analogous to system prompts for normal LLM calls and if you&rsquo;ve been following my writing, I have an unhealthy addiction to highly nuanced system prompts with additional shenanigans such as ALL CAPS for increased adherence to more important rules (yes, that&rsquo;s still effective). I could not find a good starting point for a Python-oriented <code>AGENTS.md</code> I liked, so I asked Opus 4.5 to make one:</p>\n<div class="highlight"><pre class="chroma" tabindex="0"><code class="language-md"><span class="line"><span class="cl">Add an <span class="sb">`AGENTS.md`</span> file oriented for good Python code quality. It should be intricately details. More important rules should use caps, e.g. <span class="sb">`MUST`</span>\n</span></span></code></pre></div><p>I then added a few more personal preferences and suggested tools from my previous failures working with agents in Python: use <code>uv</code> and <code>.venv</code> instead of the base Python installation, use <code>polars</code> instead of <code>pandas</code> for data manipulation, only store secrets/API keys/passwords in <code>.env</code> while ensuring <code>.env</code> is in <code>.gitignore</code>, etc. Most of these constraints don&rsquo;t tell the agent what to do, but <em>how</em> to do it. In general, adding a rule to my <code>AGENTS.md</code> whenever I encounter a fundamental behavior I don&rsquo;t like has been very effective. For example, agents love using unnecessary emoji which I hate, so I added a rule:</p>\n<div class="highlight"><pre class="chroma" tabindex="0"><code class="language-md"><span class="line"><span class="cl">**NEVER** use emoji, or unicode that emulates emoji (e.g. ✓, ✗).\n</span></span></code></pre></div><p>Agents also tend to leave a lot of redundant code comments, so I added another rule to prevent that:</p>\n<div class="highlight"><pre class="chroma" tabindex="0"><code class="language-md"><span class="line"><span class="cl">**MUST** avoid including redundant comments which are tautological or self-demonstating (e.g. cases where it is easily parsable what the code does at a glance or its function name giving sufficient information as to what the code does, so the comment does nothing other than waste user time)\n</span></span></code></pre></div><p>My up-to-date <code>AGENTS.md</code> file for Python is available <a href="https://gist.github.com/minimaxir/10b780671ee5d695b4369b987413b38f">here</a>, and throughout my time working with Opus, it adheres to every rule despite the file&rsquo;s length, and in the instances where I accidentally query an agent without having an <code>AGENTS.md</code>, it&rsquo;s <em>very</em> evident. It would not surprise me if the file is the main differentiator between those getting good and bad results with agents, although success is <a href="https://news.ycombinator.com/item?id=47034087">often mixed</a>.</p>\n<p>As a side note if you are using <a href="https://code.claude.com/docs/en/overview">Claude Code</a>, the file must be named <code>CLAUDE.md</code> instead because Anthropic is weird; this blog post will just use <code>AGENTS.md</code> for consistency.</p>\n<h2 id="opus-first-contact">Opus First Contact</h2>\n<p>With my <code>AGENTS.md</code> file set up, I did more research into proper methods of prompting agents to see if I was missing something that led to the poor performance from working with Sonnet 4.5.</p>\n<figure>\n\n    \n\n    <img alt="From the Claude Code quickstart." src="https://minimaxir.com/claude_docs.png" /> <figcaption>\n            <p>From the <a href="https://code.claude.com/docs/en/quickstart">Claude Code quickstart</a>.</p>\n        </figcaption>\n</figure>\n\n<p>Anthropic&rsquo;s prompt suggestions are simple, but you can&rsquo;t give an LLM an open-ended question like that and expect the results <em>you</em> want! You, the user, are likely subconsciously picky, and there are always functional requirements that the agent won&rsquo;t magically apply because it cannot read minds and behaves as a <a href="https://tvtropes.org/pmwiki/pmwiki.php/Main/LiteralGenie">literal genie</a>. My approach to prompting is to write the potentially-very-large individual prompt in its own Markdown file (which can be tracked in <code>git</code>), then tag the agent with that prompt and tell it to implement that Markdown file. Once the work is completed and manually reviewed, I manually commit the work to <code>git</code>, with the message referencing the specific prompt file so I have good internal tracking.</p>\n<figure>\n\n    \n\n    <img src="https://minimaxir.com/implement.png" /> \n</figure>\n\n<p>I completely ignored Anthropic&rsquo;s advice and wrote a more elaborate test prompt based on a use case I&rsquo;m familiar with and therefore can audit the agent&rsquo;s code quality. In 2021, I wrote a script to <a href="https://github.com/minimaxir/youtube-video-scraper">scrape YouTube video metadata</a> from videos on a given channel using <a href="https://developers.google.com/youtube/v3">YouTube&rsquo;s Data API</a>, but the API is poorly and counterintuitively documented and my Python scripts aren&rsquo;t great. I subscribe to the <a href="https://www.youtube.com/channel/UC9ecwl3FTG66jIKA9JRDtmg">SiIvagunner YouTube account</a> which, as a part of the channel&rsquo;s gimmick (<a href="https://www.youtube.com/watch?v=rEcOzjg7vBU">musical swaps</a> with different melodies than the ones expected), posts hundreds of videos per month with nondescript thumbnails and titles, making it nonobvious which videos are the best other than the view counts. The video metadata could be used to surface good videos I missed, so I had a fun idea to test Opus 4.5:</p>\n<div class="highlight"><pre class="chroma" tabindex="0"><code class="language-md"><span class="line"><span class="cl">Create a robust Python script that, given a YouTube Channel ID, can scrape the YouTube Data API and store all video metadata in a SQLite database. The YOUTUBE_API_KEY is present in <span class="sb">`.env`</span>.\n</span></span><span class="line"><span class="cl">\n</span></span><span class="line"><span class="cl">Documentation on the channel endpoint: https://developers.google.com/youtube/v3/guides/implementation/channels\n</span></span><span class="line"><span class="cl">\n</span></span><span class="line"><span class="cl">The test channel ID to scrape is: <span class="sb">`UC9ecwl3FTG66jIKA9JRDtmg`</span>\n</span></span><span class="line"><span class="cl">\n</span></span><span class="line"><span class="cl">You MUST obey ALL the FOLLOWING rules in your implementation.\n</span></span><span class="line"><span class="cl">\n</span></span><span class="line"><span class="cl"><span class="k">-</span> Do not use the Google Client SDK. Use the REST API with <span class="sb">`httpx`</span>.\n</span></span><span class="line"><span class="cl"><span class="k">-</span> Include sensible aggregate metrics, e.g. number of comments on the video.\n</span></span><span class="line"><span class="cl"><span class="k">-</span> Incude <span class="sb">`channel_id`</span> and <span class="sb">`retrieved_at`</span> in the database schema.\n</span></span></code></pre></div><p>The resulting script is available <a href="https://github.com/minimaxir/youtube_scraper_opus/blob/main/scrape_channel.py">here</a>, and it worked first try to scrape up to 20,000 videos (the max limit). The resulting Python script has very Pythonic code quality following the copious rules provided by the <code>AGENTS.md</code>, and it&rsquo;s more robust than my old script from 2021. It is most definitely not the type of output I encountered with Sonnet 4.5. There was a minor issue however: the logging is implemented naively such that the API key is leaked in the console. I added a rule to <code>AGENTS.md</code> but really this is the YouTube API&rsquo;s fault for <a href="https://developers.google.com/youtube/v3/getting-started#example-1">encouraging API keys as parameters in a GET request</a>.</p>\n<p>I asked a more data-science-oriented followup prompt to test Opus 4.5&rsquo;s skill at data-sciencing:</p>\n<div class="highlight"><pre class="chroma" tabindex="0"><code class="language-md"><span class="line"><span class="cl">Create a Jupyter Notebook that, using <span class="sb">`polars`</span> to process the data, does a thorough exploratory data analysis of data saved in <span class="sb">`youtube_videos.db`</span>, for all columns.\n</span></span><span class="line"><span class="cl">\n</span></span><span class="line"><span class="cl">This analysis should be able to be extended to any arbitrary input <span class="sb">`channel_id`</span>.\n</span></span></code></pre></div><p>The <a href="https://github.com/minimaxir/youtube_scraper_opus/blob/main/eda_youtube.ipynb">resulting Jupyter Notebook</a> is&hellip;indeed thorough. That&rsquo;s on me for specifying &ldquo;for all columns&rdquo;, although it was able to infer the need for temporal analysis (e.g. total monthly video uploads over time) despite not explicitly being mentioned in the prompt.</p>\n<p>The monthly analysis gave me an idea: could Opus 4.5 design a small webapp to view the top videos by month? That gives me the opportunity to try another test of how well Opus 4.5 works with less popular frameworks than React or other JavaScript component frameworks that LLMs push by default. Here, I&rsquo;ll try <a href="https://fastapi.tiangolo.com">FastAPI</a>, <a href="https://picocss.com">Pico CSS</a> for the front end (because we don&rsquo;t need a JavaScript framework for this), and <a href="https://htmx.org">HTMX</a> for lightweight client/server interactivity:</p>\n<div class="highlight"><pre class="chroma" tabindex="0"><code class="language-md"><span class="line"><span class="cl">Create a Hacker News-worthy FastAPI application using HTMX for interactivity and PicoCSS for styling to build a YouTube-themed application that leverages <span class="sb">`youtube_videos.db`</span> to create an interactive webpage that shows the top videos for each month, including embedded YouTube videos which can be clicked.\n</span></span></code></pre></div><figure>\n\n    \n\n    <img src="https://minimaxir.com/yt_web_app.webp" /> \n</figure>\n\n<p>The FastAPI webapp <a href="https://github.com/minimaxir/youtube_scraper_opus/blob/main/app.py">Python code</a> is good with logical integration of HTMX routes and partials, but Opus 4.5 had fun with the &ldquo;YouTube-themed&rdquo; aspect of the prompt: the video thumbnail simulates a YouTube thumbnail with video duration that loads an embedded video player when clicked! The full code is open-source <a href="https://github.com/minimaxir/youtube_scraper_opus/">in this GitHub repository</a>.</p>\n<p>All of these tests performed far better than what I expected given my prior poor experiences with agents. Did I gaslight myself by being an agent skeptic? How did a LLM sent to die finally solve my agent problems? Despite the holiday, X and Hacker News were abuzz with similar stories about the massive difference between Sonnet 4.5 and Opus 4.5, so something <em>did</em> change.</p>\n<p>Obviously an API scraper and data viewer alone do not justify an <strong>OPUS 4.5 CHANGES EVERYTHING</strong> declaration on social media, but it&rsquo;s enough to be less cynical and more optimistic about agentic coding. It&rsquo;s an invitation to continue creating more difficult tasks for Opus 4.5 to solve. From this point going forward, I will also switch to the terminal Claude Code, since my pipeline is simple enough and doesn&rsquo;t warrant a UI or other shenanigans.</p>\n<h2 id="getting-rusty-at-coding">Getting Rusty At Coding</h2>\n<p>If you&rsquo;ve spent enough time on programming forums such as Hacker News, you&rsquo;ve probably seen the name &ldquo;Rust&rdquo;, often in the context of snark. <a href="https://rust-lang.org">Rust</a> is a relatively niche compiled programming language that touts two important features: speed, which is evident in <a href="https://www.techempower.com/benchmarks/#section=data-r23">framework benchmarks</a> where it can perform 10x as fast as the fastest Python library, and memory safety enforced at compile time through its ownership and borrowing systems which mitigates many potential problems. For over a decade, the slogan &ldquo;Rewrite it in Rust&rdquo; <a href="https://transitiontech.ca/random/RIIR">became a meme</a> where advocates argued that <em>everything</em> should be rewritten in Rust due to its benefits, including extremely mature software that&rsquo;s infeasible to actually rewrite in a different language. Even the major LLM companies are looking to Rust to eke out as much performance as possible: OpenAI President Greg Brockman <a href="https://x.com/gdb/status/2007228511363444905">recently tweeted</a> &ldquo;rust is a perfect language for agents, given that if it compiles it&rsquo;s ~correct&rdquo; which — albeit that statement is silly at a technical level since code can still be <em>logically</em> incorrect — shows that OpenAI is very interested in Rust, and if they&rsquo;re interested in writing Rust code, they need their LLMs to be able to code well in Rust.</p>\n<p>I myself am not very proficient in Rust. Rust has a famously excellent <a href="https://rust-lang.org/learn/">interactive tutorial</a>, but a persistent issue with Rust is that there are few resources for those with intermediate knowledge: there&rsquo;s little between the tutorial and &ldquo;write an operating system from scratch.&rdquo; That was around 2020 and I decided to wait and see if the ecosystem corrected this point (in 2026 it has not), but I&rsquo;ve kept an eye on Hacker News for all the new Rust blog posts and library crates so that one day I too will be able to write the absolutely highest performing code possible.</p>\n<p>Historically, LLMs have been poor at generating Rust code due to its nicheness relative to Python and JavaScript. Over the years, one of my test cases for evaluating new LLMs was to ask it to write a relatively simple application such as <code>Create a Rust app that can create &quot;word cloud&quot; data visualizations given a long input text.</code> but even without expert Rust knowledge I could tell the outputs were too simple and half-implemented to ever be functional even with additional prompting.</p>\n<p>However, due to modern LLM postraining paradigms, it&rsquo;s entirely possible that newer LLMs are specifically RLHF-trained to write better code in Rust despite its relative scarcity. I ran more experiments with Opus 4.5 and using LLMs in Rust on some fun pet projects, and my results were <em>far</em> better than I expected. Here are four such projects:</p>\n<h3 id="icon-to-image">icon-to-image</h3>\n<p>As someone who primarily works in Python, what first caught my attention about Rust is the <a href="https://pyo3.rs/v0.28.2/">PyO3</a> crate: a crate that allows accessing Rust code through Python with all the speed and memory benefits that entails while the Python end-user is none-the-wiser. My first exposure to <code>pyo3</code> was the fast tokenizers in <a href="https://huggingface.co">Hugging Face</a> <a href="https://github.com/huggingface/tokenizers">tokenizers</a>, but many popular Python libraries now also use this pattern for speed, including <a href="https://github.com/ijl/orjson">orjson</a>, <a href="https://docs.pydantic.dev/latest/">pydantic</a>, and my favorite <a href="https://pola.rs">polars</a>. If agentic LLMs could now write both performant Rust code and leverage the <code>pyo3</code> bridge, that would be <em>extremely</em> useful for myself.</p>\n<p>I decided to start with a very simple project: a project that can take icons from an icon font file such as the ones provided by <a href="https://fontawesome.com">Font Awesome</a> and render them into images at any arbitrary resolution.</p>\n<figure>\n\n    \n\n    <img src="https://minimaxir.com/icons_header.webp" /> \n</figure>\n\n<p>I made <a href="https://github.com/minimaxir/icon-image">this exact project</a> in Python in 2021, and it&rsquo;s very hacky by pulling together several packages and cannot easily be maintained. A better version in Rust with Python bindings is a good way to test Opus 4.5.</p>\n<p>The very first thing I did was create a <code>AGENTS.md</code> for Rust by telling Opus 4.5 to port over the Python rules to Rust semantic equivalents. This worked well enough and had the standard Rust idioms: no <code>.clone()</code> to handle lifetimes poorly, no unnecessary <code>.unwrap()</code>, no <code>unsafe</code> code, etc. Although I am not a Rust expert and cannot speak that the agent-generated code is idiomatic Rust, none of the Rust code demoed in this blog post has traces of bad Rust code smell. Most importantly, the agent is instructed to call <a href="https://doc.rust-lang.org/stable/clippy/">clippy</a> after each major change, which is Rust&rsquo;s famous linter that helps keep the code clean, and Opus is good about implementing suggestions from its warnings. My up-to-date Rust <code>AGENTS.md</code> is available <a href="https://gist.github.com/minimaxir/068ef4137a1b6c1dcefa785349c91728">here</a>.</p>\n<p>With that, I built a gigaprompt to ensure Opus 4.5 accounted for both the original Python implementation and a few new ideas I had, such as <a href="https://en.wikipedia.org/wiki/Supersampling">supersampling</a> to antialias the output.</p>\n<div class="highlight"><pre class="chroma" tabindex="0"><code class="language-md"><span class="line"><span class="cl">Create a Rust/Python package (through <span class="sb">`pyo3`</span> and <span class="sb">`maturin`</span>) that efficiently and super-quickly takes an Icon Font and renders an image based on the specified icon. The icon fonts are present in <span class="sb">`assets`</span>, and the CSS file which maps the icon name to the corresponding reference in the icon font is in <span class="sb">`fontawesome.css`</span>.\n</span></span><span class="line"><span class="cl">\n</span></span><span class="line"><span class="cl">You MUST obey ALL the FOLLOWING implementation notes:\n</span></span><span class="line"><span class="cl">\n</span></span><span class="line"><span class="cl"><span class="k">-</span> If the icon name has <span class="sb">`solid`</span> in it, it is referencing <span class="sb">`fa-solid.otf`</span>.\n</span></span><span class="line"><span class="cl"><span class="k">-</span> <span class="sb">`fa-brands.otf`</span> and <span class="sb">`fa-regular.otf`</span> can be combined.\n</span></span><span class="line"><span class="cl"><span class="k">-</span> The package MUST also support Python (via <span class="sb">`pyo3`</span> and <span class="sb">`maturin`</span>).\n</span></span><span class="line"><span class="cl"><span class="k">-</span> The package MUST be able to output the image rendered as an optimized PNG and WEBP. with a default output resolution of 1024 x 1024.\n</span></span><span class="line"><span class="cl"><span class="k">-</span> The image rendering MUST support supersampling for antialiased text and points (2x by default)\n</span></span><span class="line"><span class="cl"><span class="k">-</span> The package MUST implement <span class="sb">`fontdue`</span> as its text rendering method.\n</span></span><span class="line"><span class="cl"><span class="k">-</span> Allow the user to specify the color of the icon and the color of the background (both hex and RGB)\n</span></span><span class="line"><span class="cl"><span class="k">-</span> Allow transparent backgrounds.\n</span></span><span class="line"><span class="cl"><span class="k">-</span> Allow user to specify the icon size and canvas size separately.\n</span></span><span class="line"><span class="cl"><span class="k">-</span> Allow user to specify the anchor positions (horizontal and vertical) for the icon relative to the canvas (default: center and center)\n</span></span><span class="line"><span class="cl"><span class="k">-</span> Allow users to specify a horizontal and vertical pixel offset for the icon relative to the canvas.\n</span></span><span class="line"><span class="cl">\n</span></span><span class="line"><span class="cl">After your base implementation is complete, you MUST:\n</span></span><span class="line"><span class="cl">\n</span></span><span class="line"><span class="cl"><span class="k">-</span> Write a comprehensive Python test suite using <span class="sb">`pytest`</span>.\n</span></span><span class="line"><span class="cl"><span class="k">-</span> Write a Python Jupyter Notebook\n</span></span><span class="line"><span class="cl"><span class="k">-</span> Optimize the Rust binary file size and the Python package file size.\n</span></span></code></pre></div><p>It completed the assignment in one-shot, accounting for all of the many feature constraints specified. The &ldquo;Python Jupyter Notebook&rdquo; notebook command at the end is how I manually tested whether the <code>pyo3</code> bridge worked, and it indeed worked like a charm. There was one mistake that&rsquo;s my fault however: I naively chose the <a href="https://github.com/mooman219/fontdue">fontdue</a> Rust crate as the renderer because I remember <a href="https://github.com/mooman219/fontdue?tab=readme-ov-file#performance">seeing a benchmark</a> showing it was the fastest at text rendering. However, testing large icon generation exposed a flaw: <code>fontdue</code> achieves its speed by only partially rendering curves, which is a very big problem for icons, so I followed up:</p>\n<div class="highlight"><pre class="chroma" tabindex="0"><code class="language-md"><span class="line"><span class="cl">The generated icons, at a high resolution, show signs of not having curves and instead showing discrete edges (image attached). Investigate the <span class="sb">`fontdue`</span> font renderer to see if there\'s an issue there.\n</span></span><span class="line"><span class="cl">\n</span></span><span class="line"><span class="cl">In the event that it\'s not possible to fix this in <span class="sb">`fontdue`</span>, investigate using <span class="sb">`ab_glyph`</span> instead.\n</span></span></code></pre></div><p>Opus 4.5 used its Web Search tool to confirm the issue is expected with <code>fontdue</code> and implemented <a href="https://crates.io/crates/ab_glyph">ab_glyph</a> instead which did fix the curves.</p>\n<p>icon-to-image is available <a href="https://github.com/minimaxir/icon-to-image">open-source on GitHub</a>. There were around 10 prompts total adding tweaks and polish, but through all of them Opus 4.5 never failed the assignment as written. Of course, generating icon images in Rust-with-Python-bindings is an order of magnitude faster than my old hacky method, and thanks to the better text rendering and supersampling it also looks much better than the Python equivalent.</p>\n<p>There&rsquo;s a secondary pro and con to this pipeline: since the code is compiled, it avoids having to specify as many dependencies in Python itself; in this package&rsquo;s case, Pillow for image manipulation in Python is optional and the Python package won&rsquo;t break if Pillow changes its API. The con is that compiling the Rust code into Python wheels is difficult to automate especially for multiple OS targets: fortunately, GitHub provides <a href="https://docs.github.com/en/actions/concepts/runners/github-hosted-runners">runner VMs</a> for this pipeline and a little bit of back-and-forth with Opus 4.5 created <a href="https://github.com/minimaxir/icon-to-image/blob/main/.github/workflows/release.yml">a GitHub Workflow</a> which runs the build for all target OSes on publish, so there&rsquo;s no extra effort needed on my end.</p>\n<h3 id="word-clouds-in-the-browser">Word Clouds In The Browser</h3>\n<p>When I used word clouds in Rust as my test case for LLM Rust knowledge, I had an ulterior motive: I <em>love</em> word clouds. Back in 2019, I open-sourced a Python package titled <a href="https://github.com/minimaxir/stylecloud">stylecloud</a>: a package built on top of Python&rsquo;s word cloud, but with the added ability to add more color gradients and masks based on icons to easily conform it into shapes (sound familiar?)</p>\n<figure>\n\n    \n\n    <img src="https://minimaxir.com/stylecloud_banner.png" /> \n</figure>\n\n<p>However, stylecloud was hacky and fragile, and a number of features I wanted to add such as non-90-degree word rotation, transparent backgrounds, and SVG output flat-out were not possible to add due to its dependency on Python&rsquo;s <a href="https://github.com/amueller/word_cloud">wordcloud</a>/<a href="https://matplotlib.org">matplotlib</a>, and also the package was really slow. The only way to add the features I wanted was to build something from scratch: Rust fit the bill.</p>\n<p>The pipeline was very similar to <code>icon-to-image</code> above: ask Opus 4.5 to fulfill a long list of constraints with the addition of Python bindings. But there&rsquo;s another thing that I wanted to test that would be extremely useful if it worked: WebAssembly (WASM) output with <a href="https://crates.io/crates/wasm-bindgen">wasm-bindgen</a>. Rust code compiled to WASM allows it to be run in any modern web browser with the speed benefits intact: no dependencies needed, and therefore should be future-proof. However, there&rsquo;s a problem: I would have to design an interface and I am not a front end person, and I say without hyperbole that for me, designing even a simple HTML/CSS/JS front end for a project is more stressful than training an AI. However, Opus 4.5 is able to take general guidelines and get it into something workable: I first told it to use Pico CSS and vanilla JavaScript and that was enough, but then I had an idea to tell it to use <a href="https://ui.shadcn.com">shadcn/ui</a> — a minimalistic design framework normally reserved for Web Components — along with screenshots from that website as examples. That also worked.</p>\n<figure>\n\n    \n\n    <img src="https://minimaxir.com/wordcloud_rust_ui.webp" /> \n</figure>\n\n<p>After more back-and-forth with design nitpicks and more features to add, the package is feature complete. However, it needs some more polish and a more unique design before I can release it, and I got sidetracked by <em>something</em> more impactful&hellip;</p>\n<h3 id="miditui">miditui</h3>\n<p><code>Create a music player in the terminal using Rust</code> was another Rust stress test I gave to LLMs: command line terminals can&rsquo;t play audio, right? Turns out, it can with the <a href="https://crates.io/crates/rodio">rodio</a> crate. Given the success so far with Opus 4.5 I decided to make the tasks more difficult: terminals can play sound, but can it <em>compose</em> sound? So I asked Opus 4.5 to create a MIDI composer and playback DAW within a terminal, which worked. Adding features forced me to learn more about how MIDIs and <a href="https://en.wikipedia.org/wiki/SoundFont">SoundFonts</a> actually work, so it was also educational!</p>\n<figure>\n\n    \n\n    <img src="https://minimaxir.com/miditui.webp" /> \n</figure>\n\n<p>miditui is available <a href="https://github.com/minimaxir/miditui">open-sourced on GitHub</a>, and the prompts used to build it are <a href="https://github.com/minimaxir/miditui/blob/main/agent_notes/PROMPTS.md">here</a>.</p>\n<p>During development I encountered a caveat: Opus 4.5 can&rsquo;t test or view a terminal output, especially one with unusual functional requirements. But despite being blind, it knew enough about the <a href="https://ratatui.rs">ratatui</a> terminal framework to implement whatever UI changes I asked. There were a large number of UI bugs that likely were caused by Opus&rsquo;s inability to create test cases, namely failures to account for scroll offsets resulting in incorrect click locations. As someone who spent 5 years as a <a href="https://en.wikipedia.org/wiki/Black_box">black box</a> Software QA Engineer who was unable to review the underlying code, this situation was my specialty. I put my QA skills to work by messing around with <code>miditui</code>, told Opus any errors with occasionally a screenshot, and it was able to fix them easily. I do not believe that these bugs are inherently due to LLM agents being better or worse than humans as humans are most definitely capable of making the same mistakes. Even though I myself am adept at finding the bugs and offering solutions, I don&rsquo;t believe that I would inherently avoid causing similar bugs were I to code such an interactive app without AI assistance: QA brain is different from software engineering brain.</p>\n<h3 id="ballin">ballin</h3>\n<p>One night — after a glass of wine — I had another idea: one modern trick with <a href="https://en.wikipedia.org/wiki/ASCII_art">ASCII art</a> is the use of <a href="https://www.unicode.org/charts/nameslist/c_2800.html">Braille unicode characters</a> to allow for <a href="https://steamcommunity.com/sharedfiles/filedetails/?id=2807089604">very high detail</a>. That reminded me of ball physics simulations, so what about building a full physics simulator also in the terminal? So I asked Opus 4.5 to create a terminal physics simulator with the <a href="https://rapier.rs">rapier</a> 2D physics engine and a detailed explanation of the Braille character trick: this time Opus did better and completed it in one-shot, so I spent more time making it colorful and <em>fun</em>. I pessimistically thought the engine would only be able to handle a few hundred balls: instead, the Rust codebase can handle over 10,000 logical balls!</p>\n<figure>\n\n    \n\n    <img alt="I explicitly prompted Opus to make the Colors button have a different color for each letter." src="https://minimaxir.com/ballin.webp" /> <figcaption>\n            <p>I explicitly prompted Opus to make the Colors button have a different color for each letter.</p>\n        </figcaption>\n</figure>\n\n<p>ballin is available <a href="https://github.com/minimaxir/ballin">open-sourced on GitHub</a>, and the prompts used to build it are <a href="https://github.com/minimaxir/ballin/blob/main/PROMPTS.md">here</a>.</p>\n<p>The <code>rapier</code> crate also published a blog post highlighting a <a href="https://dimforge.com/blog/2026/01/09/the-year-2025-in-dimforge">major change to its underlying math engine</a>, in its 0.32.0 version so I asked Opus 4.5 to upgrade to that version&hellip;and it caused crashes, yet tracing the errors showed it originated with <code>rapier</code> itself. Upgrading to 0.31.0 was fine with no issues: a consequence of only using agentic coding for this workflow is that I cannot construct a minimal reproducible test case to file as a regression bug report or be able to isolate it as a side effect of a new API not well-known by Opus 4.5.</p>\n<p>The main lesson I learnt from working on these projects is that agents work best when you have <a href="https://www.youtube.com/watch?v=W9_iQ1FSnp8">approximate knowledge of many things</a> with enough domain expertise to know what should and should not work. Opus 4.5 is good enough to let me finally do side projects where I know precisely what I want but not necessarily how to implement it. These specific projects aren&rsquo;t the Next Big Thing™ that justifies the existence of an industry taking billions of dollars in venture capital, but they make my life better and since they are open-sourced, hopefully they make someone else&rsquo;s life better. However, I still wanted to push agents to do more impactful things in an area that might be more worth it.</p>\n<h2 id="its-not-ai-psychosis-if-it-works">It&rsquo;s Not AI Psychosis If It Works</h2>\n<p>Before I wrote my blog post about how I use LLMs, I wrote a tongue-in-cheek blog post titled <a href="https://minimaxir.com/2025/01/write-better-code/">Can LLMs write better code if you keep asking them to “write better code”?</a> which is exactly as the name suggests. It was an experiment to determine how LLMs interpret the ambiguous command &ldquo;write better code&rdquo;: in this case, it was to prioritize making the code more convoluted with more helpful features, but if instead given commands to optimize the code, it did make the code faster successfully albeit at the cost of significant readability. In software engineering, one of the greatest sins is <a href="https://stackify.com/premature-optimization-evil/">premature optimization</a>, where you sacrifice code readability and thus maintainability to chase performance gains that slow down development time and may not be worth it. Buuuuuuut with agentic coding, we implicitly accept that our interpretation of the code is fuzzy: could agents iteratively applying optimizations for the sole purpose of minimizing benchmark runtime — and therefore faster code in typical use cases if said benchmarks are representative — now actually be a good idea? People complain about how AI-generated code is slow, but if AI can now reliably generate <em>fast</em> code, that changes the debate.</p>\n<figure>\n\n    \n\n    <img alt="Multiplication and division are too slow for Opus 4.6." src="https://minimaxir.com/div255.png" /> <figcaption>\n            <p>Multiplication and division are too slow for Opus 4.6.</p>\n        </figcaption>\n</figure>\n\n<p>As a data scientist, I&rsquo;ve been frustrated that there haven&rsquo;t been any impactful new Python data science tools released in the past few years other than <code>polars</code>. Unsurprisingly, research into AI and LLMs has subsumed traditional DS research, where developments such as text embeddings have had <a href="https://minimaxir.com/2025/02/embeddings-parquet/">extremely valuable gains</a> for typical data science natural language processing tasks. The traditional machine learning algorithms are still valuable, but no one has invented <a href="https://developers.google.com/machine-learning/decision-forests/intro-to-gbdt">Gradient Boosted Decision Trees</a> 2: Electric Boogaloo. Additionally, as a data scientist in San Francisco I am legally required to use a MacBook, but there haven&rsquo;t been data science utilities that actually use the GPU in an Apple Silicon MacBook as they don&rsquo;t support its Metal API; data science tooling is exclusively in CUDA for NVIDIA GPUs. What if agents could now port these algorithms to a) run on Rust with Python bindings for its speed benefits and b) run on GPUs without complex dependencies?</p>\n<p>This month, OpenAI announced their <a href="https://openai.com/index/introducing-the-codex-app/">Codex app</a> and my coworkers were asking questions. So I downloaded it, and as a test case for the GPT-5.2-Codex (high) model, I asked it to reimplement the <a href="https://umap-learn.readthedocs.io/en/latest/">UMAP algorithm</a> in Rust. UMAP is a dimensionality reduction technique that can take in a high-dimensional matrix of data and simultaneously cluster and visualize data in lower dimensions. However, it is a very computationally-intensive algorithm and the only tool that can do it quickly is NVIDIA&rsquo;s <a href="https://github.com/rapidsai/cuml">cuML</a> which requires CUDA dependency hell. If I can create a UMAP package in Rust that&rsquo;s superfast with minimal dependencies, that is an <em>massive</em> productivity gain for the type of work I do and can enable fun applications if fast enough.</p>\n<p>After OpenAI <a href="https://openai.com/index/introducing-gpt-5-3-codex/">released</a> GPT-5.3-Codex (high) which performed substantially better and faster at these types of tasks than GPT-5.2-Codex, I asked Codex to write a UMAP implementation from scratch in Rust, which at a glance seemed to work and gave reasonable results. I also instructed it to create benchmarks that test a wide variety of representative input matrix sizes. Rust has a popular benchmarking crate in <a href="https://crates.io/crates/criterion">criterion</a>, which outputs the benchmark results in an easy-to-read format, which, most importantly, agents can easily parse.</p>\n<figure>\n\n    \n\n    <img alt="Example output from criterion." src="https://minimaxir.com/criterion.png" /> <figcaption>\n            <p>Example output from <code>criterion</code>.</p>\n        </figcaption>\n</figure>\n\n<p>At first glance, the benchmarks and their construction looked good (i.e. no cheating) and are much faster than working with UMAP in Python. To further test, I asked the agents to implement additional different useful machine learning algorithms such as HDBSCAN as individual projects, with each repo starting with this 8 prompt plan in sequence:</p>\n<ol>\n<li>Implement the package with the specific functional requirements and design goals; afterwards, create benchmarks with specific matrix sizes that are representative of typical use cases</li>\n<li>Do a second pass to clean up the code/comments and make further optimizations</li>\n<li>Scan the crate to find areas of algorithmic weaknesses in extreme cases, and write a sentence for each describing the problem, the potential solution, and quantifying the impact of the solution</li>\n<li>Leveraging the findings found, optimize the crate such that ALL benchmarks run 60% or quicker (1.4x faster). Use any techniques to do so, and repeat until benchmark performance converges, but don&rsquo;t game the benchmarks by overfitting on the benchmark inputs alone <sup id="fnref:1"><a class="footnote-ref" href="https://minimaxir.com/index.xml#fn:1">1</a></sup></li>\n<li>Create custom tuning profiles that take advantage of the inherent quantities of the input data and CPU thread saturation/scheduling/parallelization to optimize the crate such that ALL benchmarks run 60% or quicker (1.4x faster). You can use the <a href="https://crates.io/crates/flamegraph">flamegraph</a> crate to help with the profiling</li>\n<li>Add Python bindings using <code>pyo3</code> 0.27.2 and <code>maturin</code>, with relevant package-specific constraints (specifying the <code>pyo3</code> version is necessary to ensure compatability with Python 3.10+)</li>\n<li>Create corresponding benchmarks in Python, and write a comparison script between the Python bindings and an existing Python package</li>\n<li>Accuse the agent of potentially cheating its algorithm implementation while pursuing its optimizations, so tell it to optimize for the similarity of outputs against a known good implementation (e.g. for a regression task, minimize the <a href="https://en.wikipedia.org/wiki/Mean_absolute_error">mean absolute error</a> in predictions between the two approaches)</li>\n</ol>\n<p>The simultaneous constraints of code quality requirements via <code>AGENTS.md</code>, speed requirements with a quantifiable target objective, and an output accuracy/quality requirement, all do succeed at finding meaningful speedups consistently (atleast 2x-3x)</p>\n<figure>\n\n    \n\n    <img alt="Codex 5.3 after optimizing a principal component analysis implementation." src="https://minimaxir.com/pca_benchmark_codex.png" /> <figcaption>\n            <p>Codex 5.3 after optimizing a <a href="https://en.wikipedia.org/wiki/Principal_component_analysis">principal component analysis</a> implementation.</p>\n        </figcaption>\n</figure>\n\n<p>I&rsquo;m not content with only 2-3x speedups: nowadays in order for this agentic code to be meaningful and not just another repo on GitHub, it has to be the <em>fastest implementation possible</em>. In a moment of sarcastic curiosity, I tried to see if Codex and Opus had different approaches to optimizing Rust code by chaining them:</p>\n<ol>\n<li>Instruct Codex to optimize benchmarks to 60% of runtime</li>\n<li>Instruct Opus to optimize benchmarks to 60% of runtime</li>\n<li>Instruct Opus to minimize differences between agentic implementation and known good implementation without causing more than a 5% speed regression on any benchmarks</li>\n</ol>\n<p><em>This works</em>. From my tests with the algorithms, Codex can often speed up the algorithm by 1.5x-2x, then Opus somehow speeds up that optimized code <em>again</em> to a greater degree. This has been the case of all the Rust code I&rsquo;ve tested: I also ran the <code>icon-to-image</code> and the word cloud crates through this pipeline and gained 6x cumulative speed increases in both libraries.</p>\n<p>Can these agent-benchmaxxed implementations actually beat the existing machine learning algorithm libraries, despite those libraries already being written in a low-level language such as C/C++/Fortran? Here are the results on my personal MacBook Pro comparing the CPU benchmarks of the Rust implementations of various computationally intensive ML algorithms to their respective popular implementations, where the agentic Rust results are within similarity tolerance with the battle-tested implementations and Python packages are compared against the Python bindings of the agent-coded Rust packages:</p>\n<ul>\n<li>UMAP: 2-10x faster than Rust&rsquo;s <a href="https://crates.io/crates/fast-umap">fast-umap</a>, 9-30x faster than Python&rsquo;s <a href="https://umap-learn.readthedocs.io/en/latest/">umap</a></li>\n<li>HDBSCAN (clustering algorithm): 23-100x faster than the <a href="https://crates.io/crates/hdbscan">hdbscan</a> Rust crate, 3x-10x faster than Python&rsquo;s <a href="https://pypi.org/project/hdbscan/">hdbscan</a></li>\n<li>GBDT (tree-boosting algorithm): 1.1x-1.5x faster fit/predict than the <a href="https://crates.io/crates/treeboost">treeboost</a> Rust crate<sup id="fnref:2"><a class="footnote-ref" href="https://minimaxir.com/index.xml#fn:2">2</a></sup>, 24-42x faster fit/1-5x faster predict than Python&rsquo;s <a href="https://xgboost.readthedocs.io/en/stable/index.html">xgboost</a></li>\n</ul>\n<p>I&rsquo;ll definitely take those results with this unoptimized prompting pipeline! In all cases, the GPU benchmarks are unsurprisingly even better and with <a href="https://crates.io/crates/wgpu">wgpu</a> and added WGSL shaders the code runs on Metal without any additional dependencies, however further testing is needed so I can&rsquo;t report numbers just yet.</p>\n<p>Although I could push these new libraries to GitHub now, machine learning algorithms are understandably a domain which requires extra care and testing. It would be arrogant to port Python&rsquo;s <a href="https://scikit-learn.org/stable/">scikit-learn</a> — the gold standard of data science and machine learning libraries — to Rust with all the features that implies.</p>\n<p>But that&rsquo;s unironically a good idea so I decided to try and do it anyways. With the use of agents, I am now developing <code>rustlearn</code> (extreme placeholder name), a Rust crate that implements not only the fast implementations of the standard machine learning algorithms such as <a href="https://en.wikipedia.org/wiki/Logistic_regression">logistic regression</a> and <a href="https://en.wikipedia.org/wiki/K-means_clustering">k-means clustering</a>, but also includes the fast implementations of the algorithms above: the same three step pipeline I describe above still works even with the more simple algorithms to beat scikit-learn&rsquo;s implementations. This crate can therefore receive Python bindings and even expand to the Web/JavaScript and beyond. This also gives me the oppertunity to add quality-of-life features to resolve grievances I&rsquo;ve had to work around as a data scientist, such as model serialization and native integration with pandas/polars DataFrames. I hope this use case is considered to be more practical and complex than making a ball physics terminal app.</p>\n<p>Many people reading this will call bullshit on the performance improvement metrics, and honestly, fair. I too thought the agents would stumble in hilarious ways trying, but they did not. To demonstrate that I am not bullshitting, I also decided to release a more simple Rust-with-Python-bindings project today: nndex, an in-memory vector &ldquo;store&rdquo; that is designed to retrieve the exact nearest neighbors as fast as possible (and has fast approximate NN too), and is now available <a href="https://github.com/minimaxir/nndex">open-sourced on GitHub</a>. This leverages the <a href="https://en.wikipedia.org/wiki/Dot_product">dot product</a> which is one of the simplest matrix ops and is therefore heavily optimized by existing libraries such as Python&rsquo;s <a href="https://numpy.org">numpy</a>&hellip;and yet after a few optimization passes, it tied <code>numpy</code> even though <code>numpy</code> leverages <a href="https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms">BLAS</a> libraries for maximum mathematical performance. Naturally, I instructed Opus to also add support for BLAS with more optimization passes and it now is 1-5x numpy&rsquo;s speed in the single-query case and much faster with batch prediction. <sup id="fnref:3"><a class="footnote-ref" href="https://minimaxir.com/index.xml#fn:3">3</a></sup> It&rsquo;s so fast that even though I also added GPU support for testing, it&rsquo;s mostly ineffective below 100k rows due to the GPU dispatch overhead being greater than the actual retrieval speed.</p>\n<figure>\n\n    \n\n    <img alt="Comparison of Python nndex to numpy on test workloads.topk_overlap measures result matches (perfect match) and max_similarity_abs_delta measure the largest difference between calculated cosine similarities (effectively zero)." src="https://minimaxir.com/nndex.png" /> <figcaption>\n            <p>Comparison of Python <code>nndex</code> to numpy on test workloads.<code>topk_overlap</code> measures result matches (perfect match) and <code>max_similarity_abs_delta</code> measure the largest difference between calculated cosine similarities (effectively zero).</p>\n        </figcaption>\n</figure>\n\n<p>One of the criticisms about AI generated code is that it &ldquo;just regurgitates everything on GitHub&rdquo; but by construction, if the code is faster than what currently exists, then it can&rsquo;t have been stolen and must be an original approach. Even if the explicit agentic nature of <code>rustlearn</code> makes it risky to adopt downstream, the learnings from how it accomplishes its extreme speed are still valuable.</p>\n<h2 id="the-implications-of-my-agentic-successes">The Implications of My Agentic Successes</h2>\n<p>Like many who have hopped onto the agent train post-Opus 4.5, I&rsquo;ve become nihilistic over the past few months, but not for the typical reasons. I actually am not hitting burnout and I am not worried that my programming skills are decaying due to agents: on the contrary, the session limits intended to stagger server usage have unintentionally caused me to form a habit of coding for fun an hour every day incorporating and implementing new ideas. However, is there a <em>point</em> to me writing this blog post and working on these libraries if people will likely just reply &ldquo;tl;dr AI slop&rdquo; and &ldquo;it&rsquo;s vibecoded so it&rsquo;s automatically bad&rdquo;?</p>\n<p>The real annoying thing about Opus 4.6/Codex 5.3 is that it&rsquo;s impossible to publicly say &ldquo;Opus 4.5 (and the models that came after it) are an order of magnitude better than coding LLMs released just months before it&rdquo; without sounding like an AI hype booster clickbaiting, but it&rsquo;s the counterintuitive truth to my personal frustration. I have been trying to break this damn model by giving it complex tasks that would take me months to do by myself despite my coding pedigree but Opus and Codex keep doing them correctly. On Hacker News I was <a href="https://news.ycombinator.com/item?id=46979055">accused of said clickbaiting</a> when making a similar statement with accusations of &ldquo;I haven&rsquo;t had success with Opus 4.5 so you must be lying.&rdquo; The remedy to this skepticism is to provide more evidence in addition to greater checks and balances, but what can you do if people refuse to believe your evidence?</p>\n<p>A year ago, I was one of those skeptics who was very suspicious of the agentic hype, but I was willing to change my priors in light of new evidence and experiences, which apparently is rare. Generative AI discourse has become too toxic and its discussions always end the same way, so I have been experimenting with touching grass instead, and it is nice. At this point, if I&rsquo;m not confident that I can please anyone with my use of AI, then I&rsquo;ll take solace in just pleasing myself. Continue open sourcing my projects, writing blog posts, and let the pieces fall as they may. If you want to follow along or learn when <code>rustlearn</code> releases, you can follow me <a href="https://bsky.app/profile/minimaxir.bsky.social">on Bluesky</a>.</p>\n<p>Moment of introspection aside, I&rsquo;m not sure what the future holds for agents and generative AI. My use of agents has proven to have significant utility (for myself at the least) and I have more-than-enough high-impact projects in the pipeline to occupy me for a few months. Although certainly I will use LLMs more for coding apps which benefit from this optimization, that doesn&rsquo;t imply I will use LLMs more elsewhere: I still don&rsquo;t use LLMs for writing — in fact I have intentionally made my writing voice more sardonic to specifically fend off AI accusations.</p>\n<p>With respect to Rust, working with agents and seeing how the agents make decisions/diffs has actually helped me break out of the intermediate Rust slog and taught me a lot about the ecosystem by taking on more ambitious projects that required me to research and identify effective tools for modern Rust development. Even though I have <em>technically</em> released Rust packages with many stars on GitHub, I have no intention of putting Rust as a professional skill on my LinkedIn or my résumé. As an aside, how exactly do résumés work in an agentic coding world? Would &ldquo;wrote many open-source libraries through the use of agentic LLMs which increased the throughput of popular data science/machine learning algorithms by an order of magnitude&rdquo; be disqualifying to a prospective employer as they may think I&rsquo;m cheating and faking my expertise?</p>\n<p>My obligation as a professional coder is to do what works best, especially for open source code that other people will use. Agents are another tool in that toolbox with their own pros and cons. If you&rsquo;ve had poor experiences with agents before last November, I strongly urge you to give modern agents another shot, especially with an <code>AGENTS.md</code> tailored to your specific coding domain and nuances (again here are my <a href="https://gist.githubusercontent.com/minimaxir/10b780671ee5d695b4369b987413b38f/raw/f06ad4f1430a8d9f268b160a755dab817384c93c/AGENTS.md">Python</a> and <a href="https://gist.githubusercontent.com/minimaxir/068ef4137a1b6c1dcefa785349c91728/raw/0fa5d1b505338b3a2c6834cc41e728cefe57511b/AGENTS.md">Rust</a> files, in conveient copy/paste format).</p>\n<p>Overall, I&rsquo;m very sad at the state of agentic discourse but also very excited at its promise: it&rsquo;s currently unclear which one is the stronger emotion.</p>\n<div class="footnotes">\n<hr />\n<ol>\n<li id="fn:1">\n<p>Two subtle ways agents can implicitly negatively affect the benchmark results but wouldn&rsquo;t be considered cheating/gaming it are a) implementing a form of caching so the benchmark tests are not independent and b) launching benchmarks in parallel on the same system. I eventually added <code>AGENTS.md</code> rules to ideally prevent both.&#160;<a class="footnote-backref" href="https://minimaxir.com/index.xml#fnref:1">&#x21a9;&#xfe0e;</a></p>\n</li>\n<li id="fn:2">\n<p>The <code>treeboost</code> crate beat the agent-optimized GBT crate by 4x on my first comparison test, which naturally I took offense: I asked Opus 4.6 to &ldquo;Optimize the crate such that <code>rust_gbt</code> wins in ALL benchmarks against <code>treeboost</code>.&rdquo; and it did just that.&#160;<a class="footnote-backref" href="https://minimaxir.com/index.xml#fnref:2">&#x21a9;&#xfe0e;</a></p>\n</li>\n<li id="fn:3">\n<p>Currently, only the macOS build has BLAS support as Win/Linux BLAS support is a rabbit hole that needs more time to investigate. On those platforms, numpy does win, but that won&rsquo;t be the case for long!&#160;<a class="footnote-backref" href="https://minimaxir.com/index.xml#fnref:3">&#x21a9;&#xfe0e;</a></p>\n</li>\n</ol>\n</div>'}

---

*抓取时间: 2026-02-28 06:11:57*
