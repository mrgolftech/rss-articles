# Forge-Specific Repository Folders

**来源:** [nesbitt.io](https://nesbitt.io)
**发布时间:** 2026-02-22T10:00:00+00:00
**链接:** https://nesbitt.io/2026/02/22/forge-specific-repository-folders.html

---

{'type': 'text/html', 'language': None, 'base': 'https://nesbitt.io/2026/02/22/forge-specific-repository-folders.html', 'value': '<p>Git doesn’t know about CI, code review, or issue templates, but every forge that hosts git repositories has added these features through the same trick: a dot-folder in your repo root that the forge reads on push. The folder names differ, the contents overlap in some places and diverge in others, and the portability story between them is worse than you’d expect. A companion to my earlier post on <a href="https://nesbitt.io/2026/02/05/git-magic-files.html">git’s magic files</a>.</p>\n\n<h3 id="github">.github/</h3>\n\n<p>GitHub’s folder holds:</p>\n\n<ul>\n  <li><strong>workflows/</strong> — GitHub Actions CI/CD configuration (<code class="language-plaintext highlighter-rouge">.github/workflows/*.yml</code>)</li>\n  <li><strong>ISSUE_TEMPLATE/</strong> and <strong>PULL_REQUEST_TEMPLATE/</strong> — issue and PR templates</li>\n  <li><strong>dependabot.yml</strong> — automated dependency updates</li>\n  <li><strong>CODEOWNERS</strong> — required reviewers for paths</li>\n  <li><strong>FUNDING.yml</strong> — sponsor button configuration</li>\n</ul>\n\n<p>GitHub also reads some files from the repo root or from <code class="language-plaintext highlighter-rouge">.github/</code>: <strong>SECURITY.md</strong>, <strong>CONTRIBUTING.md</strong>, <strong>CODE_OF_CONDUCT.md</strong>, <strong>LICENSE</strong>.</p>\n\n<p>The <code class="language-plaintext highlighter-rouge">.github/workflows/</code> directory contains YAML files defining Actions workflows. Each file is a separate workflow that runs on events like push, pull request, or schedule.</p>\n\n<p>CODEOWNERS uses <a href="https://nesbitt.io/2026/02/12/the-many-flavors-of-ignore-files.html">gitignore-style</a> glob patterns to map paths to GitHub users or teams who must review changes:</p>\n\n<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># .github/CODEOWNERS\n*.js @frontend-team\n/docs/ @docs-team\n* @admins\n</code></pre></div></div>\n\n<h3 id="gitlab">.gitlab/</h3>\n\n<p>GitLab uses <code class="language-plaintext highlighter-rouge">.gitlab/</code> for:</p>\n\n<ul>\n  <li><strong>ci/</strong> — reusable CI/CD templates</li>\n  <li><strong>merge_request_templates/</strong> — MR templates</li>\n  <li><strong>issue_templates/</strong> — issue templates</li>\n  <li><strong>CODEOWNERS</strong> — approval rules</li>\n  <li><strong>changelog_config.yml</strong> — built-in changelog generation config</li>\n</ul>\n\n<p>GitLab’s main CI config is <code class="language-plaintext highlighter-rouge">.gitlab-ci.yml</code> at the repo root, not in the folder. Projects often keep reusable CI templates in <code class="language-plaintext highlighter-rouge">.gitlab/ci/</code> and pull them in with <code class="language-plaintext highlighter-rouge">include:local</code>, though the directory name is convention rather than something GitLab treats specially.</p>\n\n<p>GitLab’s CODEOWNERS works similarly to GitHub’s but with different approval rule options and integration with GitLab’s approval workflows.</p>\n\n<h3 id="gitea-and-forgejo">.gitea/ and .forgejo/</h3>\n\n<p>Gitea and Forgejo (a fork of Gitea) support:</p>\n\n<ul>\n  <li><strong>workflows/</strong> — Gitea/Forgejo Actions (<code class="language-plaintext highlighter-rouge">.gitea/workflows/*.yml</code> or <code class="language-plaintext highlighter-rouge">.forgejo/workflows/*.yml</code>)</li>\n  <li><strong>ISSUE_TEMPLATE/</strong> and <strong>PULL_REQUEST_TEMPLATE/</strong> — templates</li>\n</ul>\n\n<p>Forgejo checks <code class="language-plaintext highlighter-rouge">.forgejo/</code> then <code class="language-plaintext highlighter-rouge">.gitea/</code> then <code class="language-plaintext highlighter-rouge">.github/</code> in that order, while Gitea checks <code class="language-plaintext highlighter-rouge">.gitea/</code> then <code class="language-plaintext highlighter-rouge">.github/</code>, so you can keep shared config in <code class="language-plaintext highlighter-rouge">.github/</code> and add platform-specific overrides in the forge’s own folder.</p>\n\n<p>Gitea’s CODEOWNERS uses Go regexp instead of gitignore-style globs. Patterns look like <code class="language-plaintext highlighter-rouge">.*\\.js$</code> instead of <code class="language-plaintext highlighter-rouge">*.js</code>.</p>\n\n<h3 id="bitbucket">.bitbucket/</h3>\n\n<p>Bitbucket keeps two files in <code class="language-plaintext highlighter-rouge">.bitbucket/</code>:</p>\n\n<ul>\n  <li><strong>CODEOWNERS</strong> — required reviewers</li>\n  <li><strong>teams.yaml</strong> — ad-hoc reviewer groups</li>\n</ul>\n\n<p>CI config lives at <code class="language-plaintext highlighter-rouge">bitbucket-pipelines.yml</code> in the repo root, similar to GitLab’s approach.</p>\n\n<p>Bitbucket’s CODEOWNERS has reviewer selection strategies baked into the syntax:</p>\n\n<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># .bitbucket/CODEOWNERS\n*.js random(1) @frontend-team\n/api/ least_busy(2) @backend-team\n/critical/ all @security-team\n</code></pre></div></div>\n\n<p><code class="language-plaintext highlighter-rouge">random(1)</code> picks one random reviewer from the team, <code class="language-plaintext highlighter-rouge">least_busy(2)</code> picks the two reviewers with the fewest open PRs, and <code class="language-plaintext highlighter-rouge">all</code> requires every team member to review. No other forge has reviewer selection strategies in the CODEOWNERS syntax.</p>\n\n<p>The <code class="language-plaintext highlighter-rouge">.bitbucket/teams.yaml</code> file lets you define ad-hoc reviewer groups without creating formal Bitbucket teams:</p>\n\n<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># .bitbucket/teams.yaml</span>\n<span class="na">security</span><span class="pi">:</span>\n  <span class="pi">-</span> <span class="s">alice</span>\n  <span class="pi">-</span> <span class="s">bob</span>\n<span class="na">frontend</span><span class="pi">:</span>\n  <span class="pi">-</span> <span class="s">carol</span>\n  <span class="pi">-</span> <span class="s">dave</span>\n</code></pre></div></div>\n\n<p>These can then be referenced in CODEOWNERS with the <code class="language-plaintext highlighter-rouge">@teams/</code> prefix, like <code class="language-plaintext highlighter-rouge">@teams/security</code> or <code class="language-plaintext highlighter-rouge">@teams/frontend</code>.</p>\n\n<h3 id="fallback-chains">Fallback chains</h3>\n\n<p>If you host the same repository on multiple platforms, shared config in <code class="language-plaintext highlighter-rouge">.github/</code> will be picked up by Gitea and Forgejo, with platform-specific overrides in <code class="language-plaintext highlighter-rouge">.gitea/</code> or <code class="language-plaintext highlighter-rouge">.forgejo/</code> taking priority. Bitbucket and GitLab only check their own folders, so multi-platform support across all forges still requires some duplication.</p>\n\n<h3 id="gotchas">Gotchas</h3>\n\n<p>GitHub’s org-level <code class="language-plaintext highlighter-rouge">.github</code> repository lets you set default issue templates, PR templates, and community health files for every repo in the org, but the fallback is all-or-nothing: if a repo has any file in its own <code class="language-plaintext highlighter-rouge">.github/ISSUE_TEMPLATE/</code> folder, none of the org-level templates are inherited and there’s no way to merge them. The org <code class="language-plaintext highlighter-rouge">.github</code> repo must also be public, so your default templates are visible to everyone.</p>\n\n<p>GitHub looks for CODEOWNERS in three places: <code class="language-plaintext highlighter-rouge">.github/CODEOWNERS</code>, then <code class="language-plaintext highlighter-rouge">CODEOWNERS</code> at the root, then <code class="language-plaintext highlighter-rouge">docs/CODEOWNERS</code>. First one found wins and the others are silently ignored. The syntax looks like <code class="language-plaintext highlighter-rouge">.gitignore</code> but <a href="https://docs.github.com/articles/about-code-owners">doesn’t support</a> <code class="language-plaintext highlighter-rouge">!</code> negation, <code class="language-plaintext highlighter-rouge">[]</code> character ranges, or <code class="language-plaintext highlighter-rouge">\\#</code> escaping. A syntax error used to cause the entire file to be silently ignored, meaning no owners were assigned to anything. GitHub has since added error highlighting in the web UI but there’s still no push-time validation.</p>\n\n<p>GitLab supports <a href="https://docs.gitlab.com/user/project/codeowners/advanced/">optional CODEOWNERS sections</a> with a <code class="language-plaintext highlighter-rouge">^</code> prefix, but “optional” only applies to merge requests. If someone pushes directly to a protected branch, the docs say approval from those sections is “still required,” though how that actually works for a command-line push is <a href="https://forum.gitlab.com/t/optional-codeowners-what-does-approval-required-if-pushing-directly-to-protected-branch-mean/107795">unclear even to GitLab users</a>.</p>\n\n<p>The Gitea/Forgejo workflow fallback is all-or-nothing too: if <code class="language-plaintext highlighter-rouge">.gitea/workflows/</code> contains any workflow files, <code class="language-plaintext highlighter-rouge">.github/workflows/</code> is <a href="https://github.com/go-gitea/gitea/issues/31456">completely ignored</a>, so you can’t run platform-specific workflows side by side.</p>\n\n<p>Gitea’s CODEOWNERS doesn’t check <code class="language-plaintext highlighter-rouge">.github/CODEOWNERS</code> at all, only <code class="language-plaintext highlighter-rouge">./CODEOWNERS</code>, <code class="language-plaintext highlighter-rouge">./docs/CODEOWNERS</code>, and <code class="language-plaintext highlighter-rouge">.gitea/CODEOWNERS</code>. If you migrate from GitHub with your CODEOWNERS in <code class="language-plaintext highlighter-rouge">.github/</code>, it silently does nothing. And even when it works, CODEOWNERS on Gitea <a href="https://github.com/go-gitea/gitea/issues/32602">isn’t enforceable</a>: it adds reviewers but there’s no branch protection option to require their approval. Anyone with write access can approve. CODEOWNERS also <a href="https://github.com/go-gitea/gitea/pull/30476">didn’t apply to fork PRs</a> until Gitea 1.21.11.</p>\n\n<p>Forgejo and Gitea both inherited the <code class="language-plaintext highlighter-rouge">pull_request_target</code> trigger from GitHub Actions compatibility, which means they also inherited the “<a href="https://securitylab.github.com/resources/github-actions-preventing-pwn-requests/">pwn request</a>” attack surface where a fork’s code runs with the base repo’s secrets. Forgejo added a trust-based approval system for fork PRs, but <code class="language-plaintext highlighter-rouge">pull_request_target</code> workflows still run with write tokens.</p>\n\n<p><a href="https://www.cvedetails.com/cve/CVE-2025-68937/">CVE-2025-68937</a> is a symlink-following vulnerability in <code class="language-plaintext highlighter-rouge">.gitea/template</code> and <code class="language-plaintext highlighter-rouge">.forgejo/template</code> files. An attacker creates a template repository with symlinks pointing at sensitive paths like the git user’s <code class="language-plaintext highlighter-rouge">authorized_keys</code>, and when someone creates a new repo from that template, the symlinks get dereferenced during template expansion, allowing the attacker to write arbitrary files on the server. It affected Gitea since v1.11 and Forgejo through v13.0.1.</p>\n\n<p>Forgejo also fixed a <a href="https://codeberg.org/forgejo/security-announcements/issues/38">cache poisoning vulnerability</a> where PR workflows could write to the shared action cache, letting a malicious PR poison future privileged workflow runs. It’s unclear whether Gitea is affected or fixed this quietly, as they haven’t published a corresponding advisory.</p>\n\n<p>GitHub Actions <a href="https://yossarian.net/til/post/github-actions-is-surprisingly-case-insensitive/">expressions are case-insensitive</a>. <code class="language-plaintext highlighter-rouge">$</code> matches whether the branch is <code class="language-plaintext highlighter-rouge">main</code>, <code class="language-plaintext highlighter-rouge">MAIN</code>, or <code class="language-plaintext highlighter-rouge">mAiN</code>. Context accesses like <code class="language-plaintext highlighter-rouge">secrets.MY_SECRET</code> and <code class="language-plaintext highlighter-rouge">SECRETS.my_secret</code> resolve to the same thing. Git itself is case-sensitive, so if your workflow security depends on branch naming conventions, there’s a mismatch that’s easy to miss.</p>\n\n<hr />\n\n<p>If you know of other forge-specific folders or have corrections, reach out on <a href="https://mastodon.social/@andrewnez">Mastodon</a> or submit a pull request on <a href="https://github.com/andrew/nesbitt.io">GitHub</a>.</p>'}

---

*抓取时间: 2026-02-23 00:07:01*
