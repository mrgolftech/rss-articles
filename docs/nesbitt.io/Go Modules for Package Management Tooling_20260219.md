# Go Modules for Package Management Tooling

**来源:** [nesbitt.io](https://nesbitt.io)
**发布时间:** 2026-02-19T00:00:00+00:00
**链接:** https://nesbitt.io/2026/02/19/go-modules-for-package-management-tooling.html

---

{'type': 'text/html', 'language': None, 'base': 'https://nesbitt.io/2026/02/19/go-modules-for-package-management-tooling.html', 'value': '<p>I’ve been working on a reusable layer for building ecosystem-agnostic package and supply chain tools in Go: fourteen modules under <a href="https://github.com/git-pkgs">git-pkgs</a> covering manifest parsing, registry clients, license normalization, platform translation, vulnerability feeds, and more.</p>\n\n<p>These are rebuilds of libraries I’ve written and used in Ruby for years, some going back to <a href="https://libraries.io">Libraries.io</a> and more recently for <a href="https://ecosyste.ms">Ecosyste.ms</a>, which I wrote about <a href="https://nesbitt.io/2025/12/14/supply-chain-security-tools-for-ruby">previously</a>. I built the Go versions for <a href="https://nesbitt.io/2026/01/24/rewriting-git-pkgs-in-go">git-pkgs</a>, a tool for exploring the dependency history of your repositories that <a href="https://nesbitt.io/2026/01/24/rewriting-git-pkgs-in-go">compiles to a single binary</a> with no runtime dependencies, which matters for a git subcommand that needs to just work on any machine. When I went looking for Go equivalents of my Ruby libraries, most were either abandoned, incomplete, or only covered a single ecosystem, so I rebuilt them.</p>\n\n<h2 id="identification">Identification</h2>\n\n<h3 id="purl"><a href="https://github.com/git-pkgs/purl">purl</a></h3>\n\n<p><a href="https://github.com/package-url/purl-spec">Package URL</a> (now <a href="https://ecma-international.org/publications-and-standards/standards/ecma-427/">ECMA-427</a>) is the standard format for identifying packages across ecosystems. This handles parsing, generation, and type-specific configuration for around 40 ecosystems, including registry URL generation and the reverse: parsing a registry URL back into a PURL.</p>\n\n<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">purl</span><span class="o">.</span><span class="n">Parse</span><span class="p">(</span><span class="s">"pkg:npm/%40babel/core@7.24.0"</span><span class="p">)</span>\n<span class="n">p</span><span class="o">.</span><span class="n">FullName</span><span class="p">()</span>  <span class="c">// "@babel/core"</span>\n\n<span class="n">url</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">p</span><span class="o">.</span><span class="n">RegistryURL</span><span class="p">()</span>  <span class="c">// "https://www.npmjs.com/package/@babel/core"</span>\n\n<span class="c">// Reverse lookup</span>\n<span class="n">p</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">purl</span><span class="o">.</span><span class="n">ParseRegistryURL</span><span class="p">(</span><span class="s">"https://crates.io/crates/serde"</span><span class="p">)</span>\n<span class="n">p</span><span class="o">.</span><span class="n">String</span><span class="p">()</span>  <span class="c">// "pkg:cargo/serde"</span>\n</code></pre></div></div>\n\n<h3 id="vers"><a href="https://github.com/git-pkgs/vers">vers</a></h3>\n\n<p><a href="https://github.com/package-url/vers-spec">VERS</a> is the version range specification that accompanies PURL. Different ecosystems have incompatible range syntaxes: npm uses <code class="language-plaintext highlighter-rouge">^1.2.3</code>, Ruby uses <code class="language-plaintext highlighter-rouge">~&gt; 1.2</code>, Maven uses <code class="language-plaintext highlighter-rouge">[1.0,2.0)</code>. VERS provides one syntax to normalize everything to.</p>\n\n<p>It parses both VERS URIs and native ecosystem syntax, using a mathematical interval model internally to check whether a given version falls within a range:</p>\n\n<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">r</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">vers</span><span class="o">.</span><span class="n">Parse</span><span class="p">(</span><span class="s">"vers:npm/&gt;=1.0.0|&lt;2.0.0"</span><span class="p">)</span>\n<span class="n">r</span><span class="o">.</span><span class="n">Contains</span><span class="p">(</span><span class="s">"1.5.0"</span><span class="p">)</span>  <span class="c">// true</span>\n\n<span class="c">// Native ecosystem syntax works too</span>\n<span class="n">r</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">vers</span><span class="o">.</span><span class="n">ParseNative</span><span class="p">(</span><span class="s">"~&gt; 1.2.3"</span><span class="p">,</span> <span class="s">"gem"</span><span class="p">)</span>\n<span class="n">r</span><span class="o">.</span><span class="n">Contains</span><span class="p">(</span><span class="s">"1.2.5"</span><span class="p">)</span>  <span class="c">// true</span>\n<span class="n">r</span><span class="o">.</span><span class="n">Contains</span><span class="p">(</span><span class="s">"1.3.0"</span><span class="p">)</span>  <span class="c">// false</span>\n</code></pre></div></div>\n\n<h3 id="spdx"><a href="https://github.com/git-pkgs/spdx">spdx</a></h3>\n\n<p>Package registries are full of informal license strings like “Apache 2”, “MIT License”, “GPL v3” that need normalizing into valid SPDX identifiers before you can do anything useful with them. This handles that, along with parsing compound expressions with AND/OR operators, checking license compatibility, and categorizing licenses using the scancode-licensedb database (updated weekly).</p>\n\n<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">id</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">spdx</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="s">"Apache 2"</span><span class="p">)</span>  <span class="c">// "Apache-2.0"</span>\n\n<span class="n">expr</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">spdx</span><span class="o">.</span><span class="n">Parse</span><span class="p">(</span><span class="s">"Apache 2 OR MIT License"</span><span class="p">)</span>\n<span class="n">expr</span><span class="o">.</span><span class="n">String</span><span class="p">()</span>  <span class="c">// "Apache-2.0 OR MIT"</span>\n\n<span class="n">spdx</span><span class="o">.</span><span class="n">Satisfies</span><span class="p">(</span><span class="s">"MIT OR Apache-2.0"</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"MIT"</span><span class="p">})</span>  <span class="c">// true</span>\n<span class="n">spdx</span><span class="o">.</span><span class="n">IsPermissive</span><span class="p">(</span><span class="s">"MIT"</span><span class="p">)</span>                               <span class="c">// true</span>\n<span class="n">spdx</span><span class="o">.</span><span class="n">HasCopyleft</span><span class="p">(</span><span class="s">"MIT OR GPL-3.0-only"</span><span class="p">)</span>                <span class="c">// true</span>\n</code></pre></div></div>\n\n<h3 id="platforms"><a href="https://github.com/git-pkgs/platforms">platforms</a></h3>\n\n<p>I wrote about <a href="https://nesbitt.io/2026/02/17/platform-strings">platform string fragmentation</a> recently: Go uses <code class="language-plaintext highlighter-rouge">darwin/arm64</code>, Node uses <code class="language-plaintext highlighter-rouge">darwin-arm64</code>, Rust uses <code class="language-plaintext highlighter-rouge">aarch64-apple-darwin</code>, RubyGems uses <code class="language-plaintext highlighter-rouge">arm64-darwin</code>, all for the same chip on the same OS. This translates between 14 ecosystems through a canonical intermediate representation:</p>\n\n<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">platforms</span><span class="o">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">platforms</span><span class="o">.</span><span class="n">Go</span><span class="p">,</span> <span class="s">"darwin/arm64"</span><span class="p">)</span>\n<span class="c">// p.Arch == "aarch64", p.OS == "darwin"</span>\n\n<span class="n">s</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">platforms</span><span class="o">.</span><span class="n">Format</span><span class="p">(</span><span class="n">platforms</span><span class="o">.</span><span class="n">Rust</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>\n<span class="c">// "aarch64-apple-darwin"</span>\n\n<span class="c">// Or translate directly</span>\n<span class="n">s</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">platforms</span><span class="o">.</span><span class="n">Translate</span><span class="p">(</span><span class="n">platforms</span><span class="o">.</span><span class="n">Go</span><span class="p">,</span> <span class="n">platforms</span><span class="o">.</span><span class="n">RubyGems</span><span class="p">,</span> <span class="s">"darwin/arm64"</span><span class="p">)</span>\n<span class="c">// "arm64-darwin"</span>\n</code></pre></div></div>\n\n<h2 id="data-sources">Data sources</h2>\n\n<h3 id="registries"><a href="https://github.com/git-pkgs/registries">registries</a></h3>\n\n<p>Talks to 25 package registry APIs (npm, PyPI, Cargo, RubyGems, Maven, NuGet, Hex, Pub, CocoaPods, Homebrew, and more) and returns normalized package information including versions, dependencies, maintainers, and licenses. Works a lot like the internals of <a href="https://packages.ecosyste.ms">packages.ecosyste.ms</a>, taking PURLs as input so you don’t need to know the quirks of each registry’s API.</p>\n\n<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">(</span>\n    <span class="s">"github.com/git-pkgs/registries"</span>\n    <span class="n">_</span> <span class="s">"github.com/git-pkgs/registries/all"</span>\n<span class="p">)</span>\n\n<span class="n">pkg</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">registries</span><span class="o">.</span><span class="n">FetchPackageFromPURL</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="s">"pkg:cargo/serde"</span><span class="p">,</span> <span class="no">nil</span><span class="p">)</span>\n<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">pkg</span><span class="o">.</span><span class="n">Repository</span><span class="p">)</span>  <span class="c">// "https://github.com/serde-rs/serde"</span>\n<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">pkg</span><span class="o">.</span><span class="n">Licenses</span><span class="p">)</span>    <span class="c">// "MIT OR Apache-2.0"</span>\n\n<span class="c">// Bulk fetch with parallel requests</span>\n<span class="n">packages</span> <span class="o">:=</span> <span class="n">registries</span><span class="o">.</span><span class="n">BulkFetchPackages</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span>\n    <span class="s">"pkg:npm/lodash@4.17.21"</span><span class="p">,</span>\n    <span class="s">"pkg:cargo/serde@1.0.0"</span><span class="p">,</span>\n    <span class="s">"pkg:pypi/requests@2.31.0"</span><span class="p">,</span>\n<span class="p">},</span> <span class="no">nil</span><span class="p">)</span>\n</code></pre></div></div>\n\n<p>Private registries work through PURL qualifiers, and rate-limited APIs get automatic retries with exponential backoff.</p>\n\n<h3 id="forges"><a href="https://github.com/git-pkgs/forges">forges</a></h3>\n\n<p>Fetches repository metadata from GitHub, GitLab, Gitea, Forgejo, and Bitbucket, normalizing it into a common structure similar to how <a href="https://repos.ecosyste.ms">repos.ecosyste.ms</a> works under the hood. Point it at a self-hosted domain and it’ll probe the API to figure out which forge software is running:</p>\n\n<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">client</span> <span class="o">:=</span> <span class="n">forges</span><span class="o">.</span><span class="n">NewClient</span><span class="p">(</span>\n    <span class="n">forges</span><span class="o">.</span><span class="n">WithToken</span><span class="p">(</span><span class="s">"github.com"</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">Getenv</span><span class="p">(</span><span class="s">"GITHUB_TOKEN"</span><span class="p">)),</span>\n<span class="p">)</span>\n\n<span class="n">repo</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">client</span><span class="o">.</span><span class="n">FetchRepository</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="s">"https://github.com/octocat/hello-world"</span><span class="p">)</span>\n<span class="n">repo</span><span class="o">.</span><span class="n">License</span>          <span class="c">// "MIT"</span>\n<span class="n">repo</span><span class="o">.</span><span class="n">StargazersCount</span>  <span class="c">// 12345</span>\n\n<span class="c">// Auto-detect forge type for self-hosted instances</span>\n<span class="n">client</span><span class="o">.</span><span class="n">RegisterDomain</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="s">"git.example.com"</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span>\n</code></pre></div></div>\n\n<h3 id="enrichment"><a href="https://github.com/git-pkgs/enrichment">enrichment</a></h3>\n\n<p>Where <code class="language-plaintext highlighter-rouge">registries</code> talks to one registry at a time, <code class="language-plaintext highlighter-rouge">enrichment</code> routes requests across four data sources: <a href="https://ecosyste.ms">ecosyste.ms</a>, <a href="https://deps.dev">deps.dev</a>, <a href="https://securityscorecards.dev">OpenSSF Scorecard</a>, and direct registry queries via the <code class="language-plaintext highlighter-rouge">registries</code> module. PURLs with a <code class="language-plaintext highlighter-rouge">repository_url</code> qualifier go directly to custom registries, others go through ecosyste.ms or deps.dev, and each result records which source it came from.</p>\n\n<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">client</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">enrichment</span><span class="o">.</span><span class="n">NewClient</span><span class="p">()</span>\n\n<span class="n">results</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">client</span><span class="o">.</span><span class="n">BulkLookup</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span>\n    <span class="s">"pkg:npm/lodash"</span><span class="p">,</span>\n    <span class="s">"pkg:pypi/requests"</span><span class="p">,</span>\n<span class="p">})</span>\n\n<span class="n">info</span> <span class="o">:=</span> <span class="n">results</span><span class="p">[</span><span class="s">"pkg:npm/lodash"</span><span class="p">]</span>\n<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">LatestVersion</span><span class="p">)</span>  <span class="c">// "4.17.21"</span>\n<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">License</span><span class="p">)</span>        <span class="c">// "MIT"</span>\n<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">Source</span><span class="p">)</span>         <span class="c">// "ecosystems", "registries", or "depsdev"</span>\n\n<span class="c">// Scorecard is a separate client for repo-level security scores</span>\n<span class="n">sc</span> <span class="o">:=</span> <span class="n">scorecard</span><span class="o">.</span><span class="n">New</span><span class="p">()</span>\n<span class="n">result</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">sc</span><span class="o">.</span><span class="n">GetScore</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="s">"github.com/lodash/lodash"</span><span class="p">)</span>\n<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">Score</span><span class="p">)</span>  <span class="c">// 6.8</span>\n</code></pre></div></div>\n\n<h3 id="vulns"><a href="https://github.com/git-pkgs/vulns">vulns</a></h3>\n\n<p>Seven vulnerability data sources behind one interface: <a href="https://osv.dev">OSV</a>, <a href="https://deps.dev">deps.dev</a>, <a href="https://github.com/advisories">GitHub Security Advisories</a>, <a href="https://nvd.nist.gov">NVD</a>, <a href="https://github.com/anchore/grype">Grype</a>, <a href="https://vulncheck.com">VulnCheck</a>, and <a href="https://vulnerability.circl.lu">Vulnerability-Lookup</a>. Results are normalized to OSV format with built-in CVSS parsing for v2.0 through v4.0:</p>\n\n<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">source</span> <span class="o">:=</span> <span class="n">osv</span><span class="o">.</span><span class="n">New</span><span class="p">()</span>\n\n<span class="n">results</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">source</span><span class="o">.</span><span class="n">Query</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">purl</span><span class="o">.</span><span class="n">MakePURL</span><span class="p">(</span><span class="s">"npm"</span><span class="p">,</span> <span class="s">"lodash"</span><span class="p">,</span> <span class="s">"4.17.20"</span><span class="p">))</span>\n<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">results</span> <span class="p">{</span>\n    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%s: %s (severity: %s)</span><span class="se">\\n</span><span class="s">"</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ID</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">Summary</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">SeverityLevel</span><span class="p">())</span>\n    <span class="k">if</span> <span class="n">fixed</span> <span class="o">:=</span> <span class="n">v</span><span class="o">.</span><span class="n">FixedVersion</span><span class="p">(</span><span class="s">"npm"</span><span class="p">,</span> <span class="s">"lodash"</span><span class="p">);</span> <span class="n">fixed</span> <span class="o">!=</span> <span class="s">""</span> <span class="p">{</span>\n        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"  Fixed in: %s</span><span class="se">\\n</span><span class="s">"</span><span class="p">,</span> <span class="n">fixed</span><span class="p">)</span>\n    <span class="p">}</span>\n<span class="p">}</span>\n</code></pre></div></div>\n\n<p>All sources support batch queries, with limits ranging from 1,000 to 5,000 packages per request depending on the source.</p>\n\n<h2 id="file-handling">File handling</h2>\n\n<h3 id="manifests"><a href="https://github.com/git-pkgs/manifests">manifests</a></h3>\n\n<p>Parses manifest and lockfiles across 40+ ecosystems, auto-detecting file types and extracting dependencies with version constraints, scopes, integrity hashes, and PURLs. It distinguishes between manifests (declared dependencies), lockfiles (resolved versions), and supplements (extra metadata).</p>\n\n<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">content</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">ReadFile</span><span class="p">(</span><span class="s">"package.json"</span><span class="p">)</span>\n<span class="n">result</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">manifests</span><span class="o">.</span><span class="n">Parse</span><span class="p">(</span><span class="s">"package.json"</span><span class="p">,</span> <span class="n">content</span><span class="p">)</span>\n\n<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">Ecosystem</span><span class="p">)</span>  <span class="c">// "npm"</span>\n<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">Kind</span><span class="p">)</span>       <span class="c">// "manifest"</span>\n<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">dep</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">result</span><span class="o">.</span><span class="n">Dependencies</span> <span class="p">{</span>\n    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%s@%s (%s)</span><span class="se">\\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dep</span><span class="o">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">dep</span><span class="o">.</span><span class="n">Version</span><span class="p">,</span> <span class="n">dep</span><span class="o">.</span><span class="n">Scope</span><span class="p">)</span>\n<span class="p">}</span>\n</code></pre></div></div>\n\n<p>Supported formats range from the obvious (package.json, Gemfile.lock, go.mod) to the less common (APKBUILD, PKGBUILD, .rockspec, dub.sdl). Each dependency includes its name, version constraint, scope (runtime, development, test, build, optional), integrity hash when available, and whether it’s a direct or transitive dependency.</p>\n\n<h3 id="resolve"><a href="https://github.com/git-pkgs/resolve">resolve</a></h3>\n\n<p>Where <code class="language-plaintext highlighter-rouge">manifests</code> parses static files, <code class="language-plaintext highlighter-rouge">resolve</code> parses the runtime output of package manager CLI commands (<code class="language-plaintext highlighter-rouge">npm ls --json</code>, <code class="language-plaintext highlighter-rouge">go mod graph</code>, <code class="language-plaintext highlighter-rouge">uv tree</code>, etc.) into a normalized dependency graph with PURLs. It supports 24+ managers and preserves tree structure when the manager provides it:</p>\n\n<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">(</span>\n    <span class="s">"github.com/git-pkgs/resolve"</span>\n    <span class="n">_</span> <span class="s">"github.com/git-pkgs/resolve/parsers"</span>\n<span class="p">)</span>\n\n<span class="n">output</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">exec</span><span class="o">.</span><span class="n">Command</span><span class="p">(</span><span class="s">"npm"</span><span class="p">,</span> <span class="s">"ls"</span><span class="p">,</span> <span class="s">"--json"</span><span class="p">,</span> <span class="s">"--long"</span><span class="p">)</span><span class="o">.</span><span class="n">Output</span><span class="p">()</span>\n<span class="n">result</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">resolve</span><span class="o">.</span><span class="n">Parse</span><span class="p">(</span><span class="s">"npm"</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>\n\n<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">dep</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">result</span><span class="o">.</span><span class="n">Direct</span> <span class="p">{</span>\n    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%s@%s (%s)</span><span class="se">\\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dep</span><span class="o">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">dep</span><span class="o">.</span><span class="n">Version</span><span class="p">,</span> <span class="n">dep</span><span class="o">.</span><span class="n">PURL</span><span class="p">)</span>\n    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">transitive</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">dep</span><span class="o">.</span><span class="n">Deps</span> <span class="p">{</span>\n        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"  %s@%s</span><span class="se">\\n</span><span class="s">"</span><span class="p">,</span> <span class="n">transitive</span><span class="o">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">transitive</span><span class="o">.</span><span class="n">Version</span><span class="p">)</span>\n    <span class="p">}</span>\n<span class="p">}</span>\n</code></pre></div></div>\n\n<h3 id="archives"><a href="https://github.com/git-pkgs/archives">archives</a></h3>\n\n<p>Reads and browses archive files entirely in memory, with a unified Reader interface across ZIP, tar (with gzip, bzip2, xz compression), jar, wheel, nupkg, egg, and Ruby gems. Includes prefix stripping for packages that wrap content in a directory (like npm’s <code class="language-plaintext highlighter-rouge">package/</code> wrapper). No <a href="https://nesbitt.io/2026/02/18/what-package-registries-could-borrow-from-oci">OCI support</a> yet, but pulling and browsing image layers through the same Reader interface is on the list.</p>\n\n<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">reader</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">archives</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="s">"package.tar.gz"</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>\n<span class="k">defer</span> <span class="n">reader</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>\n\n<span class="n">files</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">reader</span><span class="o">.</span><span class="n">List</span><span class="p">()</span>\n<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">fi</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">files</span> <span class="p">{</span>\n    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">fi</span><span class="o">.</span><span class="n">Path</span><span class="p">,</span> <span class="n">fi</span><span class="o">.</span><span class="n">Size</span><span class="p">)</span>\n<span class="p">}</span>\n\n<span class="n">rc</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">reader</span><span class="o">.</span><span class="n">Extract</span><span class="p">(</span><span class="s">"README.md"</span><span class="p">)</span>\n<span class="k">defer</span> <span class="n">rc</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>\n</code></pre></div></div>\n\n<h3 id="changelog"><a href="https://github.com/git-pkgs/changelog">changelog</a></h3>\n\n<p>Parses changelog files into structured entries, auto-detecting <a href="https://keepachangelog.com">Keep a Changelog</a>, markdown header, and setext/underline formats. You can supply custom regex patterns for non-standard formats, and there’s a finder that searches for common changelog filenames in a directory:</p>\n\n<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">changelog</span><span class="o">.</span><span class="n">FindAndParse</span><span class="p">(</span><span class="s">"."</span><span class="p">)</span>\n\n<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">p</span><span class="o">.</span><span class="n">Versions</span><span class="p">()</span> <span class="p">{</span>\n    <span class="n">entry</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">p</span><span class="o">.</span><span class="n">Entry</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>\n    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%s (%v): %s</span><span class="se">\\n</span><span class="s">"</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">entry</span><span class="o">.</span><span class="n">Date</span><span class="p">,</span> <span class="n">entry</span><span class="o">.</span><span class="n">Content</span><span class="p">)</span>\n<span class="p">}</span>\n\n<span class="c">// Content between two versions, like Dependabot uses</span>\n<span class="n">content</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">p</span><span class="o">.</span><span class="n">Between</span><span class="p">(</span><span class="s">"1.0.0"</span><span class="p">,</span> <span class="s">"2.0.0"</span><span class="p">)</span>\n</code></pre></div></div>\n\n<h3 id="gitignore"><a href="https://github.com/git-pkgs/gitignore">gitignore</a></h3>\n\n<p>Matches paths against <a href="https://nesbitt.io/2026/02/12/the-many-flavors-of-ignore-files">gitignore rules</a> using a direct implementation of git’s wildmatch algorithm rather than converting patterns to regexes, tested against git’s own wildmatch test suite. Handles nested <code class="language-plaintext highlighter-rouge">.gitignore</code> files scoped to their directories, global excludes, negation patterns, and all 12 POSIX character classes:</p>\n\n<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">m</span> <span class="o">:=</span> <span class="n">gitignore</span><span class="o">.</span><span class="n">NewFromDirectory</span><span class="p">(</span><span class="s">"/path/to/repo"</span><span class="p">)</span>\n\n<span class="n">m</span><span class="o">.</span><span class="n">Match</span><span class="p">(</span><span class="s">"vendor/lib.go"</span><span class="p">)</span>  <span class="c">// true if matched</span>\n\n<span class="n">r</span> <span class="o">:=</span> <span class="n">m</span><span class="o">.</span><span class="n">MatchDetail</span><span class="p">(</span><span class="s">"app.log"</span><span class="p">)</span>\n<span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">Matched</span> <span class="p">{</span>\n    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"ignored by %s (line %d of %s)</span><span class="se">\\n</span><span class="s">"</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">Pattern</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">Line</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">Source</span><span class="p">)</span>\n<span class="p">}</span>\n\n<span class="c">// Walk a directory, skipping ignored entries</span>\n<span class="n">gitignore</span><span class="o">.</span><span class="n">Walk</span><span class="p">(</span><span class="s">"/path/to/repo"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">path</span> <span class="kt">string</span><span class="p">,</span> <span class="n">d</span> <span class="n">fs</span><span class="o">.</span><span class="n">DirEntry</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>\n    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>\n    <span class="k">return</span> <span class="no">nil</span>\n<span class="p">})</span>\n</code></pre></div></div>\n\n<h2 id="tooling">Tooling</h2>\n\n<h3 id="managers"><a href="https://github.com/git-pkgs/managers">managers</a></h3>\n\n<p>Wraps 34 package manager CLIs behind a common interface where you describe what you want (add a dependency, list installed packages, update) and get the correct CLI invocation back. Package managers are defined in YAML files, so adding a new one doesn’t require code changes:</p>\n\n<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">translator</span> <span class="o">:=</span> <span class="n">managers</span><span class="o">.</span><span class="n">NewTranslator</span><span class="p">()</span>\n\n<span class="n">cmd</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">translator</span><span class="o">.</span><span class="n">BuildCommand</span><span class="p">(</span><span class="s">"npm"</span><span class="p">,</span> <span class="s">"add"</span><span class="p">,</span> <span class="n">managers</span><span class="o">.</span><span class="n">CommandInput</span><span class="p">{</span>\n    <span class="n">Args</span><span class="o">:</span>  <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="s">"package"</span><span class="o">:</span> <span class="s">"lodash"</span><span class="p">},</span>\n    <span class="n">Flags</span><span class="o">:</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="n">any</span><span class="p">{</span><span class="s">"dev"</span><span class="o">:</span> <span class="no">true</span><span class="p">},</span>\n<span class="p">})</span>\n<span class="c">// ["npm", "install", "lodash", "--save-dev"]</span>\n\n<span class="n">cmd</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">translator</span><span class="o">.</span><span class="n">BuildCommand</span><span class="p">(</span><span class="s">"bundler"</span><span class="p">,</span> <span class="s">"add"</span><span class="p">,</span> <span class="n">managers</span><span class="o">.</span><span class="n">CommandInput</span><span class="p">{</span>\n    <span class="n">Args</span><span class="o">:</span>  <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="s">"package"</span><span class="o">:</span> <span class="s">"rails"</span><span class="p">},</span>\n    <span class="n">Flags</span><span class="o">:</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="n">any</span><span class="p">{</span><span class="s">"dev"</span><span class="o">:</span> <span class="no">true</span><span class="p">},</span>\n<span class="p">})</span>\n<span class="c">// ["bundle", "add", "rails", "--group", "development"]</span>\n</code></pre></div></div>\n\n<p>The command definitions started as data from the <a href="https://github.com/ecosyste-ms/package-manager-commands">package manager command crosswalk</a> I built for Ecosyste.ms. Because it can drive any package manager agnostically, it opens up some interesting possibilities: setting up GitHub Actions workflows that work regardless of ecosystem, installing dependencies in git hooks without hardcoding the manager, or building tools like Dependabot that operate across all 34 managers with the same code. There’s an <a href="https://github.com/git-pkgs/managers">example Dependabot-style workflow</a> in the repo.</p>\n\n<p>It can auto-detect which manager is in use from lockfiles or manifests, and has a pluggable policy system that runs checks before commands execute: a <code class="language-plaintext highlighter-rouge">PackageBlocklistPolicy</code> prevents installing known-bad packages, and you can write your own to enforce license compliance, restrict registries, or gate operations behind approval.</p>\n\n<hr />\n\n<p>PURLs act as the common identifier across all of these, which is what makes them composable. You might parse a lockfile with <code class="language-plaintext highlighter-rouge">manifests</code> to get a list of dependencies as PURLs, enrich them with <code class="language-plaintext highlighter-rouge">registries</code> to pull in license and repository metadata, check them against <code class="language-plaintext highlighter-rouge">vulns</code> for known vulnerabilities, and normalize their license strings with <code class="language-plaintext highlighter-rouge">spdx</code> for compliance reporting. Four modules, no translation layer between them.</p>\n\n<p>All the modules are MIT licensed and available under the <a href="https://github.com/git-pkgs">git-pkgs org</a>.</p>'}

---

*抓取时间: 2026-02-21 00:09:53*
