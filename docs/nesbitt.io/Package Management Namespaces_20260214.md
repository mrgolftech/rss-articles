# Package Management Namespaces

**来源:** [nesbitt.io](https://nesbitt.io)
**发布时间:** 2026-02-14T00:00:00+00:00
**链接:** https://nesbitt.io/2026/02/14/package-management-namespaces.html

---

{'type': 'text/html', 'language': None, 'base': 'https://nesbitt.io/2026/02/14/package-management-namespaces.html', 'value': '<p>Every package needs a name. The rules for how those names work is one of the most consequential decisions a package manager makes, and one of the hardest to change later. I <a href="https://nesbitt.io/2025/12/29/categorizing-package-registries.html">categorized the approaches</a> previously and touched on the <a href="https://nesbitt.io/2025/12/05/package-manager-tradeoffs.html">tradeoffs</a> briefly.</p>\n\n<h3 id="flat-namespaces">Flat namespaces</h3>\n\n<p>RubyGems, PyPI, crates.io, Hex, Hackage, CRAN, and LuaRocks all use flat namespaces: one global pool of names, first-come-first-served. You pick a name, and if nobody has it, it’s yours.</p>\n\n<p>This gives you <code class="language-plaintext highlighter-rouge">gem install rails</code>, <code class="language-plaintext highlighter-rouge">pip install requests</code>, <code class="language-plaintext highlighter-rouge">cargo add serde</code>. The names are short, memorable, and greppable, with no punctuation to remember and no organization to look up.</p>\n\n<p>At scale, though, good names run out. Someone registers <code class="language-plaintext highlighter-rouge">database</code> on day one and never publishes a real package. Or they publish something, abandon it, and the name sits there forever, pointing at a library last updated in 2013. PyPI has over 600,000 projects. Many of the short, obvious names were claimed years ago by packages with single-digit downloads.</p>\n\n<p>Name scarcity creates pressure, and you end up with <code class="language-plaintext highlighter-rouge">python-dateutil</code> because <code class="language-plaintext highlighter-rouge">dateutil</code> was taken, <code class="language-plaintext highlighter-rouge">beautifulsoup4</code> because <code class="language-plaintext highlighter-rouge">beautifulsoup</code> was the old version, or <code class="language-plaintext highlighter-rouge">pillow</code> because the original <code class="language-plaintext highlighter-rouge">PIL</code> package was abandoned and PyPI doesn’t recycle names. New developers have to learn not just what to install but which of several similar-sounding packages is the right one.</p>\n\n<p>Flat namespaces also make <a href="https://nesbitt.io/2025/12/17/typosquatting-in-package-managers.html">typosquatting</a> straightforward. Someone registers <code class="language-plaintext highlighter-rouge">reqeusts</code> next to <code class="language-plaintext highlighter-rouge">requests</code> and waits. The attack works because there’s nothing between the user’s keystrokes and the registry lookup, no organization to verify and no hierarchy to navigate, just a string match against a flat list.</p>\n\n<p>Some registries add normalization rules to limit this. PyPI treats hyphens, underscores, and dots as equivalent, so <code class="language-plaintext highlighter-rouge">my-package</code> and <code class="language-plaintext highlighter-rouge">my_package</code> resolve to the same thing. crates.io does similar normalization. RubyGems doesn’t, which is why both <code class="language-plaintext highlighter-rouge">stripe</code> and <code class="language-plaintext highlighter-rouge">stripe-ruby</code> can coexist as unrelated packages.</p>\n\n<h3 id="scoped-namespaces">Scoped namespaces</h3>\n\n<p>npm added scopes in 2014. Instead of just <code class="language-plaintext highlighter-rouge">babel-core</code>, you could publish <code class="language-plaintext highlighter-rouge">@babel/core</code>. Packagist has always used <code class="language-plaintext highlighter-rouge">vendor/package</code> format: <code class="language-plaintext highlighter-rouge">symfony/console</code>, <code class="language-plaintext highlighter-rouge">laravel/framework</code>. JSR, Ansible Galaxy, Puppet Forge, and others follow similar patterns.</p>\n\n<p>Scopes split the package name into two parts: who published it, and what they called it. Different organizations can use the same package name without collision, so <code class="language-plaintext highlighter-rouge">@types/node</code> and <code class="language-plaintext highlighter-rouge">@anthropic/node</code> coexist without confusion.</p>\n\n<p>npm’s implementation is interesting because scopes are optional. You can still publish unscoped packages to the flat namespace. So npm actually has two systems running in parallel: a flat namespace for legacy packages and a scoped namespace for newer ones.</p>\n\n<p>Most of the ecosystem’s most-used packages (<code class="language-plaintext highlighter-rouge">express</code>, <code class="language-plaintext highlighter-rouge">lodash</code>, <code class="language-plaintext highlighter-rouge">react</code>) predate scopes and sit in the flat namespace. Scopes are most common for organizational packages (everything under <code class="language-plaintext highlighter-rouge">@angular/</code>, for example) and type definitions (<code class="language-plaintext highlighter-rouge">@types/</code>). And because so much of the ecosystem depends on unscoped names, npm can never require scopes without breaking the world.</p>\n\n<p>Packagist required scopes from the start. Every Composer package is <code class="language-plaintext highlighter-rouge">vendor/package</code>, no exceptions. This avoided the split-namespace problem npm has, but it means you need to know the vendor name. Is it <code class="language-plaintext highlighter-rouge">guzzlehttp/guzzle</code> or <code class="language-plaintext highlighter-rouge">guzzle/guzzle</code>? You have to look it up. And vendor names themselves are first-come-first-served, just pushing the squatting problem up one level. The stakes are higher, though, because squatting a vendor name locks out an entire family of package names rather than just one. Someone could register the <code class="language-plaintext highlighter-rouge">google</code> vendor on Packagist before Google gets there, and that blocks every <code class="language-plaintext highlighter-rouge">google/*</code> package at once.</p>\n\n<p>Scopes also require governance. Who decides that <code class="language-plaintext highlighter-rouge">@babel</code> belongs to the Babel team? npm ties scopes to user accounts and organizations, which means you need account management, ownership transfer procedures, and dispute resolution. When a maintainer leaves a project, their scoped packages might need to move. This is solvable but adds operational overhead that flat registries avoid.</p>\n\n<h3 id="hierarchical-namespaces">Hierarchical namespaces</h3>\n\n<p>Maven Central uses reverse-domain naming: <code class="language-plaintext highlighter-rouge">org.apache.commons:commons-lang3</code>, <code class="language-plaintext highlighter-rouge">com.google.guava:guava</code>. The group ID is supposed to correspond to a domain you control.</p>\n\n<p>The reverse-domain approach ties naming authority to DNS. If you own <code class="language-plaintext highlighter-rouge">example.com</code>, you can publish under <code class="language-plaintext highlighter-rouge">com.example</code>. This defers governance to the existing DNS system rather than requiring the registry to manage name ownership. Maven Central enforces this by requiring you to prove domain ownership, or for projects without their own domain, to use <code class="language-plaintext highlighter-rouge">io.github.username</code> as a fallback.</p>\n\n<p>That fallback is interesting because it quietly undermines the premise: the whole point of reverse-domain naming is that you prove ownership of infrastructure you control, but <code class="language-plaintext highlighter-rouge">io.github.username</code> just defers to GitHub’s namespace. It’s URL-based naming wearing a reverse-domain costume.</p>\n\n<p>Organizations with stable domains get clean namespaces out of this. Apache, Google, and Spring all have clear homes. The trade-off is verbose identifiers. <code class="language-plaintext highlighter-rouge">org.springframework.boot:spring-boot-starter-web</code> is a lot of characters. IDE autocompletion papers over this in Java, but the verbosity is real when reading build files or discussing dependencies.</p>\n\n<p>Domain ownership is also less stable than it looks. Companies get acquired and change domains. Open source projects move between hosting organizations. A package published under <code class="language-plaintext highlighter-rouge">com.sun.xml</code> in 2005 might need to live under <code class="language-plaintext highlighter-rouge">com.oracle.xml</code> after the acquisition, except it can’t, because changing the group ID would break every project that depends on the old one. So old names persist as historical artifacts.</p>\n\n<p>The hierarchy also doesn’t prevent all squatting. Someone could register a domain specifically to claim a Maven namespace. More concerning is domain resurrection: when a domain expires after its owner has already registered a Maven group ID, anyone can buy that domain and potentially claim the namespace. Maven Central <a href="https://central.sonatype.org/register/namespace/">verifies domain ownership</a> when you first register a group ID, requiring a DNS TXT record, but that verification is a point-in-time check.</p>\n\n<p>In January 2024, security firm Oversecured published <a href="https://blog.oversecured.com/Introducing-MavenGate-a-supply-chain-attack-method-for-Java-and-Android-applications/">MavenGate</a>, an analysis of 33,938 domains associated with Maven group IDs. They found that 6,170 of them, roughly 18%, had expired or were available for purchase. The affected group IDs included widely-used libraries like <code class="language-plaintext highlighter-rouge">co.fs2</code>, <code class="language-plaintext highlighter-rouge">net.jpountz.lz4</code>, and <code class="language-plaintext highlighter-rouge">com.opencsv</code>. A new owner of any of those domains could publish new versions under the existing group ID. Existing artifacts on Maven Central are immutable so old versions wouldn’t change, but build files that pull the latest version would pick up the attacker’s release.</p>\n\n<p>Sonatype responded by disabling accounts tied to expired domains and tightening their verification process, but they haven’t announced ongoing domain monitoring. PyPI, facing the same problem with account email domains, <a href="https://blog.pypi.org/posts/2025-08-18-preventing-domain-resurrections/">built automated daily checks</a> in 2025 and found around 1,800 accounts to unverify.</p>\n\n<p>Clojars shows what happens when a registry in the Maven ecosystem takes a different approach. Clojure libraries are distributed as Maven artifacts, but Clojars originally let you use any group ID without verification. You could publish under <code class="language-plaintext highlighter-rouge">hiccup</code> or <code class="language-plaintext highlighter-rouge">ring</code> with no domain proof. This was simpler for the Clojure community, where most libraries are small and maintained by individuals, but it meant Clojars had a much more relaxed namespace than Maven Central.</p>\n\n<p>Since build tools can pull from both registries, the gap created a dependency confusion risk: an attacker could register an unverified group on Clojars that shadows a legitimate Maven Central library. In 2021, after dependency confusion attacks became widely understood, Clojars <a href="https://github.com/clojars/clojars-web/wiki/Verified-Group-Names">started requiring verified group names</a> for new projects, adopting the same reverse-domain convention as Maven Central. Existing projects with unverified groups were grandfathered in, so the old flat names still exist alongside the new hierarchical ones.</p>\n\n<h3 id="url-based-identifiers">URL-based identifiers</h3>\n\n<p>Go modules use import paths that are URLs: <code class="language-plaintext highlighter-rouge">github.com/gorilla/mux</code>, <code class="language-plaintext highlighter-rouge">golang.org/x/crypto</code>. There’s no registration step. The URL points to a repository, and the module system fetches code from there (or from the Go module proxy, which caches it).</p>\n\n<p>This model sidesteps the registry as naming authority entirely. You publish code to a repository and the URL is the identifier, with no approval step required. Name collisions don’t arise because URLs are globally unique by construction, and owning the repo means owning the name.</p>\n\n<p>Names become tied to hosting infrastructure, though. When <code class="language-plaintext highlighter-rouge">github.com/user/repo</code> is the package identity, a GitHub org rename breaks every downstream consumer. Go addressed this with the module proxy, which caches modules so they survive repo disappearance, but the name still reflects the original location even if the code has moved. Import paths like <code class="language-plaintext highlighter-rouge">github.com/golang/lint</code> that redirect to <code class="language-plaintext highlighter-rouge">golang.org/x/lint</code> create confusion about which is canonical. And your package identity depends on a third party either way: GitHub controls the <code class="language-plaintext highlighter-rouge">github.com</code> namespace, so if they ban your account or the organization renames, your package identity changes. You’ve traded one governance dependency for another, a hosting platform instead of a registry.</p>\n\n<p>“No registration step” has its own consequences. Without a registry to mediate names, there’s no obvious place to check for existing packages, no search, no download counts, no centralized vulnerability database. Go built most of these features separately with pkg.go.dev and the module proxy. The URL-based naming stayed, but the surrounding infrastructure converged toward what registries provide anyway, just assembled differently.</p>\n\n<p>Deno launched with raw URL imports and eventually built <a href="https://jsr.io">JSR</a>, a scoped registry with semver resolution, because URL imports created <a href="https://deno.com/blog/http-imports">problems they couldn’t solve</a> at the URL layer: duplicated dependencies when the same package was imported from slightly different URLs, version management scattered across every import statement, and reliability issues when hosts went offline. You can start without a registry, but the things registries do (search, versioning, deduplication, availability) keep needing to be solved, and solving them piecemeal tends to reconverge on something registry-shaped.</p>\n\n<h3 id="swift-package-manager">Swift Package Manager</h3>\n\n<p>Apple hired Max Howell to build SwiftPM in 2015. He’d created Homebrew and used both CocoaPods and Carthage heavily, so he arrived with strong opinions about how a language package manager should work. As he told <a href="https://changelog.com/podcast/232">The Changelog</a>: “I’d been involved with CocoaPods and Carthage and used them heavily, and obviously made Homebrew, so I had lots of opinions about how a package manager should be.” He was drawn to decentralization, something he wished Homebrew had from the start.</p>\n\n<p>Carthage had already demonstrated the approach in the Apple ecosystem, launching in 2014 as a deliberate reaction against CocoaPods’ centralized registry, using bare Git URLs with no registry at all. SwiftPM followed the same path, using Git repository URLs as package identifiers with no central registry.</p>\n\n<p>Go made the same choice but then spent years building infrastructure around it: a module proxy that caches source in immutable storage so deleted repos still resolve, a checksum database (<code class="language-plaintext highlighter-rouge">sum.golang.org</code>) that uses a transparency log to guarantee every user gets identical content for a given version, and pkg.go.dev for search and discovery.</p>\n\n<p>SwiftPM doesn’t have any of this yet. Every <code class="language-plaintext highlighter-rouge">swift package resolve</code> clones directly from the Git host. If a repo disappears, resolution fails with no fallback. SwiftPM records a fingerprint per package version the first time it downloads it, but that fingerprint lives on your machine only. There’s no global database to verify that what you downloaded matches what everyone else got, no way to detect a targeted attack serving different content to different users.</p>\n\n<p>A <a href="https://checkmarx.com/blog/chainjacking-the-new-supply-chain-attack/">2022 Checkmarx study</a> found thousands of packages across Go and Swift vulnerable to repo-jacking, where an attacker registers an abandoned GitHub username and recreates a repo that existing packages still point to. Go’s proxy mitigates this because cached modules don’t re-fetch from the source, but SwiftPM has no such layer.</p>\n\n<p>The pieces to fix this are partly in place. Apple defined a <a href="https://github.com/swiftlang/swift-evolution/blob/main/proposals/0292-package-registry-service.md">registry protocol</a> (SE-0292, shipped in Swift 5.7) and built client support for it in SwiftPM, including package signing. The client tooling is ready, the protocol is specified, and the ecosystem is still small enough that introducing a namespace layer wouldn’t require the kind of painful migration that npm or PyPI face. The <a href="https://swiftpackageindex.com">Swift Package Index</a>, community-run and Apple-sponsored, already tracks around 12,000 packages. What’s missing is the public registry service itself and the integrity infrastructure around it, and the window for adding these before the ecosystem’s size makes it much harder is not open forever.</p>\n\n<h3 id="the-migration-problem">The migration problem</h3>\n\n<p>As I wrote about in <a href="https://nesbitt.io/2026/01/23/package-management-is-a-wicked-problem.html">Package Management is a Wicked Problem</a>, once PyPI accepted namespace-less package names, that was permanent. If PyPI added mandatory namespaces tomorrow, every existing <code class="language-plaintext highlighter-rouge">requirements.txt</code>, every tutorial, every CI script would need updating. The new system would have to support both namespaced and un-namespaced packages indefinitely. You haven’t replaced the flat namespace, you’ve just added a layer on top of it.</p>\n\n<p>npm’s experience shows what this looks like in practice. Scoped packages have been available since 2014, but most of the ecosystem still uses flat names. The existence of scopes didn’t make <code class="language-plaintext highlighter-rouge">express</code> become <code class="language-plaintext highlighter-rouge">@expressjs/express</code> because too much already depends on the existing name. Scopes ended up being used primarily for new packages and organizational groups rather than as a migration path for the existing namespace.</p>\n\n<p>NuGet went through a partial migration. It added package ID prefix reservation in 2017, letting Microsoft reserve the <code class="language-plaintext highlighter-rouge">Microsoft.*</code> prefix. But this is a bolt-on: the underlying namespace is still flat, and the prefixes are just a verified badge on the registry UI. It helps users identify official packages but doesn’t change the naming model.</p>\n\n<p>PyPI is threading this needle right now with <a href="https://peps.python.org/pep-0752/">PEP 752</a>, which proposes letting organizations reserve package name prefixes. Google could reserve <code class="language-plaintext highlighter-rouge">google-cloud-</code>, Apache could reserve <code class="language-plaintext highlighter-rouge">apache-airflow-providers-</code>, and future uploads matching those prefixes would require authorization from the namespace owner. Like NuGet’s approach, it requires no installer changes and leaves existing packages unaffected. It only applies going forward, though, and the thousands of existing packages with no organizational prefix remain as they are.</p>\n\n<p>Cargo and crates.io are attempting something more ambitious. The Rust community has been discussing namespaces since at least 2014, and after several earlier proposals that leaned toward npm-style user or org scopes, they settled on <a href="https://rust-lang.github.io/rfcs/3243-packages-as-optional-namespaces.html">RFC 3243</a> (“Packages as Optional Namespaces”), authored by Manish Goregaokar, who had been working on the problem since at least 2018 when the first “packages as namespaces” pre-RFC appeared.</p>\n\n<p>The approach treats existing crate names as potential namespace roots: if you own the <code class="language-plaintext highlighter-rouge">serde</code> crate, you can publish <code class="language-plaintext highlighter-rouge">serde::derive</code>, and only owners of <code class="language-plaintext highlighter-rouge">serde</code> can create crates in that namespace. Ownership flows down automatically. The <code class="language-plaintext highlighter-rouge">::</code> separator was chosen after extensive debate because it aligns with Rust’s existing path syntax, so <code class="language-plaintext highlighter-rouge">serde::derive::Deserialize</code> reads naturally in Rust source. An earlier proposal used <code class="language-plaintext highlighter-rouge">/</code> but that conflicted with Cargo’s feature syntax.</p>\n\n<p>The design is carefully scoped. Namespaces are optional, so the flat namespace stays and nothing breaks. It’s framed around projects rather than organizations, with the primary use cases being things like <code class="language-plaintext highlighter-rouge">serde::derive</code> or <code class="language-plaintext highlighter-rouge">tokio::macros</code> rather than org-level grouping. Only single-level nesting is supported for now. And they explicitly chose not to do NuGet-style prefix reservation because in a flat namespace where <code class="language-plaintext highlighter-rouge">serde-derive</code> already exists, reserving the <code class="language-plaintext highlighter-rouge">serde-</code> prefix would create confusion about whether existing <code class="language-plaintext highlighter-rouge">serde-*</code> crates are actually owned by <code class="language-plaintext highlighter-rouge">serde</code>.</p>\n\n<p>The migration challenges are real even with this careful design. A crate like <code class="language-plaintext highlighter-rouge">tokio-macros</code> already exists in the flat namespace, and transitioning it to <code class="language-plaintext highlighter-rouge">tokio::macros</code> means a new name that every downstream consumer would need to update. The RFC suggests maintaining re-export crates during transition, but there’s no alias mechanism yet. Some projects face an even harder version of this problem: the <code class="language-plaintext highlighter-rouge">async-std</code> project manages a family of <code class="language-plaintext highlighter-rouge">async-*</code> crates, but someone else owns the <code class="language-plaintext highlighter-rouge">async</code> crate, so they can’t use it as their namespace root.</p>\n\n<p>The RFC was accepted and became an official Rust project goal for 2025, led by Ed Page on the Cargo team. As of late 2025, Cargo support is partially implemented but compiler support is still in progress, requiring coordination across the lang, compiler, and crates.io teams. It’s the most carefully designed attempt at retrofitting namespaces onto a flat registry that I’m aware of, and the fact that it’s taking years of design and implementation work for a well-resourced community with strong governance shows how hard this problem is once a flat namespace is established.</p>\n\n<p>If you’re starting a registry today, you don’t have to require namespaces from day one, but you could reserve the separator character and the ownership semantics so that namespaces can be added later without conflicting with existing names. The reason crates.io can use <code class="language-plaintext highlighter-rouge">::</code> is that no existing crate name contains it. If they’d allowed colons in crate names from the start, this whole approach would have been foreclosed. Keeping your options open costs almost nothing at launch and can save years of design work later.</p>'}

---

*抓取时间: 2026-02-15 00:03:07*
