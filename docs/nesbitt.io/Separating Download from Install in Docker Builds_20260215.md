# Separating Download from Install in Docker Builds

**来源:** [nesbitt.io](https://nesbitt.io)
**发布时间:** 2026-02-15T00:00:00+00:00
**链接:** https://nesbitt.io/2026/02/15/separating-download-from-install-in-docker-builds.html

---

{'type': 'text/html', 'language': None, 'base': 'https://nesbitt.io/2026/02/15/separating-download-from-install-in-docker-builds.html', 'value': '<p>Docker layer caching works best when each layer’s inputs are narrow, and a layer that only depends on a lockfile can survive most builds untouched because you’re usually changing application code, not dependencies. Most package managers combine downloading and installing into a single command though, so the layer that fetches from the registry also depends on source files, and any source change invalidates the layer and forces every dependency to re-download even when the lockfile is identical to last time.</p>\n\n<p>That costs more than build time. crates.io, rubygems.org, and pypi.org all run on bandwidth donated by Fastly, and every redundant download in a Docker build is a cost someone else is volunteering to cover. npm is backed by Microsoft and Go’s module proxy by Google, so they can absorb it, but for the community-funded registries it adds up. It feels instant from the developer’s side, a few seconds of progress bars, so nobody thinks about the hundreds of HTTP requests firing against those services on every build where the lockfile has changed by even one line, or when you’re debugging a failed install and rebuilding the same image over and over.</p>\n\n<p>If package managers exposed a <code class="language-plaintext highlighter-rouge">download</code> that populates the local cache from the lockfile and an <code class="language-plaintext highlighter-rouge">install</code> that works offline from that cache, Docker layer caching would handle the rest:</p>\n\n<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">COPY</span><span class="s"> lockfile .</span>\n<span class="k">RUN </span>pkg download\n<span class="k">COPY</span><span class="s"> . .</span>\n<span class="k">RUN </span>pkg <span class="nb">install</span> <span class="nt">--offline</span>\n</code></pre></div></div>\n\n<h3 id="go-mod-download">go mod download</h3>\n\n<p>Go modules shipped with Go 1.11 in August 2018, and the community figured out the Docker pattern <a href="https://blog.container-solutions.com/faster-builds-in-docker-with-go-1-11">within weeks</a>. It’s now the canonical Go Dockerfile pattern, recommended by <a href="https://docs.docker.com/guides/golang/build-images/">Docker’s own documentation</a>:</p>\n\n<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">COPY</span><span class="s"> go.mod go.sum ./</span>\n<span class="k">RUN </span>go mod download\n<span class="k">COPY</span><span class="s"> . .</span>\n<span class="k">RUN </span><span class="nv">CGO_ENABLED</span><span class="o">=</span>0 go build <span class="nt">-o</span> /app .\n</code></pre></div></div>\n\n<p><code class="language-plaintext highlighter-rouge">go mod download</code> reads <code class="language-plaintext highlighter-rouge">go.mod</code> and <code class="language-plaintext highlighter-rouge">go.sum</code> and fetches everything without doing any resolution or building, and the layer caches when those two files haven’t changed.</p>\n\n<p>Before Go 1.11, <code class="language-plaintext highlighter-rouge">GOPATH</code>-based dependency management didn’t have a clean two-file manifest that could be separated from source code for layer caching, and the design of <code class="language-plaintext highlighter-rouge">go.mod</code> and <code class="language-plaintext highlighter-rouge">go.sum</code> as small standalone files made this Docker pattern fall out naturally once modules landed.</p>\n\n<p><code class="language-plaintext highlighter-rouge">go build</code> can still contact the checksum database (<code class="language-plaintext highlighter-rouge">sum.golang.org</code>) after <code class="language-plaintext highlighter-rouge">go mod download</code> to verify modules not yet in <code class="language-plaintext highlighter-rouge">go.sum</code>. Setting <code class="language-plaintext highlighter-rouge">GOFLAGS=-mod=readonly</code> after the download step prevents any network access during the build.</p>\n\n<h3 id="pnpm-fetch">pnpm fetch</h3>\n\n<p>pnpm is the only JavaScript package manager with a download-only command, and <a href="https://pnpm.io/cli/fetch"><code class="language-plaintext highlighter-rouge">pnpm fetch</code></a> was designed specifically for Docker. It reads <code class="language-plaintext highlighter-rouge">pnpm-lock.yaml</code> and downloads all packages into pnpm’s content-addressable store without reading <code class="language-plaintext highlighter-rouge">package.json</code> at all:</p>\n\n<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">COPY</span><span class="s"> pnpm-lock.yaml pnpm-workspace.yaml ./</span>\n<span class="k">RUN </span>pnpm fetch <span class="nt">--prod</span>\n<span class="k">COPY</span><span class="s"> . .</span>\n<span class="k">RUN </span>pnpm <span class="nb">install</span> <span class="nt">-r</span> <span class="nt">--offline</span> <span class="nt">--prod</span>\n</code></pre></div></div>\n\n<p>The download layer only depends on the lockfile, and the install step uses <code class="language-plaintext highlighter-rouge">--offline</code> so it never touches the network. In monorepos this is particularly useful because you don’t need to copy every workspace’s <code class="language-plaintext highlighter-rouge">package.json</code> before the download step, and pnpm’s authors thinking about container builds when they designed the CLI is the same kind of design awareness that made <code class="language-plaintext highlighter-rouge">go mod download</code> standard in Go.</p>\n\n<h3 id="cargo-fetch">cargo fetch</h3>\n\n<p><a href="https://doc.rust-lang.org/cargo/commands/cargo-fetch.html"><code class="language-plaintext highlighter-rouge">cargo fetch</code></a> reads <code class="language-plaintext highlighter-rouge">Cargo.lock</code> and downloads all crate source into the registry cache. After fetching, <code class="language-plaintext highlighter-rouge">--frozen</code> (which combines <code class="language-plaintext highlighter-rouge">--locked</code> and <code class="language-plaintext highlighter-rouge">--offline</code>) prevents any network access during the build:</p>\n\n<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">COPY</span><span class="s"> Cargo.toml Cargo.lock ./</span>\n<span class="k">RUN </span><span class="nb">mkdir </span>src <span class="o">&amp;&amp;</span> <span class="nb">touch </span>src/main.rs\n<span class="k">RUN </span>cargo fetch <span class="nt">--locked</span>\n<span class="k">COPY</span><span class="s"> . .</span>\n<span class="k">RUN </span>cargo build <span class="nt">--release</span> <span class="nt">--frozen</span>\n</code></pre></div></div>\n\n<p>The dummy <code class="language-plaintext highlighter-rouge">src/main.rs</code> is needed because <code class="language-plaintext highlighter-rouge">cargo fetch</code> requires a valid project structure even though it’s only reading the lockfile, and there’s been an <a href="https://github.com/rust-lang/cargo/issues/2644">open issue</a> about removing that requirement since 2016.</p>\n\n<p>Almost nobody uses <code class="language-plaintext highlighter-rouge">cargo fetch</code> in Dockerfiles. The Rust community skipped straight to caching compilation with <a href="https://github.com/LukeMathWalker/cargo-chef">cargo-chef</a>, because compiling hundreds of crates is where builds spend most of their wall-clock time and downloads feel cheap by comparison. But every <code class="language-plaintext highlighter-rouge">cargo build</code> without a prior <code class="language-plaintext highlighter-rouge">cargo fetch</code> is still hitting crates.io for every crate whenever the layer rebuilds, and Fastly is absorbing that traffic whether it takes three seconds or thirty.</p>\n\n<h3 id="pip-wheel">pip wheel</h3>\n\n<p><a href="https://pip.pypa.io/en/stable/cli/pip_wheel/"><code class="language-plaintext highlighter-rouge">pip wheel</code></a> builds wheels for all dependencies into a directory, and <code class="language-plaintext highlighter-rouge">pip install --no-index --find-links</code> installs from that directory offline:</p>\n\n<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">COPY</span><span class="s"> requirements.txt .</span>\n<span class="k">RUN </span>pip wheel <span class="nt">-r</span> requirements.txt <span class="nt">-w</span> /tmp/wheels\n<span class="k">COPY</span><span class="s"> . .</span>\n<span class="k">RUN </span>pip <span class="nb">install</span> <span class="nt">--no-index</span> <span class="nt">--find-links</span> /tmp/wheels <span class="nt">-r</span> requirements.txt\n</code></pre></div></div>\n\n<p><code class="language-plaintext highlighter-rouge">pip download</code> also exists but has a <a href="https://github.com/pypa/pip/issues/7863">known bug</a> where build dependencies like setuptools aren’t included, so packages that ship as source distributions can fail during the offline install. <code class="language-plaintext highlighter-rouge">pip wheel</code> avoids this by compiling everything into wheels up front, so the install step never needs a build backend.</p>\n\n<p>Neither Poetry nor uv have download-only commands. Poetry has had an <a href="https://github.com/python-poetry/poetry/issues/2184">open issue</a> since 2020, and uv has <a href="https://github.com/astral-sh/uv/issues/3163">one</a> with over a hundred upvotes. Both suggest exporting to <code class="language-plaintext highlighter-rouge">requirements.txt</code> and falling back to pip.</p>\n\n<h3 id="bundle-cache">bundle cache</h3>\n\n<p>Bundler has <code class="language-plaintext highlighter-rouge">bundle cache --no-install</code>, which fetches <code class="language-plaintext highlighter-rouge">.gem</code> files into <code class="language-plaintext highlighter-rouge">vendor/cache</code> without installing them, and <code class="language-plaintext highlighter-rouge">bundle install --local</code> installs from that cache without hitting the network:</p>\n\n<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">COPY</span><span class="s"> Gemfile Gemfile.lock ./</span>\n<span class="k">RUN </span>bundle cache <span class="nt">--no-install</span>\n<span class="k">COPY</span><span class="s"> . .</span>\n<span class="k">RUN </span>bundle <span class="nb">install</span> <span class="nt">--local</span>\n</code></pre></div></div>\n\n<p>In practice this has enough rough edges that it rarely gets used in Dockerfiles. Git-sourced gems <a href="https://github.com/ruby/rubygems/issues/6499">still try to reach the remote</a> even with <code class="language-plaintext highlighter-rouge">--local</code>, and platform-specific gems need <code class="language-plaintext highlighter-rouge">--all-platforms</code> plus <code class="language-plaintext highlighter-rouge">bundle lock --add-platform</code> to work across macOS development and Linux containers. The command was designed for vendoring gems into your repository rather than for Docker layer caching.</p>\n\n<h3 id="npm-and-yarn">npm and yarn</h3>\n\n<p>npm has no download-only command. <code class="language-plaintext highlighter-rouge">npm ci</code> reads the lockfile and skips resolution, but downloads and installs as one atomic operation with no way to separate them, and there’s no <code class="language-plaintext highlighter-rouge">--download-only</code> flag or RFC proposing one.</p>\n\n<p>Yarn Classic has an offline mirror that saves tarballs as a side effect of install, but no standalone download command. Yarn Berry has no fetch command either, despite <a href="https://github.com/yarnpkg/berry/issues/4529">multiple</a> <a href="https://github.com/yarnpkg/berry/issues/5998">open</a> issues requesting one.</p>\n\n<p>The standard JavaScript Docker pattern is still:</p>\n\n<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">COPY</span><span class="s"> package.json package-lock.json ./</span>\n<span class="k">RUN </span>npm ci\n<span class="k">COPY</span><span class="s"> . .</span>\n</code></pre></div></div>\n\n<p>When the lockfile hasn’t changed the layer caches and nothing gets downloaded, but when it has changed every package re-downloads from the registry, and pnpm is the only JavaScript package manager where you can avoid that.</p>\n\n<h3 id="buildkit-cache-mounts">BuildKit cache mounts</h3>\n\n<p>Docker BuildKit has <code class="language-plaintext highlighter-rouge">--mount=type=cache</code>, which persists a cache directory across builds so package managers can reuse previously downloaded packages even when the layer invalidates:</p>\n\n<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">RUN </span><span class="nt">--mount</span><span class="o">=</span><span class="nb">type</span><span class="o">=</span>cache,target<span class="o">=</span>/root/.npm npm ci\n</code></pre></div></div>\n\n<p>Cache mounts solve the problem from the wrong end. The package manager has the lockfile and knows the cache format, but Docker doesn’t know any of that, which is why the Dockerfile author has to specify internal cache paths that vary between tools and sometimes between versions of the same tool. Not every build system supports BuildKit cache mounts either, and not every CI environment preserves them between builds, so a download command in the package manager itself would be more broadly useful.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Registry</th>\n      <th>Funding</th>\n      <th>Download command</th>\n      <th>Offline install</th>\n      <th>Used in practice?</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Go module proxy</td>\n      <td>Google</td>\n      <td><code class="language-plaintext highlighter-rouge">go mod download</code></td>\n      <td>implicit</td>\n      <td>Yes, canonical</td>\n    </tr>\n    <tr>\n      <td>npm registry</td>\n      <td>Microsoft</td>\n      <td><code class="language-plaintext highlighter-rouge">pnpm fetch</code> (pnpm only; npm and yarn have nothing)</td>\n      <td><code class="language-plaintext highlighter-rouge">--offline</code></td>\n      <td>pnpm yes, others no</td>\n    </tr>\n    <tr>\n      <td>crates.io</td>\n      <td>Fastly (donated)</td>\n      <td><code class="language-plaintext highlighter-rouge">cargo fetch</code></td>\n      <td><code class="language-plaintext highlighter-rouge">--frozen</code></td>\n      <td>Rarely</td>\n    </tr>\n    <tr>\n      <td>PyPI</td>\n      <td>Fastly (donated)</td>\n      <td><code class="language-plaintext highlighter-rouge">pip wheel</code> (pip only)</td>\n      <td><code class="language-plaintext highlighter-rouge">--no-index --find-links</code></td>\n      <td>Rarely</td>\n    </tr>\n    <tr>\n      <td>rubygems.org</td>\n      <td>Fastly (donated)</td>\n      <td><code class="language-plaintext highlighter-rouge">bundle cache --no-install</code></td>\n      <td><code class="language-plaintext highlighter-rouge">--local</code></td>\n      <td>Rarely</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>Most package managers were designed around a persistent local cache on a developer’s laptop, <code class="language-plaintext highlighter-rouge">~/.cache</code> or <code class="language-plaintext highlighter-rouge">~/.gem</code> or <code class="language-plaintext highlighter-rouge">~/.npm</code>, that warms up over time and stays warm. Ephemeral build environments start clean every time, and Docker layers are the only caching mechanism available, which means the network-dependent part of a build needs to be isolated from the rest for caching to work.</p>\n\n<p>Opportunities:</p>\n\n<ul>\n  <li>npm could add an <code class="language-plaintext highlighter-rouge">npm fetch</code> that reads <code class="language-plaintext highlighter-rouge">package-lock.json</code> and populates the cache without installing</li>\n  <li>Poetry has had an <a href="https://github.com/python-poetry/poetry/issues/2184">open issue</a> requesting a download command since 2020, and uv has <a href="https://github.com/astral-sh/uv/issues/3163">one</a> with strong community interest</li>\n  <li>Bundler’s <code class="language-plaintext highlighter-rouge">bundle cache --no-install</code> would work if it handled git gems and cross-platform builds more reliably</li>\n  <li>Cargo’s <code class="language-plaintext highlighter-rouge">cargo fetch</code> shouldn’t need a dummy source file to run a command that only reads the lockfile</li>\n</ul>'}

---

*抓取时间: 2026-02-18 18:04:17*
