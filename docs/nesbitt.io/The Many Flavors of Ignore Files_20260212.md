# The Many Flavors of Ignore Files

**来源:** [nesbitt.io](https://nesbitt.io)
**发布时间:** 2026-02-12T10:00:00+00:00
**链接:** https://nesbitt.io/2026/02/12/the-many-flavors-of-ignore-files.html

---

{'type': 'text/html', 'language': None, 'base': 'https://nesbitt.io/2026/02/12/the-many-flavors-of-ignore-files.html', 'value': '<p>A <a href="https://github.com/git-pkgs/git-pkgs/issues/53#issuecomment-3857707729">bug report</a> in git-pkgs led me down a rabbit hole: files that git ignored were showing up as phantom diffs, and the cause turned out to be <a href="https://github.com/go-git/go-git/issues/108">go-git’s gitignore implementation</a>, which doesn’t match git’s actual behavior for unanchored patterns in nested directories. I went looking for a Go library that fully matched git’s pattern semantics and couldn’t find one, so I wrote <a href="https://github.com/git-pkgs/gitignore">git-pkgs/gitignore</a> with a wildmatch engine modeled on git’s own <code class="language-plaintext highlighter-rouge">wildmatch.c</code>.</p>\n\n<p>Building that made me appreciate how much complexity hides behind <code class="language-plaintext highlighter-rouge">.gitignore</code>, and got me thinking about all the other tools with their own ignore files. Most claim to use “gitignore syntax” without specifying which parts, and that phrase turns out to be doing a lot of work. Every tool wants to be git until it has to implement git’s edge cases.</p>\n\n<h3 id="gitignore">gitignore</h3>\n\n<p>Most people know that <code class="language-plaintext highlighter-rouge">*.log</code> ignores log files and <code class="language-plaintext highlighter-rouge">node_modules/</code> ignores the node_modules directory. But gitignore does far more than simple glob matching. I covered the basics in <a href="https://nesbitt.io/2026/02/05/git-magic-files.html">Git’s Magic Files</a>, but getting a correct implementation working forced me to deal with all of it. The <a href="https://git-scm.com/docs/gitignore">gitignore docs</a> describe the behavior in prose; the real authority is the implementation in <a href="https://github.com/git/git/blob/master/dir.c">dir.c</a> and <a href="https://github.com/git/git/blob/master/wildmatch.c">wildmatch.c</a>, with tests in <a href="https://github.com/git/git/blob/master/t/t0008-ignores.sh">t0008-ignores.sh</a> and <a href="https://github.com/git/git/blob/master/t/t3070-wildmatch.sh">t3070-wildmatch.sh</a>.</p>\n\n<p><strong>Four layers of patterns.</strong> Git doesn’t just read one <code class="language-plaintext highlighter-rouge">.gitignore</code> file. It checks patterns from four sources in order of increasing priority: the global excludes file (<code class="language-plaintext highlighter-rouge">core.excludesFile</code>, defaulting to <code class="language-plaintext highlighter-rouge">~/.config/git/ignore</code>), then <code class="language-plaintext highlighter-rouge">.git/info/exclude</code> for repo-local patterns that aren’t committed, then the root <code class="language-plaintext highlighter-rouge">.gitignore</code>, then <code class="language-plaintext highlighter-rouge">.gitignore</code> files in each subdirectory. A pattern in <code class="language-plaintext highlighter-rouge">src/.gitignore</code> only applies to files under <code class="language-plaintext highlighter-rouge">src/</code>. Patterns in deeper directories override patterns in parent directories, and the last matching pattern wins. If you’re debugging why a file isn’t being ignored (or why it is), <code class="language-plaintext highlighter-rouge">git check-ignore -v &lt;path&gt;</code> will tell you exactly which pattern in which file is responsible.</p>\n\n<p><strong>Anchored vs. unanchored patterns.</strong> A pattern with no slash in it, like <code class="language-plaintext highlighter-rouge">*.log</code>, is unanchored and matches at any depth because git effectively prepends <code class="language-plaintext highlighter-rouge">**/</code> to it. But the moment a pattern contains a slash, including a leading <code class="language-plaintext highlighter-rouge">/</code>, it becomes anchored to its <code class="language-plaintext highlighter-rouge">.gitignore</code>’s directory. This distinction is where go-git’s implementation broke down for us.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Pattern</th>\n      <th>Matches</th>\n      <th>Doesn’t match</th>\n      <th>Why</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><code class="language-plaintext highlighter-rouge">debug.log</code></td>\n      <td><code class="language-plaintext highlighter-rouge">debug.log</code>, <code class="language-plaintext highlighter-rouge">logs/debug.log</code></td>\n      <td>\xa0</td>\n      <td>Unanchored, matches at any depth</td>\n    </tr>\n    <tr>\n      <td><code class="language-plaintext highlighter-rouge">/debug.log</code></td>\n      <td><code class="language-plaintext highlighter-rouge">debug.log</code> at root only</td>\n      <td><code class="language-plaintext highlighter-rouge">logs/debug.log</code></td>\n      <td>Leading <code class="language-plaintext highlighter-rouge">/</code> anchors to root</td>\n    </tr>\n    <tr>\n      <td><code class="language-plaintext highlighter-rouge">doc/frotz</code></td>\n      <td><code class="language-plaintext highlighter-rouge">doc/frotz</code></td>\n      <td><code class="language-plaintext highlighter-rouge">a/doc/frotz</code></td>\n      <td>Contains <code class="language-plaintext highlighter-rouge">/</code>, so anchored</td>\n    </tr>\n    <tr>\n      <td><code class="language-plaintext highlighter-rouge">build/</code></td>\n      <td><code class="language-plaintext highlighter-rouge">build/</code> (dir), <code class="language-plaintext highlighter-rouge">src/build/</code> (dir)</td>\n      <td><code class="language-plaintext highlighter-rouge">build</code> (file)</td>\n      <td>Trailing <code class="language-plaintext highlighter-rouge">/</code> restricts to directories</td>\n    </tr>\n  </tbody>\n</table>\n\n<p><strong>Wildcards.</strong> <code class="language-plaintext highlighter-rouge">*</code> matches any string within a single path segment but does not cross <code class="language-plaintext highlighter-rouge">/</code> boundaries. <code class="language-plaintext highlighter-rouge">?</code> matches exactly one character, also not <code class="language-plaintext highlighter-rouge">/</code>. These follow the rules of git’s <code class="language-plaintext highlighter-rouge">wildmatch.c</code>, which is subtly different from shell globbing or Go’s <code class="language-plaintext highlighter-rouge">filepath.Match</code>.</p>\n\n<p><strong>Doublestar <code class="language-plaintext highlighter-rouge">**</code>.</strong> Only special when it appears as a complete path segment between slashes: <code class="language-plaintext highlighter-rouge">**/logs</code> matches <code class="language-plaintext highlighter-rouge">logs</code> at any depth, <code class="language-plaintext highlighter-rouge">logs/**</code> matches everything under <code class="language-plaintext highlighter-rouge">logs/</code>, and <code class="language-plaintext highlighter-rouge">foo/**/bar</code> matches <code class="language-plaintext highlighter-rouge">foo/bar</code>, <code class="language-plaintext highlighter-rouge">foo/a/bar</code>, <code class="language-plaintext highlighter-rouge">foo/a/b/c/bar</code> with zero or more intermediate directories. But <code class="language-plaintext highlighter-rouge">foo**bar</code> is not special because the stars aren’t a standalone segment; they’re just two regular <code class="language-plaintext highlighter-rouge">*</code> wildcards that won’t cross a <code class="language-plaintext highlighter-rouge">/</code>.</p>\n\n<p><strong>Bracket expressions.</strong> <code class="language-plaintext highlighter-rouge">[abc]</code> matches one character from the set, ranges like <code class="language-plaintext highlighter-rouge">[a-z]</code> and <code class="language-plaintext highlighter-rouge">[0-9]</code> work as expected, and both <code class="language-plaintext highlighter-rouge">[!a-z]</code> and <code class="language-plaintext highlighter-rouge">[^a-z]</code> negate the match. All 12 POSIX character classes are supported: <code class="language-plaintext highlighter-rouge">[:alnum:]</code>, <code class="language-plaintext highlighter-rouge">[:alpha:]</code>, <code class="language-plaintext highlighter-rouge">[:blank:]</code>, <code class="language-plaintext highlighter-rouge">[:cntrl:]</code>, <code class="language-plaintext highlighter-rouge">[:digit:]</code>, <code class="language-plaintext highlighter-rouge">[:graph:]</code>, <code class="language-plaintext highlighter-rouge">[:lower:]</code>, <code class="language-plaintext highlighter-rouge">[:print:]</code>, <code class="language-plaintext highlighter-rouge">[:punct:]</code>, <code class="language-plaintext highlighter-rouge">[:space:]</code>, <code class="language-plaintext highlighter-rouge">[:upper:]</code>, <code class="language-plaintext highlighter-rouge">[:xdigit:]</code>. You can mix classes with ranges in a single expression: <code class="language-plaintext highlighter-rouge">[a-c[:digit:]x-z]</code>. The edge cases are where it gets interesting: <code class="language-plaintext highlighter-rouge">]</code> as the first character after <code class="language-plaintext highlighter-rouge">[</code> is a literal member of the class, not the closing bracket. Ranges are byte-value ordered, so <code class="language-plaintext highlighter-rouge">[B-a]</code> matches bytes 66 through 97, which includes uppercase B through Z, several symbols, and lowercase a.</p>\n\n<p><strong>Directory-only patterns.</strong> A trailing <code class="language-plaintext highlighter-rouge">/</code> means the pattern only matches directories, so <code class="language-plaintext highlighter-rouge">build/</code> matches the directory <code class="language-plaintext highlighter-rouge">build</code> but not a file named <code class="language-plaintext highlighter-rouge">build</code>, and it also matches everything inside that directory because once a directory is ignored git skips it entirely and never looks at its contents.</p>\n\n<p><strong>Negation.</strong> A leading <code class="language-plaintext highlighter-rouge">!</code> re-includes something a previous pattern excluded. The subtlety is that you can’t re-include a file if its parent directory was already excluded, because git never descends into the excluded directory to check. To ignore everything except one nested path, you need to re-include each intermediate directory:</p>\n\n<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*\n!/foo\n/foo/*\n!/foo/bar\n</code></pre></div></div>\n\n<p>This ignores everything except <code class="language-plaintext highlighter-rouge">foo/bar</code>. You have to re-include <code class="language-plaintext highlighter-rouge">foo/</code>, then re-exclude <code class="language-plaintext highlighter-rouge">foo/*</code>, then re-include <code class="language-plaintext highlighter-rouge">foo/bar</code>. Skipping the middle step means <code class="language-plaintext highlighter-rouge">foo/bar</code> stays excluded.</p>\n\n<p><strong>Escaping.</strong> A backslash makes the next character literal, so <code class="language-plaintext highlighter-rouge">\\!important</code> matches a file literally named <code class="language-plaintext highlighter-rouge">!important</code> rather than being a negation pattern, and <code class="language-plaintext highlighter-rouge">\\#comment</code> matches a file named <code class="language-plaintext highlighter-rouge">#comment</code> rather than being treated as a comment line.</p>\n\n<p><strong>Trailing spaces.</strong> Unescaped trailing spaces on a pattern line are stripped, but trailing tabs are not. A backslash before a trailing space preserves it. Leading spaces are always significant: `  hello<code class="language-plaintext highlighter-rouge"> is a valid pattern matching a file named </code>  hello`.</p>\n\n<p><strong>Tracked files are immune.</strong> If a file is already tracked by git, adding it to <code class="language-plaintext highlighter-rouge">.gitignore</code> does nothing. You need <code class="language-plaintext highlighter-rouge">git rm --cached</code> first. This is probably the single most common source of confusion with gitignore. There’s also <code class="language-plaintext highlighter-rouge">git update-index --assume-unchanged</code> which tells git to <a href="https://luisdalmolin.dev/blog/ignoring-files-in-git-without-gitignore/">pretend a tracked file hasn’t changed</a>, useful for local config tweaks you don’t want showing up in <code class="language-plaintext highlighter-rouge">git status</code>.</p>\n\n<h3 id="everything-else">Everything else</h3>\n\n<p><a href="https://git-scm.com/docs/gitignore"><code class="language-plaintext highlighter-rouge">.gitignore</code></a> is the original. Then the copies, roughly in order of how likely you are to encounter them:</p>\n\n<ul>\n  <li><a href="https://docs.docker.com/build/concepts/context/"><code class="language-plaintext highlighter-rouge">.dockerignore</code></a> for Docker build context</li>\n  <li><a href="https://docs.npmjs.com/cli/v11/using-npm/developers/"><code class="language-plaintext highlighter-rouge">.npmignore</code></a> for npm package publishing</li>\n  <li><a href="https://prettier.io/docs/ignore"><code class="language-plaintext highlighter-rouge">.prettierignore</code></a>, <a href="https://eslint.org/docs/latest/use/configure/ignore"><code class="language-plaintext highlighter-rouge">.eslintignore</code></a>, <a href="https://stylelint.io/user-guide/ignore-code/"><code class="language-plaintext highlighter-rouge">.stylelintignore</code></a> for JavaScript linters and formatters</li>\n  <li><a href="https://www.selenic.com/mercurial/hgignore.5.html"><code class="language-plaintext highlighter-rouge">.hgignore</code></a> for Mercurial</li>\n  <li><a href="https://github.com/containers/common/blob/main/docs/containerignore.5.md"><code class="language-plaintext highlighter-rouge">.containerignore</code></a> for Podman and Buildah (the OCI alternative to <code class="language-plaintext highlighter-rouge">.dockerignore</code>)</li>\n  <li><a href="https://cloud.google.com/sdk/gcloud/reference/topic/gcloudignore"><code class="language-plaintext highlighter-rouge">.gcloudignore</code></a> for Google Cloud</li>\n  <li><a href="https://vercel.com/docs/deployments/vercel-ignore"><code class="language-plaintext highlighter-rouge">.vercelignore</code></a> for Vercel (<code class="language-plaintext highlighter-rouge">.nowignore</code> was the legacy name)</li>\n  <li><a href="https://devcenter.heroku.com/articles/slug-compiler"><code class="language-plaintext highlighter-rouge">.slugignore</code></a> for Heroku</li>\n  <li><a href="https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/eb-cli3-configuration.html"><code class="language-plaintext highlighter-rouge">.ebignore</code></a> for AWS Elastic Beanstalk</li>\n  <li><a href="https://docs.cloudfoundry.org/devguide/deploy-apps/deploy-app.html"><code class="language-plaintext highlighter-rouge">.cfignore</code></a> for Cloud Foundry</li>\n  <li><a href="https://helm.sh/docs/chart_template_guide/helm_ignore_file/"><code class="language-plaintext highlighter-rouge">.helmignore</code></a> for Helm charts</li>\n  <li><a href="https://learn.microsoft.com/en-us/azure/devops/artifacts/reference/artifactignore"><code class="language-plaintext highlighter-rouge">.artifactignore</code></a> for Azure DevOps</li>\n  <li><a href="https://learn.microsoft.com/en-us/azure/developer/azure-developer-cli/service-packaging-ignore-files"><code class="language-plaintext highlighter-rouge">.funcignore</code></a> for Azure Functions</li>\n  <li><a href="https://code.visualstudio.com/api/working-with-extensions/publishing-extension"><code class="language-plaintext highlighter-rouge">.vscodeignore</code></a> for VS Code extension packaging</li>\n  <li><a href="https://docs.chef.io/chef_repo/"><code class="language-plaintext highlighter-rouge">.chefignore</code></a> for Chef</li>\n  <li><a href="https://web.archive.org/web/20220811170451/http://doc.bazaar.canonical.com/latest/en/user-guide/controlling_registration.html"><code class="language-plaintext highlighter-rouge">.bzrignore</code></a> for Bazaar</li>\n  <li><a href="https://www.gnu.org/software/trans-coord/manual/cvs/html_node/cvsignore.html"><code class="language-plaintext highlighter-rouge">.cvsignore</code></a> for CVS</li>\n  <li><code class="language-plaintext highlighter-rouge">.ignore</code>, <code class="language-plaintext highlighter-rouge">.rgignore</code>, <code class="language-plaintext highlighter-rouge">.agignore</code> for <a href="https://github.com/BurntSushi/ripgrep">ripgrep</a> and <a href="https://github.com/ggreer/the_silver_searcher">the silver searcher</a></li>\n</ul>\n\n<h3 id="how-others-differ">How others differ</h3>\n\n<p>Docker’s is probably the most consequential ignore file after git’s, because it affects build context size and therefore build speed and layer caching. But it’s still just one flat file with no cascading, no per-directory overrides, and no global config. The pattern matching differs in subtle ways too: gitignore automatically prepends <code class="language-plaintext highlighter-rouge">**/</code> to unanchored patterns so they match at any depth, while Docker’s implementation (using Go’s <code class="language-plaintext highlighter-rouge">filepath.Match</code> under the hood) doesn’t do the same implicit anchoring. The <code class="language-plaintext highlighter-rouge">@balena/dockerignore</code> npm package has good documentation on these differences.</p>\n\n<p>npm’s is interesting because of its inverted relationship with <code class="language-plaintext highlighter-rouge">package.json</code>. You can use a <code class="language-plaintext highlighter-rouge">files</code> array in <code class="language-plaintext highlighter-rouge">package.json</code> to allowlist instead of blocklist, and if you do, <code class="language-plaintext highlighter-rouge">.npmignore</code> is ignored. If there’s no <code class="language-plaintext highlighter-rouge">.npmignore</code> at all, npm falls back to <code class="language-plaintext highlighter-rouge">.gitignore</code>, which catches people out when they publish packages and find that their <code class="language-plaintext highlighter-rouge">dist/</code> directory was excluded because gitignore told npm to skip it. Running <code class="language-plaintext highlighter-rouge">npm pack --dry-run</code> before publishing shows you exactly which files would be included, which would have saved me hours the first time I hit this.</p>\n\n<p>Mercurial’s <code class="language-plaintext highlighter-rouge">.hgignore</code> is more powerful than gitignore. It lets you choose your syntax per section with <code class="language-plaintext highlighter-rouge">syntax: glob</code> or <code class="language-plaintext highlighter-rouge">syntax: regexp</code>, and you can combine both in the same file, switching between them as needed. Glob patterns for the simple stuff, a regex for that one weird build artifact naming scheme, all in one file. It’s the only ignore file I know of that gives you regex, and the ability to mix syntaxes is something git never adopted.</p>\n\n<h3 id="uses-gitignore-syntax">“Uses gitignore syntax”</h3>\n\n<p>Most tools say “uses gitignore syntax” in their docs. What they usually mean is: glob patterns, one per line, <code class="language-plaintext highlighter-rouge">#</code> for comments, maybe <code class="language-plaintext highlighter-rouge">!</code> for negation. That’s a reasonable subset, but the differences bite you when you assume full compatibility.</p>\n\n<p>Some don’t support negation at all, some don’t support comments, and some treat <code class="language-plaintext highlighter-rouge">*</code> as matching directory separators while others don’t. Doublestar <code class="language-plaintext highlighter-rouge">**</code> is supported by most but not all, and trailing <code class="language-plaintext highlighter-rouge">/</code> for directory-only matching varies enough between tools that you can’t assume it works the same way everywhere.</p>\n\n<p>The underlying cause is implementation diversity. Tools using Go’s <code class="language-plaintext highlighter-rouge">filepath.Match</code> get different behavior from tools using the <code class="language-plaintext highlighter-rouge">ignore</code> npm package, which get different behavior from tools using Python’s <code class="language-plaintext highlighter-rouge">pathspec</code> library, which get different behavior from tools calling out to git’s own matching code. Each reimplementation makes slightly different choices about edge cases, and the gitignore spec is informal enough that these choices are all defensible. This is exactly what I ran into with go-git: it’s a mature, widely-used library, and its gitignore implementation still doesn’t handle unanchored patterns correctly in nested directories.</p>\n\n<p>A proper compatibility matrix across all these tools (supports negation? comments? doublestar? directory-only matching? cascading?) would be useful reference material. I haven’t found one, and writing it would mean empirically testing each tool rather than trusting their docs. Create a test fixture directory with files designed to probe each feature, write the ignore file, run the operation, and see what actually gets included. The tricky part is that each tool’s operation is different: <code class="language-plaintext highlighter-rouge">npm pack --dry-run</code>, <code class="language-plaintext highlighter-rouge">docker build</code>, <code class="language-plaintext highlighter-rouge">git status</code>, <code class="language-plaintext highlighter-rouge">eslint .</code>. You’d need per-tool test harnesses.</p>\n\n<h3 id="commonignore">CommonIgnore</h3>\n\n<p>One corner of the ecosystem actually tried to consolidate rather than adding yet another format. ripgrep and the silver searcher (ag) both deprecated their tool-specific ignore files (<code class="language-plaintext highlighter-rouge">.rgignore</code> and <code class="language-plaintext highlighter-rouge">.agignore</code>) in favor of a shared <code class="language-plaintext highlighter-rouge">.ignore</code> file. ripgrep’s precedence chain is <code class="language-plaintext highlighter-rouge">.gitignore</code> then <code class="language-plaintext highlighter-rouge">.ignore</code> then <code class="language-plaintext highlighter-rouge">.rgignore</code>, with each layer overriding the previous. BurntSushi extracted the matching logic into the <a href="https://crates.io/crates/ignore"><code class="language-plaintext highlighter-rouge">ignore</code></a> crate (part of the ripgrep monorepo, 91M+ downloads), and other tools like <code class="language-plaintext highlighter-rouge">fd</code> picked it up too. It’s tool-agnostic by convention rather than by any formal standard, but it’s the closest anyone has come to sharing an ignore format across tools.</p>\n\n<p>Markdown had a similar problem for years. Every tool claimed to support “Markdown” but each implemented a slightly different dialect, with different rules for edge cases around nesting, link parsing, and emphasis. <a href="https://commonmark.org/">CommonMark</a> fixed this by writing an unambiguous formal spec with hundreds of examples that serve as a test suite. Now tools can test their parser against the spec rather than guessing at intent, and users can rely on consistent behavior across implementations.</p>\n\n<p>It’s not hard to imagine something similar for ignore files. Git’s <a href="https://git-scm.com/docs/gitignore">documentation</a> describes the behavior in prose, which leaves room for interpretation on things like how <code class="language-plaintext highlighter-rouge">*</code> interacts with <code class="language-plaintext highlighter-rouge">/</code>, whether <code class="language-plaintext highlighter-rouge">**</code> must be surrounded by separators, and what happens when bracket ranges span from uppercase to lowercase. A formal spec with a shared test suite could let tool authors say “we implement level 1” (basic globs and comments) or “level 2” (add negation and doublestar) rather than the current vague gesture at gitignore compatibility. The <a href="https://github.com/git/git/blob/master/t/t3070-wildmatch.sh">wildmatch test cases</a> in git’s own test suite are a starting point, but they only cover pattern matching, not the layering, anchoring, and directory semantics that trip up most implementations.</p>'}

---

*抓取时间: 2026-02-13 06:03:02*
