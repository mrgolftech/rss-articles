# Instruction decoding in the Intel 8087 floating-point chip

**来源:** [righto.com](https://righto.com)
**发布时间:** 2026-02-14T08:48:00.000-08:00
**链接:** http://www.righto.com/2026/02/8087-instruction-decoding.html

---

{'type': 'text/html', 'language': None, 'base': 'https://www.righto.com/feeds/posts/default', 'value': 'In the 1980s, if you wanted your IBM PC to run faster, you could buy\nthe Intel 8087 floating-point coprocessor chip.\nWith this chip, CAD software, spreadsheets, flight simulators, and other programs\nwere much speedier.\nThe 8087 chip could add, subtract, multiply, and divide, of course, but it could\nalso compute\ntranscendental functions such as tangent and logarithms, as well as provide\nconstants such as &pi;.\nIn total, the 8087 added 62 new instructions to the computer.</p>\n<p>But how does a PC decide if an instruction was\na floating-point instruction for the 8087 or a regular instruction for the 8086 or 8088 CPU?\nAnd how does the 8087 chip interpret instructions to determine what they mean?\nIt turns out that decoding an instruction inside the 8087 is more complicated than you might expect.\nThe 8087 uses multiple techniques, with decoding circuitry spread across the chip.\nIn this blog post, I\'ll explain how these decoding circuits work.</p>\n<p>To reverse-engineer the 8087, I chiseled open the ceramic package of an 8087 chip and took numerous photos of the silicon die with a microscope.\nThe complex patterns on the die are formed by its metal wiring, as well as the polysilicon and silicon underneath.\nThe bottom half of the chip is the "datapath", the circuitry that performs calculations on 80-bit floating point values. \nAt the left of the datapath, a <a href="https://www.righto.com/2020/05/extracting-rom-constants-from-8087-math.html">constant ROM</a> holds important constants such as &pi;.\nAt the right are the eight registers that the\nprogrammer uses to hold floating-point values; in an unusual design decision,\nthese registers are arranged as a <a href="https://www.righto.com/2025/12/8087-stack-circuitry.html">stack</a>.\nFloating-point numbers cover a huge range by representing numbers with a fractional part and an exponent;\nthe 8087 has separate circuitry to process the fractional part and the exponent.</p>\n<p><a href="https://static.righto.com/images/8087-decode/8087-die-labeled.jpg"><img alt="Die of the Intel 8087 floating point unit chip, with main functional blocks labeled. The die is 5 mm&times;6 mm. Click this image (or any others) for a larger image." class="hilite" height="587" src="https://static.righto.com/images/8087-decode/8087-die-labeled-w450.jpg" title="Die of the Intel 8087 floating point unit chip, with main functional blocks labeled. The die is 5 mm&times;6 mm. Click this image (or any others) for a larger image." width="450" /></a><div class="cite">Die of the Intel 8087 floating point unit chip, with main functional blocks labeled. The die is 5 mm&times;6 mm. Click this image (or any others) for a larger image.</div></p>\n<p>The chip\'s instructions are defined by the large <a href="https://www.righto.com/2018/09/two-bits-per-transistor-high-density.html">microcode ROM</a> in the middle.<span id="fnref:microcode"><a class="ref" href="https://www.righto.com/feeds/posts/default#fn:microcode">1</a></span>\nTo execute an instruction, the 8087 decodes the instruction and the microcode engine starts executing\nthe appropriate micro-instructions from the microcode ROM.\nIn the upper right part of the chip, the Bus Interface Unit (BIU) communicates with the\nmain processor and memory over the computer\'s bus. \nFor the most part, the BIU and the rest of the chip operate independently,\nbut as we will see, the BIU plays important roles in instruction decoding and execution.</p>\n<h2>Cooperation with the main 8086/8088 processor</h2>\n<p>The 8087 chip acted as a coprocessor with the main 8086 (or 8088) processor. When a floating-point instruction was encountered,\nthe 8086 would let the 8087 floating-point chip carry out the floating-point instruction.\nBut how do the 8086 and the 8087 determine which chip executes a particular instruction?\nYou might expect the 8086 to tell the 8087 when it should execute an instruction, but\nthis cooperation turns out to be more\ncomplicated.</p>\n<p>The 8086 has eight opcodes that are assigned to the coprocessor, called <code>ESCAPE</code> opcodes.\nThe 8087 determines what instruction the 8086 is executing by watching the bus,\na task performed by the BIU (Bus Interface Unit).<span id="fnref:queue"><a class="ref" href="https://www.righto.com/feeds/posts/default#fn:queue">2</a></span>\nIf the instruction is an <code>ESCAPE</code>, the instruction is intended for the 8087.\nHowever, there\'s a problem. The 8087 doesn\'t have any access to the 8086\'s registers (and vice versa), so the only way\nthat they can exchange data is through memory.\nBut the 8086 addresses memory through a complicated scheme involving offsest registers and segment registers.\nHow can the 8087 determine what memory address to use when it doesn\'t have access to the registers?</p>\n<p>The trick is that when an <code>ESCAPE</code> instruction is encountered,\nthe 8086 processor starts executing the instruction, even though it is intended for the 8087.\nThe 8086 computes the memory address that the instruction references and\nreads that memory address, but ignores the result.\nMeanwhile, the 8087 watches the memory bus to see what address is accessed and stores this address internally in a BIU register.\nWhen the 8087 starts executing the instruction, it uses the address from the 8086 to read and write\nmemory.\nIn effect, the 8087 offloads address computation to the 8086 processor.</p>\n<h2>The structure of 8087 instructions</h2>\n<p>To understand the 8087\'s instructions, we need to take a closer look at the structure of 8086\ninstructions. In particular, something called the ModR/M byte is important since all 8087 instructions\nuse it.</p>\n<p>The 8086 uses a complex system of opcodes with a mixture of single-byte opcodes, prefix bytes, and longer instructions.\nAbout a quarter of the opcodes use a second byte, called ModR/M,\nthat specifies the registers and/or memory address\nto use through a complicated encoding.\nFor instance, the memory address can be computed by adding the BX and SI registers, or from the BP register plus a two-byte offset.\nThe first two bits of the ModR/M byte are the "MOD" bits. For a memory access, the MOD bits indicate\nhow many address displacement bytes follow the ModR/M byte (0, 1, or 2), while\nthe "R/M" bits specify how the address is computed.\nA MOD value of 3, however, indicates that the instruction operates on registers and does\nnot access memory.</p>\n<p><a href="https://static.righto.com/images/8087-decode/modrm.jpg"><img alt="Structure of an 8087 instruction" class="hilite" height="122" src="https://static.righto.com/images/8087-decode/modrm-w600.jpg" title="Structure of an 8087 instruction" width="600" /></a><div class="cite">Structure of an 8087 instruction</div></p>\n<p>The diagram above shows how an 8087 instruction consists of an <code>ESCAPE</code> opcode, followed by\na ModR/M byte.\nAn <code>ESCAPE</code> opcode is indicated by the special bit pattern <code>11011</code>, leaving three bits (green) available\nin the first byte to specify the type of 8087 instruction.\nAs mentioned above, the ModR/M byte has two forms.\nThe first form performs a memory access; it has MOD bits of <code>00</code>,<code>01</code>, or <code>10</code> and the R/M bits\nspecify how the memory address is computed. This leaves three bits (green) to specify the address.\nThe second form operates internally, without a memory access; it has MOD bits of <code>11</code>.\nSince the R/M bits aren\'t used in the second form, six bits (green) are available in the R/M byte\nto specify the instruction.</p>\n<p>The challenge for the designers of the 8087 was to fit all the instructions into the available bits\nin such a way that decoding is straightforward.\nThe diagram below shows a few 8087 instructions, illustrating how they achieve this.\nThe first three instructions operate internally, so they have MOD bits of 11; the green\nbits specify the particular instruction.\nAddition is more complicated because it can act on memory (first format) or registers (second format), depending on the <code>MOD</code> bits.\nThe four bits highlighted in bright green (<code>0000</code>) are the same for all <code>ADD</code> instructions;\nthe subtract, multiplication, and division instructions use the same structure but have\ndifferent values for\nthe dark green bits. For instance, <code>0001</code> indicates multiplication and <code>0100</code> indicates subtraction.\nThe other green bits (<code>MF</code>, <code>d</code>, and <code>P</code>) select variants of the addition instruction,\nchanging the data format, direction, and popping the stack at the end.\nThe last three bits select the R/M addressing mode for a memory operation, or the stack register\n<code>ST(i)</code> for a register operation.</p>\n<p><a href="https://static.righto.com/images/8087-decode/opcodes.jpg"><img alt="The bit patterns for some 8087 instructions. Based on the datasheet." class="hilite" height="200" src="https://static.righto.com/images/8087-decode/opcodes-w500.jpg" title="The bit patterns for some 8087 instructions. Based on the datasheet." width="500" /></a><div class="cite">The bit patterns for some 8087 instructions. Based on the <a href="https://datasheets.chipdb.org/Intel/x86/808x/datashts/8087/205835-007.pdf#page=20">datasheet</a>.</div></p>\n<h2>Selecting a microcode routine</h2>\n<p>Most of the 8087\'s instructions are implemented in microcode, implementing each step of\nan instruction in low-level "micro-instructions".\nThe 8087 chip contains a microcode engine; you can think of it as the mini-CPU\nthat controls the 8087 by executing a microcode routine, one micro-instruction at a time.\nThe microcode engine provides an 11-bit micro-address to the ROM, specifying the micro-instruction\nto execute.\nNormally, the microcode engine steps through the microcode sequentially, but it also supports conditional\njumps and subroutine calls.</p>\n<p>But how does the microcode engine know where to start executing the microcode for a particular machine instruction? \nConceptually, you could feed the instruction opcode into a ROM that would provide the starting micro-address.\nHowever, this would be impractical since you\'d need a 2048-word ROM to decode an 11-bit opcode.<span id="fnref:opcode"><a class="ref" href="https://www.righto.com/feeds/posts/default#fn:opcode">3</a></span>\n(While a 2K ROM is small nowadays, it was large at the time; the 8087\'s microcode ROM\nwas a tight fit at just 1648 words.)\nInstead, the 8087 uses a more efficient (but complicated) instruction decode system constructed from a combination of logic gates and\nPLAs (Programmable Logic Arrays).\nThis system holds 22 microcode entry points, much more practical than 2048.</p>\n<p>Processors often use a circuit called a PLA (Programmable Logic Array) as part of instruction decoding.\nThe idea of a PLA is to provide a dense and flexible way of implementing arbitrary logic functions.\nAny Boolean logic function can be expressed as a "sum-of-products", a collection of AND terms (products) that are OR\'d together (summed).\nA PLA has a block of circuitry called the AND plane that generates the desired sum terms.\nThe outputs of the AND plane are fed into a second block, the OR plane, which ORs the terms together.\nPhysically, a PLA is implemented as a grid, where each spot in the grid can either have a\ntransistor or not.\nBy changing the transistor pattern, the PLA implements the desired function.</p>\n<p><a href="https://static.righto.com/images/8087-decode/pla-structure.jpg"><img alt="A simplified diagram of a PLA." class="hilite" height="269" src="https://static.righto.com/images/8087-decode/pla-structure-w350.jpg" title="A simplified diagram of a PLA." width="350" /></a><div class="cite">A simplified diagram of a PLA.</div></p>\n<p>A PLA can implement arbitrary logic, but in the 8087, PLAs often act as optimized\nROMs.<span id="fnref:rom"><a class="ref" href="https://www.righto.com/feeds/posts/default#fn:rom">4</a></span> The AND plane matches bit patterns,<span id="fnref:matching"><a class="ref" href="https://www.righto.com/feeds/posts/default#fn:matching">5</a></span> selecting an entry from the OR plane, which\nholds the output values, the micro-address for each routine.\nThe advantage of the PLA over a standard ROM is that one output column can be used for many different inputs, reducing the size.</p>\n<p>The image below shows part of the instruction decoding PLA.<span id="fnref:pla-layout"><a class="ref" href="https://www.righto.com/feeds/posts/default#fn:pla-layout">6</a></span>\nThe horizontal input lines are polysilicon wires on top of the silicon.\nThe pinkish regions are doped silicon.\nWhen polysilicon crosses doped silicon, it creates a transistor (green).\nWhere there is a gap in the doped silicon, there is no transistor (red).\n(The output wires run vertically, but are not visible here;\nI dissolved the metal layer to show the silicon underneath.)\nIf a polysilicon line is energized, it turns on all the transistors in its row, pulling\nthe associated output columns to ground. (If no transistors are turned on, the pull-up transistor\npulls the output high.)\nThus, the pattern of doped silicon regions creates a grid of transistors in the PLA that\nimplements the desired logic function.<span id="fnref:nor"><a class="ref" href="https://www.righto.com/feeds/posts/default#fn:nor">7</a></span></p>\n<p><a href="https://static.righto.com/images/8087-decode/pla-diagram.jpg"><img alt="Part of the PLA for instruction decoding." class="hilite" height="231" src="https://static.righto.com/images/8087-decode/pla-diagram-w300.jpg" title="Part of the PLA for instruction decoding." width="300" /></a><div class="cite">Part of the PLA for instruction decoding.</div></p>\n<p>The standard way to decode instructions with a PLA is to take the instruction bits (and their complements) as inputs.\nThe PLA can then pattern-match against bit patterns in the instruction.\nHowever, the 8087 also uses some pre-processing to reduce the size of the PLA.\nFor instance, the <code>MOD</code> bits are processed to generate a signal if the bits are 0, 1, or 2 (i.e.\na memory operation) and a second signal if the bits are 3 (i.e. a register operation).\nThis allows the 0, 1, and 2 cases to be handled by a single PLA pattern.\nAnother signal indicates that the top bits are <code>001 111xxxxx</code>; this indicates that the R/M field\ntakes part in instruction selection.<span id="fnref:table"><a class="ref" href="https://www.righto.com/feeds/posts/default#fn:table">8</a></span>\nSometimes a PLA output is fed back in as an input, so a decoded group of instructions can be\nexcluded from another group.\nThese techniques all reduce the size of the PLA at the cost of some additional logic gates.</p>\n<p>The result of the instruction decoding PLA\'s AND plane is 22 signals, where each signal\ncorresponds to an\ninstruction or group of instructions with a shared microcode entry point.\nThe lower part of the instruction decoding PLA acts as a ROM that holds the 22 microcode entry points\nand provides the selected one.<span id="fnref:entry-points"><a class="ref" href="https://www.righto.com/feeds/posts/default#fn:entry-points">9</a></span></p>\n<h2>Instruction decoding inside the microcode</h2>\n<p>Many 8087 instructions share the same microcode routines. For instance, \nthe addition, subtraction, multiplication, division, reverse subtraction, and reverse division instructions all go to the same microcode routine.\nThis reduces the size of the microcode since these instructions share the microcode that sets up the instruction and handles the\nresult.\nHowever, the microcode obviously needs to diverge at some point to perform the specific operation.\nMoreover, some arithmetic opcodes access the top of the stack, some access an arbitrary location in the stack, some access memory, and some reverse the operands, requiring\ndifferent microcode actions.\nHow does the microcode do different things for different opcodes while sharing code?</p>\n<p>The trick is that the 8087\'s microcode engine supports conditional subroutine calls, returns, and jumps, based on 49 different\nconditions (<a href="https://www.righto.com/2025/12/8087-microcode-conditions.html">details</a>).\nIn particular, fifteen conditions examine the instruction.\nSome conditions test specific bit patterns, such as branching if the lowest bit is set, or more complex patterns such as\nan opcode matching <code>0xx 11xxxxxx</code>. Other conditions detect specific instructions such as <code>FMUL</code>.\nThe result is that the microcode can take different paths for different instructions. For instance, a reverse subtraction or\nreverse division is implemented in the microcode by testing the instruction and reversing the arguments if necessary, while sharing the rest of the code.</p>\n<p>The microcode also has a special jump target that performs a three-way jump depending on the\ncurrent machine instruction that is being executed.\nThe microcode engine has a jump ROM that holds 22 entry points for jumps or subroutine calls.<span id="fnref:jump"><a class="ref" href="https://www.righto.com/feeds/posts/default#fn:jump">10</a></span>\nHowever, a jump to target 0 uses special circuitry so it will instead jump to\ntarget 1\nfor a multiplication instruction,\ntarget 2 for an addition/subtraction, or\ntarget 3 for division.\nThis special jump is implemented by gates in the upper right corner of the jump decoder.</p>\n<p><a href="https://static.righto.com/images/8087-decode/jump-rom.jpg"><img alt="The jump decoder and ROM. Note that the rows are not in numerical order; presumably, this made the layout slightly more compact. Click this image (or any other) for a larger version." class="hilite" height="315" src="https://static.righto.com/images/8087-decode/jump-rom-w700.jpg" title="The jump decoder and ROM. Note that the rows are not in numerical order; presumably, this made the layout slightly more compact. Click this image (or any other) for a larger version." width="700" /></a><div class="cite">The jump decoder and ROM. Note that the rows are not in numerical order; presumably, this made the layout slightly more compact. Click this image (or any other) for a larger version.</div></p>\n<h2>Hardwired instruction handling</h2>\n<p>Some of the 8087\'s instructions are implemented directly by hardware in the Bus Interface Unit (BIU), rather than using microcode.\nFor example, instructions to enable or disable interrupts, or to save or restore state are implemented in hardware.\nThe decoding for these instructions is performed by separate circuitry from the instruction decoder described above.</p>\n<p>In the first step, a small PLA decodes the top 5 bits of the instruction.\nMost importantly, if these bits are <code>11011</code>, it indicates an ESCAPE instruction, the start of\nan 8087 operation. This causes the 8087 to start interpreting the instruction and stores\nthe opcode in a BIU register for use\nby the instruction decoder.\nA second small PLA takes the outputs from the top-5 PLA and combines them with the lower three bits.\nIt decodes specific instruction values:\n<code>D9</code>, <code>DB</code>, <code>DD</code>, <code>E0</code>, <code>E1</code>, <code>E2</code>, or <code>E3</code>.\nThe first three values correspond to specific ESCAPE instructions,\nand are recorded in latches.</p>\n<p>The two PLAs decode the second byte in the same way.\nLogic gates combine the PLA outputs from the second byte with the latched values from the first byte,\ndetecting eleven hardwired instructions.<span id="fnref:control"><a class="ref" href="https://www.righto.com/feeds/posts/default#fn:control">11</a></span>\nSome of these instructions operate directly on registers, such as clearing exceptions;\nthe decoded instruction signal \ngoes to the relevant register and modifies it in an ad hoc way. <span id="fnref:fclex"><a class="ref" href="https://www.righto.com/feeds/posts/default#fn:fclex">12</a></span>.\nOther hardwired instructions are more complicated, writing chip state to memory or reading chip state from memory.\nThese instructions require multiple memory operations, controlled by the Bus Interface Unit\'s state machine.\nEach of these instructions has a flip-flop that is triggered by the decoded instruction to keep track of which instruction is active.</p>\n<p>For the instructions that save and restore the 8087\'s state (<code>FSAVE</code> and <code>FRSTOR</code>), there\'s one more complication.\nThese instructions are partially implemented in the BIU, which moves the relevant BIU registers to or from memory.\nBut then, instruction processing switches to microcode, where a microcode routine saves\nor loads the floating-point registers. \nJumping to the microcode routine is not implemented through the regular microcode jump circuitry.\nInstead, two hardcoded values force the microcode address to the save or restore routine.<span id="fnref:save"><a class="ref" href="https://www.righto.com/feeds/posts/default#fn:save">13</a></span></p>\n<h2>Constants</h2>\n<p>The 8087 has seven instructions to load floating-point constants such as &pi;, 1, or log<sub>10</sub>(2). \nThe 8087 has a constant ROM that holds these constants, as well as constants for transcendental\noperations.\nYou might expect that the 8087 simply loads the specified constant from the constant ROM, using\nthe instruction to select the desired constant.\nHowever, the process is much more complicated.<span id="fnref:constants"><a class="ref" href="https://www.righto.com/feeds/posts/default#fn:constants">14</a></span></p>\n<p>Looking at the instruction decode ROM shows that different constants are implemented with different\nmicrocode routines: the constant-loading instructions <code>FLDLG2</code> and <code>FLDLN2</code> have one entry\npoint; <code>FLD1</code>, <code>FLD2E</code>, <code>FLDL2T</code>, and <code>FLDPI</code> have a second entry point, and <code>FLDZ</code> (zero) has a third entry point.\nIt\'s understandable that zero is a special case, but why are there two routines for the other constants?</p>\n<p>The explanation is that the fraction part of each constant is stored in the constant ROM, but the\nexponent is stored in a separate, smaller ROM.\nTo reduce the size of the exponent ROM, only some of the necessary exponents are stored.\nIf a constant needs an exponent one larger than a value in the ROM, the microcode adds one to the\nexponent ROM value, computing the exponent on the fly.</p>\n<p>Thus, the load-constant instructions use three separate instruction decoding mechanisms.\nFirst, the instruction decode ROM determines the appropriate microcode routine for the constant\ninstruction, as before.\nThen, the constant PLA decodes the instruction to select the appropriate constant.\nFinally, the microcode routine tests the bottom bit of the instruction and increments the\nexponent if necessary.</p>\n<h2>Conclusions</h2>\n<p>To wrap up the discussion of the decoding circuitry, the diagram below shows how the\ndifferent circuits are arranged on the die. This image shows the upper-right part of the die;\nthe microcode engine is at the left and part of the ROM is at the bottom.</p>\n<p><a href="https://static.righto.com/images/8087-decode/decoding-labeled.jpg"><img alt="The upper-left portion of the 8087 die, with functional blocks labeled." class="hilite" height="447" src="https://static.righto.com/images/8087-decode/decoding-labeled-w600.jpg" title="The upper-left portion of the 8087 die, with functional blocks labeled." width="600" /></a><div class="cite">The upper-left portion of the 8087 die, with functional blocks labeled.</div></p>\n<p>The 8087 doesn\'t have a clean architecture, but instead is full of ad hoc circuits and corner\ncases.\nThe 8087\'s instruction decoding is an example of this.\nDecoding is complicated to start with due to the 8086\'s convoluted instruction\nformats and the ModR/M byte.\nOn top of that, the 8087\'s instruction decoding has multiple layers: the instruction decode PLA,\nmicrocode conditional jumps that depend on the instruction, a special jump target that\ndepends on the instruction,\nconstants selected based on the instruction, and instructions decoded by the BIU.</p>\n<p>The 8087 has a reason for this complicated architecture: at the time, the chip was on the\nedge of what was possible, so the designers needed to use whatever techniques they could to\nreduce the size of the chip. If implementing a corner case could shave a few transistors off the\nchip or make the microcode ROM slightly smaller, the corner case was worthwhile.\nEven so, the 8087 was barely manufacturable at first; early yield was just two working chips\nper silicon wafer.\nDespite this difficult start, a floating-point standard based on the 8087 is now part of almost every processor.</p>\n<p>Thanks to the members of the "Opcode Collective" for their contributions, especially Smartest Blob and Gloriouscow.</p>\n<p>For updates, follow me on\n Bluesky (<a href="https://bsky.app/profile/righto.com">@righto.com</a>),\nMastodon (<a href="https://oldbytes.space/@kenshirriff">@kenshirriff@oldbytes.space</a>),\nor <a href="http://www.righto.com/feeds/posts/default">RSS</a>.</p>\n<h2>Notes and references</h2>\n<div class="footnote">\n<ol>\n<li id="fn:microcode">\n<p>The contents of the microcode ROM are available <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt">here</a>, partially decoded thanks to Smartest Blob.&#160;<a class="footnote-backref" href="https://www.righto.com/feeds/posts/default#fnref:microcode" title="Jump back to footnote 1 in the text">&#8617;</a></p>\n</li>\n<li id="fn:queue">\n<p>It is difficult for the 8087 to determine what the 8086 is doing because the 8086 prefetches\ninstructions. Thus, when an instruction is seen on the bus, the 8086 may execute it at some\npoint in the future, or it may end up discarded.</p>\n<p>In order to tell what instruction is being executed, the 8087 floating-point chip internally duplicates the 8086 processor\'s queue.\nThe 8087 watches the memory bus and copies any instructions that are prefetched.\nSince the 8087 can\'t tell from the bus when the 8086 starts a new instruction or when the 8086 empties the queue when jumping to a new address,\nthe 8086 processor provides two queue status signals to the 8087.\nWith the help of these signals, the 8087 knows exactly what the 8086 is executing.</p>\n<p>The 8087\'s instruction queue has six 8-bit registers, the same as the 8086.\nSurprisingly, the last two queue registers in the 8087 are tied together, so there are\nonly five usable queue registers.\nMy hypothesis is that since the 8087 copies the active instruction into separate registers\n(unlike the 8086), only five queue registers are needed. This raises the question of\nwhy the excess register wasn\'t removed from the die, rather than wasting valuable space.</p>\n<p>The 8088 processor, used in the IBM PC, has a four-byte queue instead of a six-byte queue. The 8088 is almost identical to the 8086\nexcept it has an 8-bit memory bus instead of a 16-bit memory bus. With the narrower memory bus, prefetching is more likely to get in\nthe way of other memory accesses, so a smaller prefetch queue was implemented.</p>\n<p>Knowing the queue size is essential to the 8087 floating-point chip.\nTo indicate this, when the processor boots, a signal lets the 8087 determine if the attached processor is\nan 8086 or an 8088.&#160;<a class="footnote-backref" href="https://www.righto.com/feeds/posts/default#fnref:queue" title="Jump back to footnote 2 in the text">&#8617;</a></p>\n</li>\n<li id="fn:opcode">\n<p>The relevant part of the opcode is 11 bits:\nthe top 5 bits are always\n<code>11011</code> for an <code>ESCAPE</code> opcode, so they can be ignored during decoding.\nThe Bus Interface Unit has a 3-bit register to hold the\nfirst byte of the instruction and an 8-bit register to hold the second byte.\nThe BIU registers have an irregular appearance because there are 3-bit registers, 8-bit\nregisters, and 10-bit registers (holding half of a 20-bit address).&#160;<a class="footnote-backref" href="https://www.righto.com/feeds/posts/default#fnref:opcode" title="Jump back to footnote 3 in the text">&#8617;</a></p>\n</li>\n<li id="fn:rom">\n<p>What\'s the difference between a PLA and a ROM?\nThere is a lot of overlap: a ROM can replace a PLA, while a PLA can implement a ROM.\nA ROM is essentially a PLA where the first stage is a binary decoder, so the ROM\nhas a separate row for each input value.\nHowever, the first stage of a ROM can be optimized so multiple inputs share the same output value;\nis this a ROM or a PLA?</p>\n<p>The "official" difference is that in a ROM, one row is activated at a time, while in a PLA,\nmultiple rows can be activated at once, so the output values are combined.\n(Thus, it is straightforward to read the values out of a ROM, but more difficult to read\nthe values out of a PLA.)</p>\n<p>I consider the instruction decoding PLA to be best described as a PLA first stage with the\nsecond stage acting as a ROM.\nYou could also call it a partially-decoded ROM, or just a PLA.\nHopefully my terminology isn\'t too confusing.&#160;<a class="footnote-backref" href="https://www.righto.com/feeds/posts/default#fnref:rom" title="Jump back to footnote 4 in the text">&#8617;</a></p>\n</li>\n<li id="fn:matching">\n<p>To match a bit pattern in an instruction, \nthe bits of the instruction are fed into the PLA, along with the complements of these bits; this allows the PLA to match against a 0\nbit or a 1 bit.\nEach row of a PLA will match a particular bit pattern in the instruction: bits that must be 1, bits that must be 0, and bits that don\'t matter.\nIf the instruction opcodes are assigned rationally, a small number of bit patterns will match all the opcodes, reducing the size of the\ndecoder.</p>\n<p>I may be going too far with this analogy, but a PLA is a lot like a neural net. Each column in the AND plane is like a\nneuron that fires when it recognizes a particular input pattern.\nThe OR plane is like a second layer in a neural net, combining signals from the first layer.\nThe PLA\'s "weights", however, are fixed at 0 or 1, so it\'s not as flexible as a "real" neural net.&#160;<a class="footnote-backref" href="https://www.righto.com/feeds/posts/default#fnref:matching" title="Jump back to footnote 5 in the text">&#8617;</a></p>\n</li>\n<li id="fn:pla-layout">\n<p>The instruction decoding PLA has an unusual layout, where the second plane is rotated 90&deg;.\nIn a regular PLA (left), the inputs (red) go into the first plane, the perpendicular outputs from the first plane (purple) go into the second plane,\nand the PLA outputs (blue) exit parallel to the inputs.\nIn the address PLA, however, the second plane is rotated 90&deg;, so the outputs are perpendicular to the inputs.\nThis approach requires additional wiring (horizontal purple lines), but presumably, this layout worked better in the 8087 since the outputs are lined up with the rest of the microcode engine.</p>\n<p><a href="https://static.righto.com/images/8087-decode/folded.jpg"><img alt="Conceptual diagram of a regular PLA on the left and a rotated PLA on the right." class="hilite" height="265" src="https://static.righto.com/images/8087-decode/folded-w350.jpg" title="Conceptual diagram of a regular PLA on the left and a rotated PLA on the right." width="350" /></a><div class="cite">Conceptual diagram of a regular PLA on the left and a rotated PLA on the right.</div></p>\n<p><!-- -->&#160;<a class="footnote-backref" href="https://www.righto.com/feeds/posts/default#fnref:pla-layout" title="Jump back to footnote 6 in the text">&#8617;</a></p>\n</li>\n<li id="fn:nor">\n<p>To describe the implementation of a PLA in more detail, the transistors in each row of the AND plane form a NOR gate, since if any transistor is turned on, it pulls the output low.\n Likewise, the transistors in each column of the OR plane form a NOR gate.\n So why is the PLA described as having an AND plane and an OR plane, rather than two NOR planes?\n By using <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws">De Morgan\'s law</a>, you can treat the NOR-NOR Boolean equations as\n equivalent to AND-OR Boolean equations (with the inputs and outputs inverted).\n It\'s usually much easier to understand the logic as AND terms OR\'d together.</p>\n<p>The converse question is why don\'t they build the PLA from AND and OR gates instead of NOR gates? The reason is that AND and OR\n gates are harder to build with NMOS transistors, since you need to add explicit inverter circuits.\n Moreover, NMOS NOR gates are typically faster than NAND gates because the transistors are in parallel. (CMOS is the opposite;\n NAND gates are faster because the weaker PMOS transistors are in parallel.)&#160;<a class="footnote-backref" href="https://www.righto.com/feeds/posts/default#fnref:nor" title="Jump back to footnote 7 in the text">&#8617;</a></p>\n</li>\n<li id="fn:table">\n<p></p>\n<p>The 8087\'s opcodes can be organized into tables, showing the underlying structure.\n(In each table, the row (Y) coordinate is the bottom 3 bits of the first byte and the column (X) coordinate\nis the 3 bits after the MOD bits in the second byte.)</p>\n<p>Memory operations use the following encoding with MOD = 0, 1, or 2.\nEach box represents 8 different addressing modes.</p>\n<p><table id="op8087">\n<tr><th>&nbsp;</th>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n</tr>\n<tr><th>0</th>\n<td style="background-color: #FFD6A5;">FADD</td>\n<td style="background-color: #FDFFB6;">FMUL</td>\n<td style="background-color: #CAFFBF;">FCOM</td>\n<td style="background-color: #CAFFBF;">FCOMP</td>\n<td style="background-color: #9BF6FF;">FSUB</td>\n<td style="background-color: #9BF6FF;">FSUBR</td>\n<td style="background-color: #A0C4FF;">FDIV</td>\n<td style="background-color: #A0C4FF;">FDIVR</td>\n<tr><th>1</th>\n<td style="background-color: #BDB2FF;">FLD</td>\n<td>&nbsp;</td>\n<td style="background-color: #FFC6FF;">FST</td>\n<td style="background-color: #FFC6FF;">FSTP</td>\n<td style="background-color: yellow;">FLDENV</td>\n<td style="background-color: yellow;">FLDCW</td>\n<td style="background-color: yellow;">FSTENV</td>\n<td style="background-color: yellow;">FSTCW</td>\n<tr><th>2</th>\n<td style="background-color: #FFD6A5;">FIADD</td>\n<td style="background-color: #FDFFB6;">FIMUL</td>\n<td style="background-color: #CAFFBF;">FICOM</td>\n<td style="background-color: #CAFFBF;">FICOMP</td>\n<td style="background-color: #9BF6FF;">FISUB</td>\n<td style="background-color: #9BF6FF;">FISUBR</td>\n<td style="background-color: #A0C4FF;">FIDIV</td>\n<td style="background-color: #A0C4FF;">FIDIVR</td>\n<tr><th>3</th>\n<td style="background-color: #BDB2FF;">FILD</td>\n<td>&nbsp;</td>\n<td style="background-color: #FFC6FF;">FIST</td>\n<td style="background-color: #FFC6FF;">FISTP</td>\n<td>&nbsp;</td>\n<td style="background-color: #BDB2FF;">FLD</td>\n<td>&nbsp;</td>\n<td style="background-color: #FFC6FF;">FSTP</td>\n<tr><th>4</th>\n<td style="background-color: #FFD6A5;">FADD</td>\n<td style="background-color: #FDFFB6;">FMUL</td>\n<td style="background-color: #CAFFBF;">FCOM</td>\n<td style="background-color: #CAFFBF;">FCOMP</td>\n<td style="background-color: #9BF6FF;">FSUB</td>\n<td style="background-color: #9BF6FF;">FSUBR</td>\n<td style="background-color: #A0C4FF;">FDIV</td>\n<td style="background-color: #A0C4FF;">FDIVR</td>\n<tr><th>5</th>\n<td style="background-color: #BDB2FF;">FLD</td>\n<td>&nbsp;</td>\n<td style="background-color: #FFC6FF;">FST</td>\n<td style="background-color: #FFC6FF;">FSTP</td>\n<td style="background-color: yellow;">FRSTOR</td>\n<td>&nbsp;</td>\n<td style="background-color: yellow;">FSAVE</td>\n<td style="background-color: yellow;">FSTSW</td>\n<tr><th>6</th>\n<td style="background-color: #FFD6A5;">FIADD</td>\n<td style="background-color: #FDFFB6;">FIMUL</td>\n<td style="background-color: #CAFFBF;">FICOM</td>\n<td style="background-color: #CAFFBF;">FICOMP</td>\n<td style="background-color: #9BF6FF;">FISUB</td>\n<td style="background-color: #9BF6FF;">FISUBR</td>\n<td style="background-color: #A0C4FF;">FIDIV</td>\n<td style="background-color: #A0C4FF;">FIDIVR</td>\n<tr><th>7</th>\n<td style="background-color: #BDB2FF;">FILD</td>\n<td>&nbsp;</td>\n<td style="background-color: #FFC6FF;">FIST</td>\n<td style="background-color: #FFC6FF;">FISTP</td>\n<td style="background-color: #BDB2FF;">FBLD</td>\n<td style="background-color: #BDB2FF;">FILD</td>\n<td style="background-color: #FFC6FF;">FBSTP</td>\n<td style="background-color: #FFC6FF;">FISTP</td>\n</tr>\n</table></p>\n<p>The important point is that the instruction encoding has a lot of regularity, making the decoding\nprocess easier. For instance, the basic arithmetic operations (<code>FADD</code> through <code>FDIVR</code>) are\nrepeated on alternating rows.\nHowever, the table also has significant irregularities, which complicate the decoding process.</p>\n<p>The register operations (MOD = 3) have a related layout, but there are even more\nirregularities.</p>\n<p></p>\n<p><table id="op8087">\n<tr><th>&nbsp;</th>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n</tr>\n<tr><th>0</th>\n<td style="background-color: #FFD6A5;">FADD</td>\n<td style="background-color: #FDFFB6;">FMUL</td>\n<td style="background-color: #CAFFBF;">FCOM</td>\n<td style="background-color: #CAFFBF;">FCOMP</td>\n<td style="background-color: #9BF6FF;">FSUB</td>\n<td style="background-color: #9BF6FF;">FSUBR</td>\n<td style="background-color: #A0C4FF;">FDIV</td>\n<td style="background-color: #A0C4FF;">FDIVR</td>\n<tr><th>1</th>\n<td style="background-color: #BDB2FF;">FLD</td>\n<td style="background-color: #ECDCB0;">FXCH</td>\n<td style="background-color: #ccc;">FNOP</td>\n<td>&nbsp;</td>\n<td style="background-color: #FFADAD;">misc1</td>\n<td style="background-color: #FFADAD;">misc2</td>\n<td style="background-color: #FFADAD;">misc3</td>\n<td style="background-color: #FFADAD;">misc4</td>\n<tr><th>2</th>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<tr><th>3</th>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td style="background-color: yellow;">misc5</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<tr><th>4</th>\n<td style="background-color: #FFD6A5;">FADD</td>\n<td style="background-color: #FDFFB6;">FMUL</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td style="background-color: #9BF6FF;">FSUB</td>\n<td style="background-color: #9BF6FF;">FSUBR</td>\n<td style="background-color: #A0C4FF;">FDIV</td>\n<td style="background-color: #A0C4FF;">FDIVR</td>\n<tr><th>5</th>\n<td style="background-color: #EDDCB0;">FFREE</td>\n<td>&nbsp;</td>\n<td style="background-color: #FFC6FF;">FST</td>\n<td style="background-color: #FFC6FF;">FSTP</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<tr><th>6</th>\n<td style="background-color: #FFD6A5;">FADDP</td>\n<td style="background-color: #FDFFB6;">FMULP</td>\n<td>&nbsp;</td>\n<td style="background-color: #CAFFBF;">FCOMPP</td>\n<td style="background-color: #9BF6FF;">FSUBP</td>\n<td style="background-color: #9BF6FF;">FSUBRP</td>\n<td style="background-color: #A0C4FF;">FDIVP</td>\n<td style="background-color: #A0C4FF;">FDIVRP</td>\n<tr><th>7</th>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n</tr>\n</table></p>\n<p>In most cases, each box indicates 8 different values for the stack register, but there\nare exceptions.\nThe <code>NOP</code> and <code>FCOMPP</code> instructions each have a single opcode, "wasting" the rest of \nthe box.</p>\n<p>Five of the boxes in the table encode multiple instructions instead of the register number.\nThe first four (red) are miscellaneous instructions handled by the decoding PLA:\n<br />\nmisc1 = <code>FCHS</code>, <code>FABS</code>, <code>FTST</code>, <code>FXAM</code>\n<br />\nmisc2 = <code>FLD1</code>, <code>FLDL2T</code>, <code>FLDL2E</code>, <code>FLDPI</code>, <code>FLDLG2</code>, <code>FLDLN2</code>, <code>FLDZ</code> (the constant-loading instructions)\n<br />\nmisc3 = <code>F2XM1</code>, <code>FYL2X</code>, <code>FPTAN</code>, <code>FPATAN</code>, <code>FXTRACT</code>, <code>FDECSTP</code>, <code>FINCSTP</code>\n<br />\nmisc4 =\n<code>FPREM</code>, <code>FYL2XP1</code>, <code>FSQRT</code>, <code>FRNDINT</code>, <code>FSCALE</code></p>\n<p>The last miscellaneous box (yellow) holds instructions that are handled by the BIU.\n<br />\n<code>misc5 = FENI</code>, <code>FDISI</code>, <code>FCLEX</code>, <code>FINIT</code></p>\n<p>Curiously, the 8087\'s opcodes (like the <a href="https://web.archive.org/web/20050329195235/http://www.dabo.de/ccc99/www.camp.ccc.de/radio/help.txt">8086\'s</a>) make much more sense in octal than in\nhexadecimal.\nIn octal, an 8087 opcode is simply <code>33Y MXR</code>, where X and Y are the table coordinates above,\nM is the MOD value (0, 1, 2, or 3), and R is the R/M field or the stack register number.&#160;<a class="footnote-backref" href="https://www.righto.com/feeds/posts/default#fnref:table" title="Jump back to footnote 8 in the text">&#8617;</a></p>\n</li>\n<li id="fn:entry-points">\n<p>The 22 outputs from the instruction decoder PLA correspond to the following groups\nof instructions, activating one row of ROM and producing the corresponding microcode address.\nFrom this table, you can see which instructions are grouped together in the microcode.</p>\n<p><pre>\n 0 <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L201">#0200</a> FXCH\n 1 <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L598">#0597</a> FSTP (BCD)\n 2 <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L809">#0808</a> FCOM FCOMP FCOMPP\n 3 <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L1009">#1008</a> FLDLG2 FLDLN2\n 4 <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L1528">#1527</a> FSQRT\n 5 <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L1587">#1586</a> FPREM\n 6 <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L1139">#1138</a> FPATAN\n 7 <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L1040">#1039</a> FPTAN\n 8 <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L901">#0900</a> F2XM1\n 9 <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L1021">#1020</a> FLDZ\n10 <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L711">#0710</a> FRNDINT\n11 <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L1464">#1463</a> FDECSTP FINCSTP\n12 <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L813">#0812</a> FTST\n13 <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L893">#0892</a> FABS FCHS\n14 <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L66">#0065</a> FFREE FLD\n15 <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L218">#0217</a> FNOP FST FSTP (not BCD)\n16 <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L2">#0001</a> FADD FDIV FDIVR FMUL FSUB FSUBR\n17 <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L749">#0748</a> FSCALE\n18 <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L1029">#1028</a> FXTRACT\n19 <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L1258">#1257</a> FYL2X FYL2XP1\n20 <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L1004">#1003</a> FLD1 FLDL2E FLDL2T FLDPI\n21 <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L1469">#1468</a> FXAM\n</pre>&#160;<a class="footnote-backref" href="https://www.righto.com/feeds/posts/default#fnref:entry-points" title="Jump back to footnote 9 in the text">&#8617;</a></p>\n</li>\n<li id="fn:jump">\n<p>The instruction decoding PLA has 22 entries, and the jump table also has 22 entries.\nIt\'s a coincidence that these values are the same.</p>\n<p>An entry in the jump table ROM is selected by five bits of the micro-instruction.\nThe ROM is structured with two 11-bit words per row, interleaved. (It\'s also a coincidence that there\nare 22 bits.)\nThe upper four bits of the jump number select a row in the ROM, while the bottom bit selects\none of the two rows.</p>\n<p>This implementation is modified for target 0, the three-way jump. The first ROM row is selected\nfor target 0 if the current instruction is multiplication, or for target 1.\nThe second row is selected for target 0 if the current instruction is addition or subtraction,\nor for target 2.\nThe third row is selected for target 0 if the current instruction is division,\nor for target 3.\nThus, target 0 ends up selecting rows 1, 2, or 3.\nHowever, remember that there are two words per row, selected by the low bit of the target number.\nThe problem is that target 0 with multiplication will access the left word of row 1, while\ntarget 1 will access the right word of row 1, but both should provide the same address.\nThe solution is that rows 1, 2, and 3 have the same address stored twice in the row,\nso these rows each "waste" a value.</p>\n<p>For reference, the contents of the jump table are:\n<pre>\n 0: Jumps to target 1 for <code>FMUL</code>, 2 for <code>FADD/FSUB/FSUBR</code>, 3 for <code>FDIV/FDIVR</code>\n 1: <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L360">#0359</a>\n 2: <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L233">#0232</a>\n 3: <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L411">#0410</a>\n 4: <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L84">#0083</a>\n 5: <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L1485">#1484</a>\n 6: <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L123">#0122</a>\n 7: <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L174">#0173</a>\n 8: <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L440">#0439</a>\n 9: <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L656">#0655</a>\n10: <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L535">#0534</a>\n11: <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L300">#0299</a>\n12: <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L1573">#1572</a>\n13: <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L1447">#1446</a>\n14: <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L860">#0859</a>\n15: <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L397">#0396</a>\n16: <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L319">#0318</a>\n17: <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L381">#0380</a>\n18: <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L780">#0779</a>\n19: <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L869">#0868</a>\n20: <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L523">#0522</a>\n21: <a href="https://github.com/a-mcego/granite/blob/main/tools/8087mc/bin/8087mc_out.txt#L802">#0801</a>\n</pre>&#160;<a class="footnote-backref" href="https://www.righto.com/feeds/posts/default#fnref:jump" title="Jump back to footnote 10 in the text">&#8617;</a></p>\n</li>\n<li id="fn:control">\n<p>Eleven instructions are implemented in the BIU hardware.\nFour of these are relatively simple, setting or clearing bits:\n<code>FINIT</code> (initialize), <code>FENI</code> (enable interrupts), <code>FDISI</code> (disable interrupts),\nand <code>FCLEX</code> (clear exceptions).\nSix of these are more complicated, storing state to memory or loading state from memory:\n<code>FLDCW</code> (load control word), <code>FSTCW</code> (store control word), <code>FSTSW</code> (store status word),\n<code>FSTENV</code> (store environment),\n<code>FLDENV</code> (load environment), <code>FSAVE</code> (save state), and <code>FRSTOR</code> (restore state).\nAs explained elsewhere, the last two instructions are partially implemented in microcode.&#160;<a class="footnote-backref" href="https://www.righto.com/feeds/posts/default#fnref:control" title="Jump back to footnote 11 in the text">&#8617;</a></p>\n</li>\n<li id="fn:fclex">\n<p>Even a seemingly trivial instruction uses more circuitry than you might expect.\nFor instance, after the <code>FCLEX</code> (clear exception) instruction is decoded, the signal goes through nine gates before it clears the exception\nbits in the status register. Along the way, it goes through a flip-flop to synchronize the timing,\na gate to combine it with the reset signal, and various inverters and drivers.\nEven though these instructions seem like they should complete immediately, they typically take 5 clock cycles due to overhead in the 8087.&#160;<a class="footnote-backref" href="https://www.righto.com/feeds/posts/default#fnref:fclex" title="Jump back to footnote 12 in the text">&#8617;</a></p>\n</li>\n<li id="fn:save">\n<p>I\'ll give more details here on the circuit that jumps to the save or restore microcode.\nThe BIU sends two signals to the microcode engine, one to jump to the save code and one to\njump to the restore code.\nThese signals are buffered and delayed by a capacitor, probably to adjust the timing of the\nsignal.</p>\n<p>In the microcode engine, there are two hardcoded constants for the routines, just above\nthe jump table; the\nBIU signal causes the appropriate constant to go onto the micro-address lines.\nEach bit in the address has a pull-up transistor to +5V or a pull-down transistor to ground.\nThis approach is somewhat inefficient since it requires two transistor sites per bit. In\ncomparison, the jump address ROM and the instruction address ROM use one transistor site\nper bit.\n(As in a PLA, each transistor is present or absent as needed, so the number of physical\ntransistors is less than the number of transistor sites.)</p>\n<p><a href="https://static.righto.com/images/8087-decode/capacitors.jpg"><img alt="Two capacitors in the 8087. This photo shows the metal layer with the silicon and polysilicon underneath." class="hilite" height="250" src="https://static.righto.com/images/8087-decode/capacitors-w500.jpg" title="Two capacitors in the 8087. This photo shows the metal layer with the silicon and polysilicon underneath." width="500" /></a><div class="cite">Two capacitors in the 8087. This photo shows the metal layer with the silicon and polysilicon underneath.</div></p>\n<p>Since capacitors are somewhat unusual in NMOS circuits, I\'ll show them in the photo above.\nIf a polysilicon line crosses over doped silicon, it creates a transistor.\nHowever, if a polysilicon region sits on top of the doped silicon without crossing it, it forms a capacitor instead.\n(The capacitance exists for a transistor, too, but the gate capacitance is generally unwanted.)&#160;<a class="footnote-backref" href="https://www.righto.com/feeds/posts/default#fnref:save" title="Jump back to footnote 13 in the text">&#8617;</a></p>\n</li>\n<li id="fn:constants">\n<p>The documentation provides a hint that the microcode to load constants is complicated.\nSpecifically, the documentation shows that different constants take different amounts of\ntime to load.\nFor instance, log<sub>2</sub>(e) takes 18 cycles while log<sub>2</sub>(10) takes 19 cycles and log<sub>10</sub>(2) takes 21 cycles.\nYou\'d expect that pre-computed constants would all take the same time, so the varying times\nshow that more is happening behind the scenes.&#160;<a class="footnote-backref" href="https://www.righto.com/feeds/posts/default#fnref:constants" title="Jump back to footnote 14 in the text">&#8617;</a></p>\n</li>\n</ol>\n</div>'}

---

*抓取时间: 2026-02-18 18:04:21*
