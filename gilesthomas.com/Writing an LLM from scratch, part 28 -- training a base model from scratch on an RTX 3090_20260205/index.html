
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="技术博客文章聚合 - Hacker News 2025年最受欢迎的博客">
      
      
        <meta name="author" content="OpenClaw">
      
      
        <link rel="canonical" href="https://mrgolftech.github.io/rss-articles/gilesthomas.com/Writing%20an%20LLM%20from%20scratch%2C%20part%2028%20--%20training%20a%20base%20model%20from%20scratch%20on%20an%20RTX%203090_20260205/">
      
      
      
      
        
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.1">
    
    
      
        <title>Writing an LLM from scratch, part 28 -- training a base model from scratch on an RTX 3090 - Hacker News 精选博客</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.484c7ddc.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      
  


    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#writing-an-llm-from-scratch-part-28-training-a-base-model-from-scratch-on-an-rtx-3090" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="Hacker News 精选博客" class="md-header__button md-logo" aria-label="Hacker News 精选博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Hacker News 精选博客
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Writing an LLM from scratch, part 28 -- training a base model from scratch on an RTX 3090
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="切换到深色模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换到深色模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="切换到浅色模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换到浅色模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="分享" aria-label="分享" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/mrgolftech/rss-articles" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    rss-articles
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
  
    
  
  首页

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../blogs/" class="md-tabs__link">
        
  
  
    
  
  所有博客

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Hacker News 精选博客" class="md-nav__button md-logo" aria-label="Hacker News 精选博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Hacker News 精选博客
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/mrgolftech/rss-articles" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    rss-articles
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    首页
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../blogs/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    所有博客
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#writing-an-llm-from-scratch-part-28-training-a-base-model-from-scratch-on-an-rtx-3090_1" class="md-nav__link">
    <span class="md-ellipsis">
      
        Writing an LLM from scratch, part 28 -- training a base model from scratch on an RTX 3090
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Writing an LLM from scratch, part 28 -- training a base model from scratch on an RTX 3090">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#the-model" class="md-nav__link">
    <span class="md-ellipsis">
      
        The model
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-data" class="md-nav__link">
    <span class="md-ellipsis">
      
        The data
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#epochs" class="md-nav__link">
    <span class="md-ellipsis">
      
        Epochs
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tokens-per-second" class="md-nav__link">
    <span class="md-ellipsis">
      
        Tokens per second
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#checkpointing" class="md-nav__link">
    <span class="md-ellipsis">
      
        Checkpointing
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#validation" class="md-nav__link">
    <span class="md-ellipsis">
      
        Validation
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#datasets" class="md-nav__link">
    <span class="md-ellipsis">
      
        Datasets
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#finally-training-an-llm" class="md-nav__link">
    <span class="md-ellipsis">
      
        Finally training an LLM!
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#evals" class="md-nav__link">
    <span class="md-ellipsis">
      
        Evals
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fineweb-edu" class="md-nav__link">
    <span class="md-ellipsis">
      
        FineWeb-Edu
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#continuing-training" class="md-nav__link">
    <span class="md-ellipsis">
      
        Continuing training
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#flops" class="md-nav__link">
    <span class="md-ellipsis">
      
        FLOPs
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#but-why-is-our-model-worse-than-openais" class="md-nav__link">
    <span class="md-ellipsis">
      
        But why is our model worse than OpenAI's?
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="But why is our model worse than OpenAI&#39;s?">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#amount-of-training-data" class="md-nav__link">
    <span class="md-ellipsis">
      
        Amount of training data
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#number-of-epochs" class="md-nav__link">
    <span class="md-ellipsis">
      
        Number of epochs
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#architectural-differences" class="md-nav__link">
    <span class="md-ellipsis">
      
        Architectural differences
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dropout" class="md-nav__link">
    <span class="md-ellipsis">
      
        Dropout
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-learning-rate" class="md-nav__link">
    <span class="md-ellipsis">
      
        The learning rate
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-precision" class="md-nav__link">
    <span class="md-ellipsis">
      
        The precision
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-batch-size" class="md-nav__link">
    <span class="md-ellipsis">
      
        The batch size
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exploding-gradients" class="md-nav__link">
    <span class="md-ellipsis">
      
        Exploding gradients
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conclusion" class="md-nav__link">
    <span class="md-ellipsis">
      
        Conclusion
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  


  
    <a href="https://github.com/mrgolftech/rss-articles/edit/master/docs/gilesthomas.com/Writing an LLM from scratch, part 28 -- training a base model from scratch on an RTX 3090_20260205.md" title="编辑此页" class="md-content__button md-icon" rel="edit">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75z"/></svg>
    </a>
  
  


<h1 id="writing-an-llm-from-scratch-part-28-training-a-base-model-from-scratch-on-an-rtx-3090">Writing an LLM from scratch, part 28 -- training a base model from scratch on an RTX 3090<a class="headerlink" href="#writing-an-llm-from-scratch-part-28-training-a-base-model-from-scratch-on-an-rtx-3090" title="Permanent link">&para;</a></h1>
<p><strong>来源:</strong> https://gilesthomas.com
<strong>链接:</strong> https://www.gilesthomas.com/2025/12/llm-from-scratch-28-training-a-base-model-from-scratch
<strong>日期:</strong> Tue, 02 Dec 2025 18:15:00 +0000</p>
<hr />
<p><a href="/">Giles' blog</a></p>
<p><a href="https://x.com/gpjt"><img alt="Me on X/Twitter" src="/images/x-icon.png" /></a> <a href="https://bsky.app/profile/gilesthomas.com"><img alt="Me on Bluesky" src="/images/bluesky-icon.png" /></a> <a href="https://github.com/gpjt"><img alt="My GitHub profile" src="/images/github-icon.png" /></a> <a href="https://huggingface.co/gpjt"><img alt="My Hugging Face profile" src="/images/hf-icon.png" /></a> <a href="/feed/rss.xml"><img alt="RSS feed for this blog" src="/images/rss-icon.png" /></a></p>
<p><a href="/about">About</a></p>
<p><a href="/contact">Contact</a></p>
<p>Archives </p>
<p>Categories </p>
<p>Blogroll </p>
<ul>
<li><a href="/2026/02"> February 2026 (2) </a></li>
<li><a href="/2026/01"> January 2026 (4) </a></li>
<li><a href="/2025/12"> December 2025 (1) </a></li>
<li><a href="/2025/11"> November 2025 (3) </a></li>
<li><a href="/2025/10"> October 2025 (9) </a></li>
<li><a href="/2025/09"> September 2025 (3) </a></li>
<li><a href="/2025/08"> August 2025 (5) </a></li>
<li><a href="/2025/07"> July 2025 (1) </a></li>
<li><a href="/2025/06"> June 2025 (2) </a></li>
<li><a href="/2025/05"> May 2025 (3) </a></li>
<li><a href="/2025/04"> April 2025 (2) </a></li>
<li><a href="/2025/03"> March 2025 (7) </a></li>
<li><a href="/2025/02"> February 2025 (10) </a></li>
<li><a href="/2025/01"> January 2025 (6) </a></li>
<li><a href="/2024/12"> December 2024 (7) </a></li>
<li><a href="/2024/09"> September 2024 (1) </a></li>
<li><a href="/2024/08"> August 2024 (2) </a></li>
<li><a href="/2024/07"> July 2024 (2) </a></li>
<li><a href="/2024/05"> May 2024 (2) </a></li>
<li><a href="/2024/04"> April 2024 (2) </a></li>
<li><a href="/2024/02"> February 2024 (2) </a></li>
<li><a href="/2023/04"> April 2023 (1) </a></li>
<li><a href="/2023/03"> March 2023 (2) </a></li>
<li><a href="/2022/09"> September 2022 (1) </a></li>
<li><a href="/2022/02"> February 2022 (1) </a></li>
<li><a href="/2021/11"> November 2021 (1) </a></li>
<li><a href="/2021/03"> March 2021 (1) </a></li>
<li><a href="/2021/02"> February 2021 (2) </a></li>
<li><a href="/2019/08"> August 2019 (1) </a></li>
<li><a href="/2018/11"> November 2018 (1) </a></li>
<li><a href="/2017/05"> May 2017 (1) </a></li>
<li><a href="/2016/12"> December 2016 (1) </a></li>
<li><a href="/2016/04"> April 2016 (1) </a></li>
<li><a href="/2015/08"> August 2015 (1) </a></li>
<li><a href="/2014/12"> December 2014 (1) </a></li>
<li><a href="/2014/08"> August 2014 (1) </a></li>
<li><a href="/2014/03"> March 2014 (1) </a></li>
<li><a href="/2013/12"> December 2013 (1) </a></li>
<li><a href="/2013/10"> October 2013 (3) </a></li>
<li><a href="/2013/09"> September 2013 (4) </a></li>
<li><a href="/2013/08"> August 2013 (2) </a></li>
<li><a href="/2013/07"> July 2013 (1) </a></li>
<li><a href="/2013/06"> June 2013 (1) </a></li>
<li><a href="/2013/02"> February 2013 (1) </a></li>
<li><a href="/2012/10"> October 2012 (1) </a></li>
<li><a href="/2012/06"> June 2012 (1) </a></li>
<li><a href="/2012/05"> May 2012 (1) </a></li>
<li><a href="/2012/04"> April 2012 (1) </a></li>
<li><a href="/2012/02"> February 2012 (1) </a></li>
<li><a href="/2011/10"> October 2011 (1) </a></li>
<li><a href="/2011/06"> June 2011 (1) </a></li>
<li><a href="/2011/05"> May 2011 (1) </a></li>
<li><a href="/2011/04"> April 2011 (1) </a></li>
<li><a href="/2011/03"> March 2011 (1) </a></li>
<li><a href="/2011/02"> February 2011 (1) </a></li>
<li><a href="/2011/01"> January 2011 (1) </a></li>
<li><a href="/2010/12"> December 2010 (3) </a></li>
<li><a href="/2010/11"> November 2010 (1) </a></li>
<li><a href="/2010/10"> October 2010 (1) </a></li>
<li><a href="/2010/09"> September 2010 (1) </a></li>
<li><a href="/2010/08"> August 2010 (1) </a></li>
<li><a href="/2010/07"> July 2010 (1) </a></li>
<li><a href="/2010/05"> May 2010 (3) </a></li>
<li><a href="/2010/04"> April 2010 (1) </a></li>
<li><a href="/2010/03"> March 2010 (2) </a></li>
<li><a href="/2010/02"> February 2010 (3) </a></li>
<li><a href="/2010/01"> January 2010 (4) </a></li>
<li><a href="/2009/12"> December 2009 (2) </a></li>
<li><a href="/2009/11"> November 2009 (5) </a></li>
<li><a href="/2009/10"> October 2009 (2) </a></li>
<li><a href="/2009/09"> September 2009 (2) </a></li>
<li><a href="/2009/08"> August 2009 (3) </a></li>
<li><a href="/2009/07"> July 2009 (1) </a></li>
<li><a href="/2009/05"> May 2009 (1) </a></li>
<li><a href="/2009/04"> April 2009 (1) </a></li>
<li><a href="/2009/03"> March 2009 (5) </a></li>
<li><a href="/2009/02"> February 2009 (5) </a></li>
<li><a href="/2009/01"> January 2009 (5) </a></li>
<li><a href="/2008/12"> December 2008 (3) </a></li>
<li><a href="/2008/11"> November 2008 (7) </a></li>
<li><a href="/2008/10"> October 2008 (4) </a></li>
<li><a href="/2008/09"> September 2008 (2) </a></li>
<li><a href="/2008/08"> August 2008 (1) </a></li>
<li><a href="/2008/07"> July 2008 (1) </a></li>
<li><a href="/2008/06"> June 2008 (1) </a></li>
<li><a href="/2008/05"> May 2008 (1) </a></li>
<li><a href="/2008/04"> April 2008 (1) </a></li>
<li><a href="/2008/01"> January 2008 (4) </a></li>
<li><a href="/2007/12"> December 2007 (3) </a></li>
<li><a href="/2007/03"> March 2007 (3) </a></li>
<li><a href="/2007/02"> February 2007 (1) </a></li>
<li><a href="/2007/01"> January 2007 (2) </a></li>
<li><a href="/2006/12"> December 2006 (4) </a></li>
<li>
<p><a href="/2006/11"> November 2006 (18) </a></p>
</li>
<li>
<p><a href="/ai"> AI (68) </a></p>
</li>
<li><a href="/til-deep-dives"> TIL deep dives (63) </a></li>
<li><a href="/python"> Python (62) </a></li>
<li><a href="/llm-from-scratch"> LLM from scratch (34) </a></li>
<li><a href="/resolver-one"> Resolver One (34) </a></li>
<li><a href="/blogkeeping"> Blogkeeping (18) </a></li>
<li><a href="/pythonanywhere"> PythonAnywhere (17) </a></li>
<li><a href="/linux"> Linux (16) </a></li>
<li><a href="/startups"> Startups (15) </a></li>
<li><a href="/nslu2-offsite-backup-project"> NSLU2 offsite backup project (13) </a></li>
<li><a href="/til"> TIL (13) </a></li>
<li><a href="/hugging-face"> Hugging Face (12) </a></li>
<li><a href="/funny"> Funny (11) </a></li>
<li><a href="/finance"> Finance (10) </a></li>
<li><a href="/fine-tuning"> Fine-tuning LLMs (10) </a></li>
<li><a href="/musings"> Musings (10) </a></li>
<li><a href="/c"> C (9) </a></li>
<li><a href="/gadgets"> Gadgets (8) </a></li>
<li><a href="/personal"> Personal (8) </a></li>
<li><a href="/robotics"> Robotics (8) </a></li>
<li><a href="/website-design"> Website design (8) </a></li>
<li><a href="/3d"> 3D (5) </a></li>
<li><a href="/rants"> Rants (5) </a></li>
<li><a href="/cryptography"> Cryptography (4) </a></li>
<li><a href="/javascript"> JavaScript (4) </a></li>
<li><a href="/music"> Music (4) </a></li>
<li><a href="/oddities"> Oddities (4) </a></li>
<li><a href="/quick-links"> Quick links (4) </a></li>
<li><a href="/talks"> Talks (4) </a></li>
<li><a href="/dirigible"> Dirigible (3) </a></li>
<li><a href="/eee"> Eee (3) </a></li>
<li><a href="/memes"> Memes (3) </a></li>
<li><a href="/politics"> Politics (3) </a></li>
<li><a href="/django"> Django (2) </a></li>
<li><a href="/gpu-computing"> GPU Computing (2) </a></li>
<li><a href="/latex"> LaTeX (2) </a></li>
<li><a href="/mathml"> MathML (2) </a></li>
<li><a href="/olpc-xo"> OLPC XO (2) </a></li>
<li><a href="/retro-language-models"> Retro Language Models (2) </a></li>
<li><a href="/space"> Space (2) </a></li>
<li><a href="/voip"> VoIP (2) </a></li>
<li><a href="/copyright"> Copyright (1) </a></li>
<li><a href="/golang"> Golang (1) </a></li>
<li><a href="/raspberry-pi"> Raspberry Pi (1) </a></li>
<li>
<p><a href="/software-dev-tools"> Software development tools (1) </a></p>
</li>
<li>
<p><a href="https://agileabstractions.com/">Agile Abstractions</a></p>
</li>
<li><a href="https://www.astralcodexten.com/">Astral Codex Ten</a></li>
<li><a href="https://blog.omega-prime.co.uk/">:: (Bloggable a) =&gt; a -&gt; IO ()</a></li>
<li><a href="https://daviddfriedman.substack.com/">David Friedman's Substack</a></li>
<li><a href="https://robertsmithson1.substack.com/">Econ &amp; Energy</a></li>
<li><a href="https://ianozsvald.com/">Entrepreneurial Geekiness</a></li>
<li><a href="https://holdenweb.blogspot.com/">For some value of "Magic"</a></li>
<li><a href="https://hackaday.com/">Hackaday</a></li>
<li><a href="https://kaleidic.substack.com/">kaleidic.ai newsletter</a></li>
<li><a href="https://knowing.net/">Knowing.NET</a></li>
<li><a href="https://languagelog.ldc.upenn.edu/nll/">Language Log</a></li>
<li><a href="http://blog.millenniumhand.co.uk/">Millennium Hand</a></li>
<li><a href="https://ntoll.org/">ntoll.org</a></li>
<li><a href="https://www.obeythetestinggoat.com/">Obey the Testing Goat!</a></li>
<li><a href="https://pkaznowski.gitlab.io/projects/">PK</a></li>
<li><a href="https://blog.pythonanywhere.com/">PythonAnywhere News</a></li>
<li><a href="https://simonwillison.net/">Simon Willison's Weblog</a></li>
<li><a href="https://medium.com/@societive">Societive</a></li>
<li><a href="https://orestis.gr/">Software Deviser</a></li>
<li><a href="https://filip.lajszczak.dev/">Some opinions, held with varying degrees of certainty</a></li>
<li><a href="https://www.tartley.com/">tartley.com</a></li>
</ul>
<h2 id="writing-an-llm-from-scratch-part-28-training-a-base-model-from-scratch-on-an-rtx-3090_1">Writing an LLM from scratch, part 28 -- training a base model from scratch on an RTX 3090<a class="headerlink" href="#writing-an-llm-from-scratch-part-28-training-a-base-model-from-scratch-on-an-rtx-3090_1" title="Permanent link">&para;</a></h2>
<p>Posted on 2 <a href="/2025/12/">December 2025</a> in <a href="/ai">AI</a>, <a href="/llm-from-scratch">LLM from scratch</a>, <a href="/til-deep-dives">TIL deep dives</a>, <a href="/python">Python</a></p>
<p>Having worked through the main body of <a href="https://sebastianraschka.com/">Sebastian Raschka</a>'s book "<a href="https://www.manning.com/books/build-a-large-language-model-from-scratch">Build a Large Language Model (from Scratch)</a>", I wanted to try an experiment: is it possible to train a base model of my own, on my own hardware?</p>
<p>The book shows you how to train your LLM, does a basic training run on a small dataset, and then we switch to downloading the "pre-cooked" weights from OpenAI. That makes sense given that not every reader will have access to enough hardware to really train from scratch. And right back at <a href="/2024/12/llm-from-scratch-1">the start of this series</a>, I did some naive scaling of numbers I'd got when fine-tuning LLMs and came to the conclusion that it would be impossible in a reasonable time.</p>
<p>But the speed I got with my RTX 3090 on the book's small training run made me think that perhaps -- just perhaps! -- it might actually be possible to train a model of this size -- about 163M parameters -- on my own hardware. Not, perhaps, on a small laptop, but at least on a reasonably high-end "gaming" PC.</p>
<p>Additionally, Andrej Karpathy recently announced <a href="https://github.com/karpathy/nanochat">nanochat</a>, "the best ChatGPT that $100 can buy". He mentions on the main page that he's trained a model called <code>d32</code>, with 32 Transformer layers, which has 1.9B parameters, for about $800. His smaller 20-layer <code>d20</code> model, with 561M parameters, he says should be trainable in about four hours on an 8x H100 GPU node, which costs about $24/hour -- hence the $100 total price.</p>
<p>What's even more interesting about nanochat is that it's built with PyTorch; initially I'd got the impression that it was based on his pure C/CUDA <a href="https://github.com/karpathy/llm.c"><code>llm.c</code></a>, which I would imagine would give a huge speedup. But no -- he's using the same stack as I have been in this series!</p>
<p>Karpathy's models are both larger than 163M parameters, so it definitely sounded like this might be doable. Obviously, I'm nowhere near as experienced an AI developer, and he's using a larger machine (8 GPUs and each of them has &gt; 3x more VRAM than mine), but he's also including the time to train a tokeniser and instruction fine-tune into that four hours -- and his smaller model is more than three times larger than mine. So that should all help.</p>
<p>This post is a little less structured than the others in my LLM from scratch series, as it's essentially a tidied version of the notes I kept as I worked through the project.</p>
<p>But so as not to bury the lede: using the Hugging Face FineWeb-series datasets, I was able to train a GPT-2 small sized base model to a level where it was almost as good as the original in just over 48 hours on my own hardware! Base models: not just for the big AI labs.</p>
<p>Here's the full story.</p>
<h3 id="the-model">The model<a class="headerlink" href="#the-model" title="Permanent link">&para;</a></h3>
<p>For this project, I want to use the exact same model code as Raschka presented in the LLM from scratch book -- <a href="https://github.com/gpjt/llm-from-scratch/blob/main/gpt.py">my copy here</a>. There have been <a href="https://magazine.sebastianraschka.com/p/from-gpt-2-to-gpt-oss-analyzing-the">a number of architectural improvements</a> to LLMs since GPT-2, but for now it's best to keep things simple.</p>
<p>But there are still some settings to decide on. The config dictionary for the models we've been using has these parameters:</p>
<ul>
<li><code>vocab_size</code>. This is determined by the tokenizer, and I want to use the GPT-2 one, so it will need to be <code>50257</code>.</li>
<li><code>context_length</code>. GPT-2 has a 1,024-token context length, so I'll stick with that.</li>
<li><code>emb_dim</code>, <code>n_heads</code>, <code>n_layers</code> --- these define which of the different GPT-2 model classes we're training, and I want to stick to the smallest <code>gpt2-small</code> one, so they will be <code>768</code>, <code>12</code> and <code>12</code> respectively</li>
<li><code>drop_rate</code>. One of the most surprising things to me in the "architectural improvements" post linked above was that dropout is no longer used so much. However, this appears to be tied in to the one-epoch training that has taken off since GPT-2, so I think it would be best to stick to <code>0.1</code> here.</li>
<li><code>qkv_bias</code>. From what Raschka says in the book, this doesn't add on much value, even though the original GPT-2 used it, so let's set it to <code>False</code>.</li>
</ul>
<p>There's also the aspect of weight-tying -- the original GPT-2 reused its embedding matrix as the weights for the linear layer that <a href="/2025/05/llm-from-scratch-15-from-context-vectors-to-logits">projects the context vectors from the last Transformers layer into vocab space to get the logits</a>.</p>
<p>There's nothing in the code we've been working with to enforce that, though -- when we do our small train in the book, we're using independent weights for each of those steps. The only time it is "enforced" is when we download the pretrained weights from OpenAI, where we put the same values into both the embedding matrix and the final output head.</p>
<p>Given that Raschka says that it's in general better to avoid weight-tying, and actually doing it would be harder than not doing it, then it seems a no-brainer to not do it.</p>
<p>So, what does that mean about our model?</p>
<div class="language-text highlight"><pre><span></span><code>In [1]: big_train_params = {
   ...:     &quot;vocab_size&quot;: 50257,
   ...:     &quot;context_length&quot;: 1024,
   ...:     &quot;emb_dim&quot;: 768,
   ...:     &quot;n_heads&quot;: 12,
   ...:     &quot;n_layers&quot;: 12,
   ...:     &quot;drop_rate&quot;: 0.1,
   ...:     &quot;qkv_bias&quot;: False
   ...: }

In [2]: from gpt import GPTModel

In [3]: model = GPTModel(big_train_params)

In [4]: sum(p.numel() for p in model.parameters())
Out[4]: 163009536
</code></pre></div>
<p>That matches what we got when working through the book; 163M parameters. Can we train it?</p>
<h3 id="the-data">The data<a class="headerlink" href="#the-data" title="Permanent link">&para;</a></h3>
<p>It seems like every AI project starts with the question "what data can we use?"</p>
<p>The original report on GPT-2, "<a href="https://cdn.openai.com/better-language-models/language_models_are_unsupervised_multitask_learners.pdf">Language Models are Unsupervised Multitask Learners</a>", is frustratingly lacking in details. However, it does say that they trained it on "8 million documents for a total of 40 GB of text". Now, <a href="https://platform.openai.com/tokenizer">according to OpenAI</a>, it's reasonable to assume roughly four characters per token for typical English text. So 40 GB of text is ~10 billion tokens. That data was essentially gathered by scraping pages linked from Reddit that had more than three upvotes there, so was reasonably high quality. Can we get something similar?</p>
<p>Conveniently, Hugging Face host a big dataset called <a href="https://huggingface.co/datasets/HuggingFaceFW/fineweb">FineWeb</a>, and that has a 10 billion token "sample" dataset, randomly selected from the full 18.5 <em>trillion</em> tokens. So the sample feels like it's order-of-magnitude right. And while reading more about Karpathy's nanochat, I spotted that it uses <a href="https://huggingface.co/datasets/HuggingFaceFW/fineweb-edu">FineWeb-Edu</a>, which is a version of FineWeb that contains "only the most educational web pages".</p>
<p>I wrote <a href="https://github.com/gpjt/llm-from-scratch/blob/main/download-fineweb-10b.py">a script to download both of those</a>, and kicked it off. It took about 20 minutes for each one (slow wifi in my study, I was getting &lt; 5MB/s); FineWeb's 10B sample took up about 29 GiB, and FineWeb-Edu's about 27 GiB.</p>
<p>Time to take a look at them. The Hugging Face <a href="https://pypi.org/project/datasets/"><code>datasets</code></a> <code>load_dataset</code> function loads up all of the files you provide, and you can tell it how to split them up into train/validation/test sets. This command just loads up the whole FineWeb one and says "treat it all as the train split", which is good enough for now:</p>
<div class="language-text highlight"><pre><span></span><code>In [1]: from datasets import load_dataset

In [2]: fw = load_dataset(
   ...:     &quot;parquet&quot;,
   ...:     data_files=&quot;./fineweb/sample/10BT/*.parquet&quot;,
   ...:     split=&quot;train&quot;
   ...: )
Generating train split: 14868862 examples [01:53, 130852.34 examples/s]
Loading dataset shards: 100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 102/102 [00:03&lt;00:00, 31.90it/s]
</code></pre></div>
<p>Yikes. It took 1 minute, 53 seconds to generate the train split. However, that appears to be a one-off cost -- when I accessed it again later using the same code in a different Python session, it just did the second "Loading dataset shards" portion, taking three seconds, not the generation of the split. Presumably it caches it.</p>
<p>Anyway, let's see what's in it:</p>
<div class="language-text highlight"><pre><span></span><code>In [3]: print(fw)
Dataset({
    features: [&#39;text&#39;, &#39;id&#39;, &#39;dump&#39;, &#39;url&#39;, &#39;date&#39;, &#39;file_path&#39;, &#39;language&#39;, &#39;language_score&#39;, &#39;token_count&#39;],
    num_rows: 14868862
})
</code></pre></div>
<p>Great, so we have 14,868,862 rows, each of which has various bits of information. Checking the first one's text:</p>
<div class="language-text highlight"><pre><span></span><code>In [7]: print(fw[0][&quot;text&quot;][:500])
|Viewing Single Post From: Spoilers for the Week of February 11th|
|Lil||Feb 1 2013, 09:58 AM|
Don&#39;t care about Chloe/Taniel/Jen-Jen. Don&#39;t care about Sami, really, but hoping
that we get some good &quot;SAMANTHA GENE!!&quot; Marlena Death-Stares out of it. And
&quot;newfound&quot; feelings. Please. If only.
STEFANO!! STEFANO, STEFANO, STEFANO!!!! :cheer:
|Spoilers for the Week of February 11th Â· DAYS: News, Spoilers &amp; Discussion|
</code></pre></div>
<p>Well, for FineWeb, that doesn't look particularly "fine", but I guess it's better than the stuff that Karpathy talked about in <a href="https://www.dwarkesh.com/p/andrej-karpathy">his recent interview with Dwarkesh Patel</a>:</p>
<blockquote>
<p>When youâre looking at a pre-training dataset in the frontier lab and you look at a random internet document, itâs total garbage. I don't even know how this works at all. Itâs [stuff] like stock tickers, symbols, it's a huge amount of slop and garbage from like all the corners of the internet</p>
</blockquote>
<p>Let's take a look at FineWeb-Edu.</p>
<div class="language-text highlight"><pre><span></span><code>In [8]: fw_edu = load_dataset(
   ...:     &quot;parquet&quot;,
   ...:     data_files=&quot;./fineweb-edu/sample/10BT/*.parquet&quot;,
   ...:     split=&quot;train&quot;
   ...: )
Generating train split: 9672101 examples [01:32, 104057.34 examples/s]
Loading dataset shards: 100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 98/98 [00:02&lt;00:00, 48.62it/s]

In [9]: print(fw_edu[0][&quot;text&quot;][:500])
The Independent Jane
For all the love, romance and scandal in Jane Austenâs books, what they are
really about is freedom and independence. Independence of thought and the
freedom to choose.
Elizabethâs refusal of Mr. Collins offer of marriage showed an independence
seldom seen in heroines of the day. Her refusal of Mr. Darcy while triggered by
anger showed a level of independence that left him shocked and stunned.
The freedom she exhibited in finally accepting him in direct defiance of Lady Cath
</code></pre></div>
<p>That looks a lot better!</p>
<p>Now let's take a look at the document lengths in terms of tokens. There's a <code>token_count</code> column, but I don't know which tokeniser that's for, so to be safe we'll calculate it ourselves.</p>
<p>How long would it take to tokenise every row in FineWeb 10B to check? Let's tokenise the first 10,000 of the 14,868,862 that we have, and see how long that would take -- then we can work out the estimated time for the whole thing.</p>
<div class="language-text highlight"><pre><span></span><code>In [25]: import tiktoken

In [26]: import time

In [27]: tokenizer = tiktoken.get_encoding(&quot;gpt2&quot;)

In [28]: start = time.time()
    ...: for entry in fw.select(range(10_000)):
    ...:     tokenizer.encode(entry[&quot;text&quot;])
    ...: end = time.time()

In [29]: end - start
Out[29]: 1.4528205394744873

In [30]: fw
Out[30]:
Dataset({
    features: [&#39;text&#39;, &#39;id&#39;, &#39;dump&#39;, &#39;url&#39;, &#39;date&#39;, &#39;file_path&#39;, &#39;language&#39;, &#39;language_score&#39;, &#39;token_count&#39;],
    num_rows: 14868862
})

In [31]: (14868862 / 10_000) * 1.4528205394744873
Out[31]: 2160.1788112211702
</code></pre></div>
<p>2,160 seconds or about 36 minutes. Yikes!</p>
<p>After a bit of digging, though, I found that <code>tiktoken</code> tokenisers can handle batches (poorly documented, but it's there <a href="https://github.com/openai/tiktoken/blob/97e49cb/tiktoken/core.py#L175#L175">in the source</a>):</p>
<div class="language-text highlight"><pre><span></span><code>In [45]: text_batch = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]

In [46]: tokenizer.encode_batch(text_batch)
Out[46]: [[64], [65], [66]]
</code></pre></div>
<p>Also, we can map a function over an entire HF dataset, and that can be made to run with multiple processes. So, we can combine the two:</p>
<div class="language-text highlight"><pre><span></span><code>In [47]: import os

In [53]: def add_len(examples):
    ...:     texts = [t or &quot;&quot; for t in examples[&quot;text&quot;]]
    ...:     tokens = tokenizer.encode_batch(texts, disallowed_special=())
    ...:     return {&quot;tok_len&quot;: [len(t) for t in tokens]}
    ...:

In [54]: start = time.time()
    ...: fw_with_len = fw.map(
    ...:     add_len,
    ...:     batched=True,
    ...:     batch_size=1024,
    ...:     num_proc=os.cpu_count(),
    ...: )
    ...: end = time.time()
Map (num_proc=24): 100%|ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 14868862/14868862 [03:15&lt;00:00, 75869.33 examples/s]
</code></pre></div>
<p>Just over three minutes, not too bad! (The reason the command count above jumps from 47 to 53 was that in the first run I didn't have the <code>disallowed_special=()</code> in there -- one of the rows in the dataset had <code>&lt;|endoftext|&gt;</code> in it, and the tokenizer rejected it. I'm going to play fast and loose and ignore that for now.)</p>
<p>Now let's see how it added it:</p>
<div class="language-text highlight"><pre><span></span><code>In [56]: fw_with_len[0].keys()
Out[56]: dict_keys([&#39;text&#39;, &#39;id&#39;, &#39;dump&#39;, &#39;url&#39;, &#39;date&#39;, &#39;file_path&#39;, &#39;language&#39;, &#39;language_score&#39;, &#39;token_count&#39;, &#39;tok_len&#39;])

In [57]: fw_with_len[0][&quot;tok_len&quot;]
Out[57]: 142

In [58]: len(fw_with_len[&quot;tok_len&quot;])
Out[58]: 14868862

In [59]: fw_with_len[&quot;tok_len&quot;][0]
Out[59]: 142
</code></pre></div>
<p>Cool! We've added a <code>tok_len</code> column with the number of GPT-2 tokens for each row, and we can extract what amounts to a list of those values. Let's plot them as a histogram.</p>
<p>Trying to do it directly -- that is, just doing</p>
<div class="language-text highlight"><pre><span></span><code>ax.hist(fw_with_len[&quot;tok_len&quot;], bins=bins)
</code></pre></div>
<p>...seems to make MatPlotLib very unhappy, and my interpreter crashed with an OOM -- I think it might be trying to load all of the dataset -- text, IDs, etc -- into RAM in one go.</p>
<p>So I started a fresh one and did the stuff to load it and annotate it with token lengths again -- weirdly, this time the mapping only took 10 seconds or so! That was strange, I'll need to look into that. Perhaps the earlier command added the <code>tok_len</code> column to the files on disk?</p>
<p>To work around the memory issue, I converted the <code>tok_len</code> column from the dataset to an actual list:</p>
<div class="language-text highlight"><pre><span></span><code>In [11]: lengths = [n for n in fw_with_len[&quot;tok_len&quot;]]
</code></pre></div>
<p>That took ten or twenty seconds. Let's then try the plot again (full code this time):</p>
<div class="language-text highlight"><pre><span></span><code>In [19]: import numpy as np
    ...: import matplotlib.pyplot as plt
    ...:
    ...: bins = np.arange(0, 2048 + 16, 16)
    ...:
    ...: plt.xkcd()
    ...: plt.rcParams[&#39;font.family&#39;] = &quot;xkcd&quot;
    ...: fig = plt.figure(figsize=(10, 6))
    ...: ax = plt.gca()
    ...:
    ...: ax.hist(lengths, bins=bins)
    ...: ax.set_xlabel(&quot;TOKENIZED LENGTH (GPT-2 TOKENS)&quot;)
    ...: ax.set_ylabel(&quot;COUNT&quot;)
    ...: ax.set_title(&quot;FINEWEB DISTRIBUTION OF TOKENIZED LENGTHS&quot;)
    ...:
    ...: mean_len = float(np.mean(lengths))
    ...: median_len = float(np.median(lengths))
    ...: h_mean = ax.axvline(mean_len, linestyle=&quot;--&quot;, label=f&quot;MEAN = {mean_len:.1f}&quot;)
    ...: h_med  = ax.axvline(median_len, linestyle=&quot;:&quot;,  label=f&quot;MEDIAN = {median_len:.1f}&quot;)
    ...: ax.legend(handles=[h_mean, h_med])
    ...:
    ...: ax.grid(True, axis=&quot;y&quot;, alpha=0.3)
    ...: plt.tight_layout()
    ...: plt.savefig(&quot;fineweb-token-length-distribution.png&quot;)
</code></pre></div>
<p>That took about 11s to run, and the result is this:</p>
<p><img alt="Histogram of GPT-2 token count across FineWeb samples" src="/post-assets/llm-from-scratch-28-training-a-base-model-from-scratch/fineweb-token-length-distribution.png" /></p>
<p>That's really promising! The bulk of them are less than our 1,024 token sequence length. 1 If we present each row in the dataset as a stand-alone training sample, cropping them when necessary, perhaps we won't lose too much data? Let's see.</p>
<p>First step, how many tokens are there in total?</p>
<div class="language-text highlight"><pre><span></span><code>In [20]: sum(lengths)
Out[20]: 10336315397
</code></pre></div>
<p>Nice, about 10B, as expected. How many tokens would we have if we cropped them to the default GPT-2 context length of 1,024?</p>
<div class="language-text highlight"><pre><span></span><code>In [21]: sum(l if l &lt; 1024 else 1024 for l in lengths)
Out[21]: 7354541756
</code></pre></div>
<p>Ouch, 7.3B. That's quite a reduction:</p>
<div class="language-text highlight"><pre><span></span><code>In [22]: 7354541756 / 10336315397
Out[22]: 0.7115245107685639
</code></pre></div>
<p>So we're losing 29% of our tokens by that cropping. That's from curtailing just 16% of the sequences:</p>
<div class="language-text highlight"><pre><span></span><code>In [26]: len([l for l in lengths if l &gt; 1024])
Out[26]: 2438899

In [27]: len(lengths)
Out[27]: 14868862

In [28]: 2438899 / 14868862
Out[28]: 0.1640272806351959
</code></pre></div>
<p>That's not great.</p>
<p>I feel that we have two options here:</p>
<ol>
<li>Crop all of the input sequences -- that is, each row in the dataset -- so that each one is no more than our 1,024 sequence length. Then we can pad them out with end-of-sequence tokens (as is the standard) so that they're all 1,024. This will lose us quite a lot of tokens, but has the big benefit of being easy.</li>
<li>Treat the corpus as, essentially, one long document, with end-of-sequence delimiters between each row, then split that up into 1,024-token sequences. Doing it this way would mean we'd use all of our training data. But it would be more complicated, especially if we hit memory constraints.</li>
</ol>
<p>At this point in the experiment, I'm going to keep both options open. I'm inclined towards the latter (I believe it's closer to what the real GPT-2 train did), but I'm not sure.</p>
<p>Anyway, we're scoping things out here, so let's move on.</p>
<h3 id="epochs">Epochs<a class="headerlink" href="#epochs" title="Permanent link">&para;</a></h3>
<p>After looking at the data, I've thought a bit more about this. I'd previously been thinking in terms of training across all of the tokens in the dataset; we'd work our way through the 10B tokens, and then we'd be done.</p>
<p>But when training a model, you do multiple epochs, normally -- you run through the dataset once, updating your gradients as you go, then run through it again likewise, and eventually you stop when your validation loss starts rising.</p>
<p>I think that because I'd read that LLMs are normally trained on just one epoch these days, I'd kind of internalised that we only need to do one. But it wasn't the case in 2019 when GPT-2 came out. They had less data -- just 10B tokens or so, compared to insanely huge datasets like the full FineWeb (not the 10B one we've been looking at -- the 18.5T full one), so they would have trained it for some number of epochs.</p>
<p>How many? That's another case where the GPT-2 paper is annoyingly light. <a href="https://wandb.ai/bkkaggle/lm-finetuning/reports/Pretraining-a-124-M-Parameter-GPT-2-Language-Model--VmlldzoyMjg4NzA">This report</a> says in the "Replicating GPT-2" section that OpenAI trained it for 800k iterations with a batch size of 512. Plugging in a sequence length of 1024, that gives us this many tokens:</p>
<p>800,000×512×1,024=419,430,400,000</p>
<p>Over 419B tokens!</p>
<p>Now, if we believe that their dataset was 10B tokens, then we can work out how many epochs that came to:</p>
<p>419,430,400,000/10,000,000,000=41.94</p>
<p>The same report says that they -- as in, the report authors -- make that "around a total of 60 epochs through the training set" -- I believe that the training set they're talking about could well be slightly shorter than the original GPT-2 one -- the GPT-2 authors didn't release their own, which is called "WebText", so the report's author is using a different one that tries to replicate it, <a href="https://skylion007.github.io/OpenWebTextCorpus/">OpenWebText</a>.</p>
<p>That sounds expensive; even without knowing how many tokens per second we can train for, 40-odd epochs of 10B tokens each sounds like it would take a long time. Are there any other comparison points that might tell us how long to train for?</p>
<p>Well, there's a "Chinchilla heuristic" that I've heard of, which says that you should train on about 20 tokens per model parameter. I spent some time reading into where that comes from; originally it's in "<a href="https://arxiv.org/abs/2203.15556">Training Compute-Optimal Large Language Models</a>" from Google DeepMind, and it's an interesting paper, and is surprisingly easy to read, with a few bits of maths that get a bit hairy (but aren't required to get a good-enough feel for what they're saying). I recommend you take a look.</p>
<p>It was written in 2022, and the authors felt that people were scaling up models a lot, but weren't increasing the number of tokens that they used for training enough. So, they trained a huge number of models, trying to answer the question: "given a particular budget in training FLOPs, what is the optimal balance of training tokens versus parameters to make sure you're using those FLOPs most efficiently?". They were arguing against the method taken in a particular paper, where another team had trained a model (called Gopher) on significantly fewer tokens than they thought optimal.</p>
<p>The number of FLOPs used to train a model is linear with both the number of parameters and the number of tokens you train it on, so if you get 2x the number of FLOPs that you had before, you can either train the same model on twice as many tokens, or you can double its size. Which is better? Their conclusion was that you should actually scale both parameters and tokens up by the same amount -- that is, in the 2x case you'd want to have 2 times both the parameters and tokens, which would double your FLOPs and get you better performance.</p>
<p>As you can probably see, by doing this they indirectly worked out an optimal number of tokens to train a particular size of model for. They don't state the "20x" heuristic themselves, but it's pretty clear in table 3 in the paper, where they give a number of model sizes and the optimal number of tokens for each.</p>
<p>Now, this number is not the number of tokens you need to train for to get the <em>best</em> model you can for a particular number of parameters; a model of a given size can always be trained more and will (hopefully) get better. But it tells you when you've trained on enough tokens that you could get better results by training a larger model than you have right now.</p>
<p>They're implicitly assuming that models can get as large as you want, which of course is not the case -- in reality, you're going to be targeting a particular model size, the size that can fit on your training hardware (or more likely with production models, the size that can fit on your planned inference hardware).</p>
<p>But interestingly, looking at the <a href="https://github.com/karpathy/nanochat/blob/master/README.md">README.md for Karpathy's nanochat</a> project, he trained his 1.9B "d32" model on 38B tokens -- exactly 20x. And if you look at the <a href="https://github.com/karpathy/nanochat/blob/master/speedrun.sh"><code>speedrun.sh</code></a> script in the same repo, he explicitly says that he's training for 20x parameters for the smaller <code>d20</code> model:</p>
<div class="language-text highlight"><pre><span></span><code># The d20 model is 561M parameters.
# Chinchilla says #tokens = 20X #params, so we need 561e6 * 20 = 11.2B tokens.
</code></pre></div>
<p>If Andrej Karpathy thinks that training for Chinchilla-optimality is the right way to go, then who am I to disagree? ;-)</p>
<p>More seriously, perhaps the better quality of the dataset makes this a reasonable thing to do. From the GPT-2 paper, their description of how they got the data:</p>
<blockquote>
<p>...we created a new web scrape which emphasizes document quality. To do this we only scraped web pages which have been curated/filtered by humans. Manually filtering a full web scrape would be exceptionally expensive so as a starting point, we scraped all outbound links from Reddit, a social media platform, which received at least 3 karma. This can be thought of as a heuristic indicator for whether other users found the link interesting, educational, or just funny.</p>
</blockquote>
<p>That's a clever trick, but I believe that FineWeb is much more carefully filtered and improved than the WebText dataset they got from that. Back in 2019, they had to do everything from scratch -- find appropriate ways to get data, filter it, and so on. Now we can just download stuff from Hugging Face. So maybe Chinchilla-optimal is enough.</p>
<p>Anyway, we have 163,009,536 parameters, so on that basis, let's train for:</p>
<p>163,009,536×20=3,260,190,720</p>
<p>...tokens. (I'll just use 3.2B from now on, but that's the actual number I mean.)</p>
<p>That's pretty cool! We have more than that number of tokens already in our FineWeb 10B sample, so we can do a single-epoch training run.</p>
<p>So the question is -- is that even doable on my hardware?</p>
<h3 id="tokens-per-second">Tokens per second<a class="headerlink" href="#tokens-per-second" title="Permanent link">&para;</a></h3>
<p>It all hinges on how many tokens per second we can train at. A good way to check this is to write a throwaway "trainer". We can use that to work out what our maximum batch size on the RTX 3090's 24 GiB of VRAM, then run a bunch of batches through -- a forward and backward pass for each -- and see how many we get.</p>
<p>This won't estimate how much time we'll spend validating the model, of course. But my gut is telling me that we should spend no more than 5% of our training time running validations, so we can later on do a similar test, eval mode, forward pass only with no gradient tracking, and use that to work out how many tokens should be in the validation set.</p>
<p>So, let's estimate training speed. <a href="https://github.com/gpjt/llm-from-scratch/blob/36196755f850adeba348d15e2f4f81e87ad4d14f/measure-tokens-per-second.py">This code</a> gets an estimate of tokens/second at different batch sizes. Hopefully it's clear enough to not need an in-depth explanation. An outline:</p>
<ul>
<li>We load enough GPT-2 tokens from FineWeb for <code>NUM_BATCHES</code> batches of <code>MAX_BATCH_SIZE</code> sequences each, every one of those sequences being <code>SEQ_LENGTH</code> long (plus one extra token for the targets we're comparing them to). Note that we're not bothering to separate them with anything for this test.</li>
<li>We then loop over batch sizes from <code>1</code> to <code>MAX_BATCH_SIZE</code>.</li>
<li>Then we create our model and put it on the CUDA device. We do this for each batch size rather than creating one and then using it for all of them so that they're all starting from the same point -- the <code>torch.manual_seed</code> should make sure that they're identical.</li>
<li>For each batch size, we create input and output batches as tensors -- note that we're not putting these on CUDA yet, I wanted to do that in the training loop to mirror what a real training loop will have to do. When we're training with 3.2B tokens then having them all on CUDA will be a waste of VRAM, so we'll be pushing a batch there for each iteration.</li>
<li>We do a stripped-down training loop -- for each batch, put the inputs and outputs onto CUDA, then a forward pass, work out the loss, backward pass, and optimiser step. We do the same <code>NUM_BATCHES</code> iterations per batch size.</li>
<li>Finally, we print out the number of tokens we trained on for this batch size, how long it took, and the number of tokens per second.</li>
</ul>
<p>Here's what it prints out:</p>
<div class="language-text highlight"><pre><span></span><code>Loading dataset shards: 100%|ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 102/102 [00:00&lt;00:00, 362.71it/s]
Testing with batch size 1
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:10&lt;00:00,  9.77it/s]
Done, trained on 102,400 tokens in 10.2348s.
Tokens per second: 10,005

Testing with batch size 2
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:17&lt;00:00,  5.60it/s]
Done, trained on 204,800 tokens in 17.8631s.
Tokens per second: 11,464

Testing with batch size 3
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:25&lt;00:00,  3.93it/s]
Done, trained on 307,200 tokens in 25.4152s.
Tokens per second: 12,087

Testing with batch size 4
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:33&lt;00:00,  3.02it/s]
Done, trained on 409,600 tokens in 33.1185s.
Tokens per second: 12,367

Testing with batch size 5
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:40&lt;00:00,  2.46it/s]
Done, trained on 512,000 tokens in 40.6351s.
Tokens per second: 12,599

Testing with batch size 6
  0%|                                                                                                                                             | 0/100 [00:00&lt;?, ?it/s]
Traceback (most recent call last):
  File &quot;/home/giles/Dev/llm-from-scratch/measure-tokens-per-second.py&quot;, line 89, in &lt;module&gt;
    main()
    ~~~~^^
...
torch.OutOfMemoryError: CUDA out of memory. Tried to allocate 1.15 GiB. GPU 0 has a total capacity of 23.56 GiB of which 269.19 MiB is free. Including non-PyTorch memory, this process has 20.99 GiB memory in use. Of the allocated memory 18.67 GiB is allocated by PyTorch, and 2.02 GiB is reserved by PyTorch but unallocated. If reserved but unallocated memory is large try setting PYTORCH_CUDA_ALLOC_CONF=expandable_segments:True to avoid fragmentation.  See documentation for Memory Management  (https://pytorch.org/docs/stable/notes/cuda.html#environment-variables)
</code></pre></div>
<p>So we can see that it gets faster as we increase the batch size, which makes sense because we're handling sequences in parallel, but it does flatten off a bit, which makes sense because there's a limit to how much parallelism we can do, even on a GPU.</p>
<p>Let's see how that fits in with the different training sizes we looked at above:</p>
<ul>
<li>Chinchilla heuristic, 20x parameters -- 3.2B tokens: 247,850 seconds, which is just less than three days</li>
<li>Estimated GPT-2 train, 419B tokens: 32,452,947 seconds, which is just over a year.</li>
</ul>
<p>OK. We're definitely not going to be able to train this thing the GPT-2 way! I expected that to be the case, but now we have a solid proof of that.</p>
<p>But the three-day Chinchilla-optimal train actually sounds doable! I'm heading to London to visit family soon, so won't be using my home PC. With a bit of help from <a href="https://tailscale.com/">Tailscale</a> I'll be able to log into it from my laptop, though, so I can potentially nurse a run through.</p>
<p>Can we make it any faster?</p>
<p>Now, when doing the fine-tuning work, I found that you could generally speed things up by doing everything in 16-bit rather than 32-bit. Intuitively that makes sense -- lower-precision numbers, fewer bits, means less work for the GPU doing the various multiplications and additions that are involved in our train.</p>
<p>Working with ChatGPT, I found a couple of ways to take advantage of that. Firstly, using TF32.</p>
<p>The normal float32 format uses 8 bits for the exponent, and 23 for the mantissa. If you haven't looked into how floats are represented in memory (or if you've forgotten), that means that, using m to mean the mantissa and x the exponent, the numbers are represented in memory as</p>
<p>m×2x</p>
<p>TF32 is messier; it has the same exponent size -- and thus the same range -- as float32, but it essentially ignores the lower 13 bits of the mantissa. So it takes up the same amount of memory, but is lower-precision, which means that calculations can be faster. Most importantly, cards like the RTX 3090 have dedicated "tensor cores" -- as opposed to the normal CUDA cores that do normal matrix multiplications -- and they operate in TF32. Unsurprisingly, "TF32" is "tensor float 32-bit".</p>
<p>The PyTorch <a href="https://docs.pytorch.org/docs/stable/generated/torch.set_float32_matmul_precision.html"><code>set_float32_matmul_precision</code></a> allows you to tell it what precision to use for matrix multiplications; the default is <code>"highest"</code>, which means "use float32 all of the time", so you're stuck using just the CUDA cores. If, instead, you set it to <code>"high"</code>, then it will use TF32 if the hardware supports it and it has the appropriate kernels available. So that will let us use the tensor cores.</p>
<p>I added this to the code above just above the loop over the different batch sizes:</p>
<div class="language-text highlight"><pre><span></span><code>torch.set_float32_matmul_precision(&quot;high&quot;)
</code></pre></div>
<p>Let it run, and:</p>
<div class="language-text highlight"><pre><span></span><code>Testing with batch size 1
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:08&lt;00:00, 11.66it/s]
Done, trained on 102,400 tokens in 8.5799s.
Tokens per second: 11,934

Testing with batch size 2
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:15&lt;00:00,  6.65it/s]
Done, trained on 204,800 tokens in 15.0287s.
Tokens per second: 13,627

Testing with batch size 3
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:20&lt;00:00,  4.85it/s]
Done, trained on 307,200 tokens in 20.6374s.
Tokens per second: 14,885

Testing with batch size 4
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:27&lt;00:00,  3.61it/s]
Done, trained on 409,600 tokens in 27.7148s.
Tokens per second: 14,779

Testing with batch size 5
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:33&lt;00:00,  3.01it/s]
Done, trained on 512,000 tokens in 33.2420s.
Tokens per second: 15,402
</code></pre></div>
<p>That's a 22% speedup! Of course, the precision of the training isn't as good. But given that many modern models are trained at 16-bit (I've seen suggestions that some are even trained as low as 4-bit) then that shouldn't matter.</p>
<p>Let's see whether we can train in 16-bit instead. PyTorch has a smart mode where you can tell it "use 16-bit where it makes sense, otherwise use 32-bit" -- AMP, which stands for "Automatic Mixed Precision". <a href="https://docs.pytorch.org/tutorials/recipes/recipes/amp_recipe.html">There's a great recipe for how to use it in the docs</a>, so let's use that. We need to create a <code>Scaler</code> object to handle scaling parameters from 16-bit to 32-bit as needed -- we can re-use that across all batch sizes so we can create it just before the loop:</p>
<div class="language-text highlight"><pre><span></span><code>    scaler = torch.amp.GradScaler()
</code></pre></div>
<p>...then we need to replace this core part of our training loop:</p>
<div class="language-text highlight"><pre><span></span><code>            logits = model(inputs)
            loss = torch.nn.functional.cross_entropy(
                logits.flatten(0, 1), outputs.flatten()
            )
            loss.backward()
            optimizer.step()
</code></pre></div>
<p>...with some code to use AMP and that scaler -- basically we use a context manager to switch it on when we're doing the forward pass and work out the loss, and then use the scaler to manage the backward pass and the optimiser's step:</p>
<div class="language-text highlight"><pre><span></span><code>            with torch.amp.autocast(device_type=device.type, dtype=torch.float16):
                logits = model(inputs)
                loss = torch.nn.functional.cross_entropy(
                    logits.flatten(0, 1), outputs.flatten()
                )
            scaler.scale(loss).backward()
            scaler.step(optimizer)
            scaler.update()
</code></pre></div>
<p>Running that gives us these results:</p>
<div class="language-text highlight"><pre><span></span><code>(llm-from-scratch) giles@perry:~/Dev/llm-from-scratch (main)$ python measure-tokens-per-second.py
Loading dataset shards: 100%|ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 102/102 [00:00&lt;00:00, 340.25it/s]
Testing with batch size 1
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:07&lt;00:00, 13.38it/s]
Done, trained on 102,400 tokens in 7.4764s.
Tokens per second: 13,696

Testing with batch size 2
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:12&lt;00:00,  8.11it/s]
Done, trained on 204,800 tokens in 12.3286s.
Tokens per second: 16,611

Testing with batch size 3
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:16&lt;00:00,  6.02it/s]
Done, trained on 307,200 tokens in 16.6238s.
Tokens per second: 18,479

Testing with batch size 4
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:21&lt;00:00,  4.67it/s]
Done, trained on 409,600 tokens in 21.3936s.
Tokens per second: 19,145

Testing with batch size 5
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:25&lt;00:00,  3.87it/s]
Done, trained on 512,000 tokens in 25.8624s.
Tokens per second: 19,797

Testing with batch size 6
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:30&lt;00:00,  3.25it/s]
Done, trained on 614,400 tokens in 30.7239s.
Tokens per second: 19,997

Testing with batch size 7
  0%|                                                                                                                                             | 0/100 [00:00&lt;?, ?it/s]
Traceback (most recent call last):
  File &quot;/home/giles/Dev/llm-from-scratch/measure-tokens-per-second.py&quot;, line 94, in &lt;module&gt;
    main()
</code></pre></div>
<p>Wow! With that we can train on 3.2B tokens in about 160,000 seconds, which is 44 hours. That's definitely doable.</p>
<p>Now, what happens if we remove the</p>
<div class="language-text highlight"><pre><span></span><code>torch.set_float32_matmul_precision(&quot;high&quot;)
</code></pre></div>
<p>...so that we're using AMP, but not the tensor cores?</p>
<div class="language-text highlight"><pre><span></span><code>(llm-from-scratch) giles@perry:~/Dev/llm-from-scratch (main)$ python measure-tokens-per-second.py
Loading dataset shards: 100%|ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 102/102 [00:00&lt;00:00, 365.94it/s]
Testing with batch size 1
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:07&lt;00:00, 13.03it/s]
Done, trained on 102,400 tokens in 7.6736s.
Tokens per second: 13,344

Testing with batch size 2
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:12&lt;00:00,  8.04it/s]
Done, trained on 204,800 tokens in 12.4383s.
Tokens per second: 16,465

Testing with batch size 3
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:16&lt;00:00,  5.96it/s]
Done, trained on 307,200 tokens in 16.7851s.
Tokens per second: 18,301

Testing with batch size 4
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:21&lt;00:00,  4.64it/s]
Done, trained on 409,600 tokens in 21.5571s.
Tokens per second: 19,000

Testing with batch size 5
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:25&lt;00:00,  3.85it/s]
Done, trained on 512,000 tokens in 25.9610s.
Tokens per second: 19,721

Testing with batch size 6
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:30&lt;00:00,  3.24it/s]
Done, trained on 614,400 tokens in 30.8405s.
Tokens per second: 19,921

Testing with batch size 7
  0%|                                                                                                                                             | 0/100 [00:00&lt;?, ?it/s]
Traceback (most recent call last):
  File &quot;/home/giles/Dev/llm-from-scratch/measure-tokens-per-second.py&quot;, line 93, in &lt;module&gt;
    main()
    ~~~~^^
  File &quot;/home/giles/Dev/llm-from-scratch/measure-tokens-per-second.py&quot;, line 81, in main
</code></pre></div>
<p>It's basically the same. 300tps slower at the start, down to 70 at the end. Still, it looks better to keep the "high" precision in place, rather than the "highest".</p>
<p>Right. We have the beginnings of a training loop that <em>should</em> be able to let us run a Chinchilla-optimal train on a GPT-2 small sized model in 44 hours, and I have the time to do it. And it looks like a batch size of six is what we can fit into the RTX 3090's 24 GiB of VRAM.</p>
<p>What else are we going to need to build something to do this?</p>
<h3 id="checkpointing">Checkpointing<a class="headerlink" href="#checkpointing" title="Permanent link">&para;</a></h3>
<p>If I want to do a long training run, then stuff might go wrong -- it might crash for some reason. So we're going to need to save checkpoints as we go and be able to restart training from those checkpoints.</p>
<p>In those, we're going to need to save the model and the optimiser's state, plus some kind of info about how far through the dataset we are. We should keep training and validation losses too, so that we can easily chart and recover our progress, and according to <a href="https://discuss.pytorch.org/t/do-i-need-to-save-the-state-dict-oof-gradscaler/95718/4">this forum post</a> we're going to need to save the scaler (which makes me think that it actually has state in it, so we probably should have used a fresh scaler for each batch size in the above -- let's hope that doesn't prove to be a problem [note from later: it wasn't]).</p>
<p>I wrote a <a href="https://github.com/gpjt/llm-from-scratch/blob/main/test-checkpointing.py">script</a> to create a model, train it for a bit, and then dump out all of that apart from the metadata (which I reckon is going to be less than 1kB). I wanted to use the <a href="https://huggingface.co/docs/safetensors/en/index">safetensors</a> format for all of it, but unfortunately I couldn't get it to work for the optimiser or the scaler, so had to use <code>torch.save</code> for those (which I don't like because it uses <a href="https://docs.python.org/3/library/pickle.html">pickle</a>, which introduces serious problems if you ever want to move files from machine to machine, as the Python and library versions need to match perfectly). Ah well. Here's what the test checkpoint looks like:</p>
<div class="language-text highlight"><pre><span></span><code>(llm-from-scratch) giles@perry:~/Dev/llm-from-scratch (main)$ du -sh test-checkpoint
1.9G    test-checkpoint
(llm-from-scratch) giles@perry:~/Dev/llm-from-scratch (main)$ ls -lh test-checkpoint
total 1.9G
-rw-r--r-- 1 giles giles 670M Nov 11 15:21 model.safetensors
-rw-r--r-- 1 giles giles 1.3G Nov 11 15:21 optimizer.pt
-rw-r--r-- 1 giles giles 1.4K Nov 11 15:21 scaler.pt
</code></pre></div>
<p>That's huge! And it's almost all the optimiser. From what I read, that stores two numbers per parameter, so it makes sense that it's double the size of the model weights. And at 32-bit, 4 bytes per param, then 670MiB for the model is sane.</p>
<p>Timing-wise, it takes about a second to save, the same to load, so that's fine.</p>
<p>So that sounds reasonable in terms of timing, and disk space is pretty high, but not so huge that it can't be managed with careful planning -- don't checkpoint so much that we run out of disk during the train (I have a 2TiB disk, but it's far from empty).</p>
<p>It's probably worth double-checking that it works, though! Because my checkpoint test already did some training, I changed it so that it does this:</p>
<ul>
<li>Create a model, optimiser and scaler.</li>
<li>Train the model for a bit.</li>
<li>Work out the loss.</li>
<li>Save a checkpoint.</li>
<li>Create a new model, optimiser, and scaler, and then restore the checkpoint into them.</li>
<li>Work out the loss</li>
<li>
<p>Train for a bit more to check that the optimiser and scaler still work.</p>
<p>(llm-from-scratch) giles@perry:~/Dev/llm-from-scratch (main)$ python test-checkpointing.py
Loading dataset shards: 100%|ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 102/102 [00:00&lt;00:00, 387.76it/s]
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:30&lt;00:00,  3.30it/s]
Loss prior to checkpoint: 7.0519
Checkpoint saved in 0.96s
Checkpoint loaded in 0.89s
Loss after checkpoint load: 7.0519
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:30&lt;00:00,  3.27it/s]
Loss after further training: 6.8996</p>
</li>
</ul>
<p>Looks sane! The numbers for loss are the same before and after, so I think it's vanishingly implausible that the checkpoint we restored is different from the one we saved. And the continued training seems to be working -- at least, loss is going down -- so that sounds reasonable too.</p>
<p>OK, so, again, the time taken to checkpoint is negligible, but the disk space isn't. I reckon we can comfortably do 100 checkpoints over the train. That's roughly one every half-hour over 44 hours.</p>
<p>We're going to want to do a validation run each time we checkpoint, so let's think about that next.</p>
<h3 id="validation">Validation<a class="headerlink" href="#validation" title="Permanent link">&para;</a></h3>
<p>How big should our validation set be? Let's say we only want to spend 5m per checkpoint period doing validation. How many batches can we get through in that time?</p>
<p>I wrote a simple script to run a model (after a few hundred training steps) in eval mode on different numbers of iterations to see how long each one took. It used the same <code>autocast</code> trick as the training loop above in order to use mixed precision, and I ran it with <code>torch.inference_mode</code> instead of the <code>torch.no_grad</code> that I've used in the past (ChatGPT tells me it's a little faster). I also put in some calls to <code>torch.cuda.synchronize</code> around the loop that I was timing, which should apparently help make sure that the numbers are precise. The code is <a href="https://github.com/gpjt/llm-from-scratch/blob/main/measure-validation-timing.py">here</a> if you'd like to take a look.</p>
<p>After some fiddling with the min/max numbers at the top:</p>
<div class="language-text highlight"><pre><span></span><code>(llm-from-scratch) giles@perry:~/Dev/llm-from-scratch (main)$ python measure-validation-timing.py
Loading dataset shards: 100%|ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 102/102 [00:00&lt;00:00, 352.52it/s]
Doing initial train
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 100/100 [00:30&lt;00:00,  3.25it/s]
Timing validation batch size 2900
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 2900/2900 [04:29&lt;00:00, 10.76it/s]
Got loss 7.3029 in 269.5059s
Timing validation batch size 3000
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 3000/3000 [04:39&lt;00:00, 10.73it/s]
Got loss 7.3044 in 279.4869s
Timing validation batch size 3100
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 3100/3100 [04:46&lt;00:00, 10.81it/s]
Got loss 7.3042 in 286.6812s
Timing validation batch size 3200
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 3200/3200 [04:55&lt;00:00, 10.82it/s]
Got loss 7.3043 in 295.7016s
Timing validation batch size 3300
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 3300/3300 [05:04&lt;00:00, 10.82it/s]
Got loss 7.3065 in 304.9547s
Timing validation batch size 3400
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 3400/3400 [05:14&lt;00:00, 10.82it/s]
Got loss 7.3060 in 314.3070s
Timing validation batch size 3500
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 3500/3500 [05:25&lt;00:00, 10.76it/s]
Got loss 7.3062 in 325.1689s
Timing validation batch size 3600
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 3600/3600 [05:35&lt;00:00, 10.73it/s]
Got loss 7.3064 in 335.6270s
Timing validation batch size 3700
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 3700/3700 [05:44&lt;00:00, 10.73it/s]
Got loss 7.3083 in 344.8765s
Timing validation batch size 3800
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 3800/3800 [05:54&lt;00:00, 10.73it/s]
Got loss 7.3111 in 354.3010s
Timing validation batch size 3900
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 3900/3900 [06:03&lt;00:00, 10.72it/s]
Got loss 7.3104 in 363.6413s
Timing validation batch size 4000
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 4000/4000 [06:11&lt;00:00, 10.76it/s]
Got loss 7.3110 in 371.8712s
</code></pre></div>
<p>OK, so let's call it 3200. That's 3200 * 6 * 1024 tokens = 19,660,800 tokens.</p>
<p>That's about 0.006144 of our training set. Pretty low, but we're talking about such a large training set that I think we're OK. And practically we can't do more -- we're already talking about 5 mins every half-hour, so we're bumping up our train time by 88 * 5 = 440 minutes, which is seven hours.</p>
<p>Now let's start thinking about the datasets.</p>
<h3 id="datasets">Datasets<a class="headerlink" href="#datasets" title="Permanent link">&para;</a></h3>
<p>We can split the HF thing into train and validation sets. I'm thinking it might be useful to load all of our training and validation data into RAM for the train loop. 3.2B tokens with four bytes per token should be about 13 GiB, after all, and I have 64 GiB RAM on the machine.</p>
<p>...but wait, int64 is the default for PyTorch for long ints -- that's what our token lists are in the original, and it's twice the size, so we're talking 26 GiB. I believe that PyTorch expects that format for the cross entropy loss.</p>
<p>That's not the end of the world, though -- we can store the data as int32 in RAM (with 50,257 as our vocab size we could even use int16 if we wanted to) and then we'll need to make them the right type just before using them. We can do that when splatting them onto the GPU, eg.</p>
<div class="language-text highlight"><pre><span></span><code>x = x_int32.to(device).to(torch.long)
</code></pre></div>
<p>First thought, can we store them as a Python list? Turns out they're not all that memory-efficient, though:</p>
<div class="language-text highlight"><pre><span></span><code>In [2]: list(range(3_200_000_000))
Killed                     ipython
</code></pre></div>
<p>How about PyTorch tensors?</p>
<div class="language-text highlight"><pre><span></span><code>In [3]: torch.rand((3_200_000_000))
Out[3]: tensor([0.6668, 0.1471, 0.9428,  ..., 0.3548, 0.5738, 0.5723])
</code></pre></div>
<p>Promising! (Though ChatGPT pointed out when reviewing a draft of this post that I was using the default <code>float32</code> rather than an <code>int32</code> type here. Still, it's the same size.)</p>
<p>Let's measure memory usage in a new interpreter.</p>
<div class="language-text highlight"><pre><span></span><code>In [1]: import psutil

In [2]: import torch

In [3]: import os

In [4]: rss_before = psutil.Process(os.getpid()).memory_info().rss

In [5]: t = torch.rand((3_200_000_000))

In [6]: rss_after = psutil.Process(os.getpid()).memory_info().rss

In [7]: rss_after - rss_before
Out[7]: 12801474560
</code></pre></div>
<p>Yup, 12,801,474,560, so about 12 GiB. Can we save it?</p>
<div class="language-text highlight"><pre><span></span><code>In [8]: from safetensors.torch import save_file

In [9]: save_file({&quot;tokens&quot;: t}, &quot;xxx&quot;)



(llm-from-scratch) giles@perry:~/Dev/llm-from-scratch (main)$ ls -l xxx
-rw-r--r-- 1 giles giles 12800000088 Nov 11 20:43 xxx
(llm-from-scratch) giles@perry:~/Dev/llm-from-scratch (main)$ ls -lh xxx
-rw-r--r-- 1 giles giles 12G Nov 11 20:43 xxx
</code></pre></div>
<p>OK, let's try reloading it in a fresh session:</p>
<div class="language-text highlight"><pre><span></span><code>In [1]: from safetensors.torch import load_file

In [2]: t = load_file(&quot;xxx&quot;)[&quot;tokens&quot;]

In [3]: t
Out[3]: tensor([0.5421, 0.1613, 0.8055,  ..., 0.7002, 0.7609, 0.5629])
</code></pre></div>
<p>Nice. So, I think we can write a quick script that splits our incoming dataset into say 99/1% train and validation, grabs the first 3.2B tokens from the training set, glomming them together into one big tensor with EOSes between them, and saves them, and then does likewise for the first 19,660,800 tokens from the validation set. We'll use FineWeb, with the possibility of switching to FineWeb-Edu later on. Doing it that way means that we're actually using the second of the two options I considered earlier:</p>
<blockquote>
<p>Treat the corpus as, essentially, one long document, with end-of-sequence delimiters between each row, then split that up into 1,024-token sequences.</p>
</blockquote>
<p>I thought it would be harder than concatenating/padding rows, but it actually turns out to be simple enough.</p>
<p>Let's give it a go. <a href="https://github.com/gpjt/llm-from-scratch/blob/843da6e19927ef1235b7989032e00c31d6c4396b/big-train-prepare-datasets.py">Here's the code</a>. I wanted to have an round number of 6-sequence batches of 1,024 tokens each, so the the number of training tokens worked out at</p>
<p>534,200×6×1,024=3,282,124,800</p>
<p>...rather than the strict Chinchilla-optimal 3,260,190,720, but that's no biggie.</p>
<p>Running it takes 5m55s, and then:</p>
<div class="language-text highlight"><pre><span></span><code>(llm-from-scratch) giles@perry:~/Dev/llm-from-scratch (main)$ ls -lh big-train-datasets/
total 13G
-rw-r--r-- 1 giles giles 13G Nov 11 23:08 train.safetensors
-rw-r--r-- 1 giles giles 76M Nov 11 23:02 validation.safetensors
</code></pre></div>
<p>Looks about the right size -- 19M * 4 for val, 3.2B * 4 for train.</p>
<p>Cool! Let's finally write our training script.</p>
<h3 id="finally-training-an-llm">Finally training an LLM!<a class="headerlink" href="#finally-training-an-llm" title="Permanent link">&para;</a></h3>
<p>You can see <a href="https://github.com/gpjt/llm-from-scratch/blob/main/big_train.py">the full training script here</a> -- note that this is the final version from the repo, so isn't exactly what I'm running at this point in the post. The checkpointing code is (sensibly enough) in a separate file, <a href="https://github.com/gpjt/llm-from-scratch/blob/main/checkpointing.py"><code>checkpointing.py</code></a>.</p>
<p>It took two days to run, and...</p>
<p><img alt="Training and validation loss over two days, FineWeb" src="/post-assets/llm-from-scratch-28-training-a-base-model-from-scratch/big-training-run-chart-fineweb.png" /></p>
<p>Both train and validation losses fall nicely! Training loss is a bit choppy, but that's because I erroneously only plotted the most recent iteration's training loss rather than an average over all iterations between the last and current validation run; the validation loss is correct because I did average all of the validation numbers. (The version of the code linked above fixes that error.)</p>
<p>The best epoch for val loss is not the last one but it was close. Looking at the last 5 iterations, their val losses were:</p>
<div class="language-text highlight"><pre><span></span><code>3.991096583977342
3.940103444904089  &lt;-- best
3.9403586230427026
3.9464842446893456
3.9469190353155135 &lt;-- latest
</code></pre></div>
<p>It's time to do some evals</p>
<h3 id="evals">Evals<a class="headerlink" href="#evals" title="Permanent link">&para;</a></h3>
<p>Firstly, let's try the smoke test that we do in the book. What does our model think should come after the text "Every effort moves you"?</p>
<p>With uninitialised weights we get gibberish, as expected</p>
<div class="language-text highlight"><pre><span></span><code>Every effort moves youã¯ISIS Keectar handling holistic Supply query prolongidation Joey flaw camerasIdent formula
</code></pre></div>
<p>But with our best checkpoint we get this:</p>
<div class="language-text highlight"><pre><span></span><code>Every effort moves you towards a sustainable and holistic diet of water, protein, vitamins, and protein
</code></pre></div>
<p>Nice! The multiple mentions of protein is actually the kind of repetition that small models tend to do, so that's not bad news.</p>
<p>Let's try with the last iteration's checkpoint:</p>
<div class="language-text highlight"><pre><span></span><code>Every effort moves you towards a new level of success, and youâre likely to continue
</code></pre></div>
<p>Also very nice, perhaps better!</p>
<p>I think that both of those are qualitatively as good as the result we got when we <a href="/2025/10/llm-from-scratch-22-finally-training-our-llm">loaded the pre-trained weights from OpenAI</a>, which was:</p>
<div class="language-text highlight"><pre><span></span><code>Every effort moves you as far as the hand can go until the end of your turn unless something interrupts your control flow. As you may observe I
</code></pre></div>
<p>That's very reassuring. But is there something a bit more quantitative that we can do?</p>
<p>Firstly, can we compare it to anything in the GPT-2 paper? In figure 4 they give their perplexity against their train and test sets for the different model sizes; for the small one it's a bit over 16, Let's assume that they're basing that on natural logarithms, so they mean that they have a loss of ln16. That's <code>2.77</code>, which is much lower than our best loss of 3.9401.</p>
<p>However, that is across different datasets, so while it makes me suspect that their model is better than ours, we can't really say for sure either way.</p>
<p>The cool thing is, though, that we <em>have</em> their model -- so we can actually run it against our dataset. I wrote a script called <a href="https://github.com/gpjt/llm-from-scratch/blob/main/test_openai_weights_against_our_val_dataset.py"><code>test_openai_weights_against_our_val_dataset.py</code></a>, and running it gives us this:</p>
<div class="language-text highlight"><pre><span></span><code>Loss against our validation dataset: 3.4987249702960255
</code></pre></div>
<p>Still better than ours :-(</p>
<p>I considered doing the same thing against Qwen to see whether that was also better, but with a different tokeniser we couldn't really treat it as comparable. Loss and perplexity are both over next-token predictions, and if the meaning of "token" changes, then the numbers will change. 2</p>
<p>OK, so we have a model, but it's not as good as the original GPT-2 small. Our loss on our validation set is roughly 3.94, while the original weights get about 3.50. Expressing that in terms of perplexity gives our own model about 51.4, while the original has 33.1. That's actually still higher than the 16 that they had in the paper, which is interesting -- presumably it's related to the fact that they're validating over their own WebText test set rather than ours; they're both samples of web content, but there must be differences.</p>
<p>At this point, my guess is that this shows that all of that extra training that the OpenAI team did beyond the Chinchilla-optimal number of tokens did have a real benefit -- and that's not suprising. Remember that the Chinchilla paper is about the best way to spend a FLOPs budget. They're not saying that you can't drive down loss by continuing to train your model further -- of course you can. They're saying that when you pass the optimal number of tokens, you should increase the model parameters and the tokens by the same ratio, and by doing that you'll get the best balance.</p>
<p>But still, a Chinchilla-optimal model of 163M parameters might still be useful. What happens if we instruction fine-tune it <a href="/2025/10/llm-from-scratch-25-instruction-fine-tuning">like we did the original model in Chapter 7 of the book</a>? In that post and its <a href="/2025/11/llm-from-scratch-26-evaluating-the-fine-tuned-model">followup</a>, we used some training samples using the "Alpaca" one-shot question-answering format:</p>
<div class="language-text highlight"><pre><span></span><code>Below is an instruction that describes a task.  Write a response that
appropriately completes the request.

### Instruction:

&lt;some instructions&gt;


### Input:

&lt;optional, some input&gt;

### Response:
</code></pre></div>
<p>...to get a model that we then provided a test set of questions in the same format, then used the Llama 3 7B model to judge the results on a scale of 0 to 100. We then averaged the results and got a plausible-looking indicator of how useful the model was, as compared to the more narrowly technical loss number.</p>
<p>One problem with that is that we ran those tests on the OpenAI weights for the medium-sized 355M-parameter GPT-2 model. If we don't want to be comparing apples to oranges, we'll need to re-run it on their weights for the small model. Let's see how we do.</p>
<p>First, let's run it for five epochs just to see when/if it starts overfitting:</p>
<p><img alt="Loss over five epochs training GPT-2 original weights on Alpaca" src="/post-assets/llm-from-scratch-28-training-a-base-model-from-scratch/instruction-fine-tune-5-epochs-losses-plot-original-weights.png" /></p>
<p>OK, so two epochs looks like the right amount, just as it was with the medium model. So we can train for that (because I'm using the original code I wrote when working through the chapter, I didn't checkpoint during training -- but it takes less than a minute to run the whole thing, so no biggie). Here's the loss chart:</p>
<p><img alt="Loss over two epochs training GPT-2 original weights on Alpaca" src="/post-assets/llm-from-scratch-28-training-a-base-model-from-scratch/instruction-fine-tune-2-epochs-losses-plot-original-weights.png" /></p>
<p>Validation loss at the end is 0.733, noticeably above the 0.649 that I got with the medium-sized model. And the sample outputs shown at the end aren't as good, either. With the medium-sized model, I got these:</p>
<div class="language-text highlight"><pre><span></span><code>Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
Rewrite the sentence using a simile.

### Input
The car is very fast.

Correct response:
&gt;&gt; The car is as fast as lightning.

Model response:
&gt;&gt; The car is as fast as a bullet.
Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
What type of cloud is typically associated with thunderstorms?

Correct response:
&gt;&gt; The type of cloud typically associated with thunderstorms is cumulonimbus.

Model response:
&gt;&gt; The type of cloud typically associated with thunderstorms is a cumulus cloud.
Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
Name the author of &#39;Pride and Prejudice&#39;.

Correct response:
&gt;&gt; Jane Austen.

Model response:
&gt;&gt; The author of &#39;Pride and Prejudice&#39; is Jane Austen.
</code></pre></div>
<p>...but with the small model (remember, this is with OpenAI's original weights) I get this:</p>
<div class="language-text highlight"><pre><span></span><code>Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
Rewrite the sentence using a simile.

### Input
The car is very fast.

Correct response:
&gt;&gt; The car is as fast as lightning.

Model response:
&gt;&gt; The car is as fast as a horse.
Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
What type of cloud is typically associated with thunderstorms?

Correct response:
&gt;&gt; The type of cloud typically associated with thunderstorms is cumulonimbus.

Model response:
&gt;&gt; A type of cloud typically associated with thunderstorms is the active layer.
Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
Name the author of &#39;Pride and Prejudice&#39;.

Correct response:
&gt;&gt; Jane Austen.

Model response:
&gt;&gt; The author of &#39;Pride and Prejudice&#39; is Robert Frost.
</code></pre></div>
<p>Definitely worse, especially the last one! Let's see what Llama 3 thinks of it, again using the code from the book:</p>
<div class="language-text highlight"><pre><span></span><code>Number of scores: 110 of 110
Average score: 35.50
</code></pre></div>
<p>The medium model got an average of 50, so the OpenAI small model is definitely much worse, as the examples suggested. Makes sense.</p>
<p>Let's see how our own base model performs when fine-tuned on the same data. After a bit of fiddling I found that validation loss settled down at the end of epoch 10:</p>
<p><img alt="Loss over ten epochs training our FineWeb base model on Alpaca" src="/post-assets/llm-from-scratch-28-training-a-base-model-from-scratch/instruction-fine-tune-10-epochs-losses-plot-our-model-fineweb.png" /></p>
<p>(It's hard to see from the chart, but validation loss was actually very slowly dropping even after epoch 5.)</p>
<p>It's interesting that our own model took longer to train here, but it does make sense in terms of it being that little bit dumber.</p>
<p>The samples it printed out at the end are also interesting:</p>
<div class="language-text highlight"><pre><span></span><code>Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
Rewrite the sentence using a simile.

### Input
The car is very fast.

Correct response:
&gt;&gt; The car is as fast as lightning.

Model response:
&gt;&gt; The car is as fast as a cheetah.
Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
What type of cloud is typically associated with thunderstorms?

Correct response:
&gt;&gt; The type of cloud typically associated with thunderstorms is cumulonimbus.

Model response:
&gt;&gt; A thunder storm is a type of thunder.
Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
Name the author of &#39;Pride and Prejudice&#39;.

Correct response:
&gt;&gt; Jane Austen.

Model response:
&gt;&gt; The author of &#39;Pride and Prejudice&#39; is Robert Frost.
</code></pre></div>
<p>The simile is pretty good, I think better than the OpenAI original weights' one, but the storm clouds one is dreadful. It's fascinating that they both chose the same wrong answer for "Pride and Prejudice" -- my guess is that it's because the training set contained this question:</p>
<div class="language-text highlight"><pre><span></span><code>Identify the tone used in the poem &#39;The Road Not Taken&#39; by Robert Frost.
</code></pre></div>
<p>...so both models picked up on Robert Frost being a useful author to reference in answers.</p>
<p>Anyway, what does Llama 3 think of the output?</p>
<div class="language-text highlight"><pre><span></span><code>Number of scores: 110 of 110
Average score: 29.35
</code></pre></div>
<p>Yup, it's dumber than the original weights -- but, at least to my mind, closer to the original weights' score than you might have thought based on that loss/perplexity number alone.</p>
<p>But, on the other hand, I'm not convinced that Llama 3 7B is smart enough to be doing a good job. In the stuff the eval script printed out, we have this:</p>
<div class="language-text highlight"><pre><span></span><code>Dataset response:
&gt;&gt; The type of cloud typically associated with thunderstorms is cumulonimbus.

Model response:
&gt;&gt; The type of cloud is typically associated with thunderstorms.

Score:
&gt;&gt; I&#39;d score this model response a 40 out of 100.

Here&#39;s why:

* The response partially answers the question by mentioning that cumulonimbus clouds are associated with thunderstorms.
* However, it lacks specific details and doesn&#39;t provide a clear answer to the question.
* A good response should provide a complete and accurate answer, which this one does not.

A better response would be something like: &quot;The type of cloud typically associated with thunderstorms is cumulonimbus.&quot; This response provides a clear and accurate answer to the question.
</code></pre></div>
<p>This is clearly completely wrong, the mention of cumulonimbus is coming from the dataset response, not the model response. Llama 3 7B is tripping up over what came from where, which is pretty normal for a small model.</p>
<p>Of course, it's possible that the scores for the OpenAI GPT-2 small weights also have been given a higher rating than they deserve -- or, indeed, that there were right answers that were incorrectly judged wrong. Conceivably it averages out. But there's no reason to assume it would, so it's essentially noise and is making the results less useful.</p>
<p>Let's try using a much smarter LLM as a judge and run both of the models responses through it -- the just-released OpenAI GPT-5.1 model. The code is <a href="https://github.com/gpjt/llm-from-scratch/blob/main/evaluate-with-openai.py">here</a>.</p>
<p>Running that against our own model's answers:</p>
<div class="language-text highlight"><pre><span></span><code>Number of scores: 110 of 110
Average score: 16.14
</code></pre></div>
<p>...and against the model fine-tuned from the small OpenAI weights:</p>
<div class="language-text highlight"><pre><span></span><code>Number of scores: 110 of 110
Average score: 20.39
</code></pre></div>
<p>...and, of course, it didn't make the mistake of confusing the dataset response with the model's in any of the cases printed out. ChatGPT 5.1 in the chat interface is very smart, I expect these results are much closer to a reasonable ground truth.</p>
<p>Out of interest, what does it make of the model based on the GPT-2 <strong>medium</strong> weights that we train as part of the book?</p>
<div class="language-text highlight"><pre><span></span><code>Number of scores: 110 of 110
Average score: 38.41
</code></pre></div>
<p>That's as compared to an average of about 50 from Llama 3 7B. It seems like GPT 5.1 is a tougher judge than the small local model -- and my guess is that that is because it's more accurate. 3</p>
<p>Anyway, the ranking remains the same; after fine-tuning on the same Alpaca dataset, GPT-2 medium &gt; GPT-2 small &gt; our model. But it's still a relatively close-run thing between our model and GPT-2 small. Can we close the gap without vast amounts of extra training?</p>
<h3 id="fineweb-edu">FineWeb-Edu<a class="headerlink" href="#fineweb-edu" title="Permanent link">&para;</a></h3>
<p>The results so far were from using 3.2B tokens of the FineWeb 10B corpus. Now, as I noted at the start of this post, Andrej Karpathy's nanochat project uses FineWeb-Edu, a separate corpus designed to be really informative. Indeed, back at the start when we were looking at the two datasets, the first row in the Edu dataset was about Jane Austen, so maybe we would wind up with a model that at least got that question right!</p>
<p>That's going to take another two days to train, but that's no big deal. We first need to change our script that generates the train/validation splits to regenerate them using the Edu dataset; we'll move the old ones to one side, though -- it will be interesting to see what loss we get on the non-edu validation data with the new model.</p>
<p>(Note to self: work out some way to split out different datasets and training runs for future experiments like this. The setup I had in my <a href="/2025/10/retro-language-models-rebuilding-karpathys-rnn-in-pytorch">recent post on RNNs</a> worked quite well. Throughout the remainder of this post I'm juggling directories of checkpoints and datasets, and I'm sure I got it right, but it was an error-prone process.)</p>
<p>That being done, it's time to move the checkpoints we already have to one side, and to kick off the train!</p>
<p>Here's what we have after two days on that -- oops, I forgot to add the code to average training loss across all of the batches, so again it's a bit spiky.</p>
<p><img alt="Training and validation loss over two days, FineWeb-Edu" src="/post-assets/llm-from-scratch-28-training-a-base-model-from-scratch/big-training-run-chart-fineweb-edu.png" /></p>
<p>But we got to a final eval loss of about 3.693 this time. Of course, that's on its own validation set, so it's not comparable with the numbers from before; loss is specific to a particular dataset. Let's see what it makes of the original run's validation set. Juggle some directories around (my messy file structure means that there is just one "datasets" directory and one "checkpoints" one, so I'm moving them around to make sure I'm using the right combination):</p>
<div class="language-text highlight"><pre><span></span><code>(llm-from-scratch) giles@perry:~/Dev/llm-from-scratch (main)$ python test_our_weights_against_our_dataset.py
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 3200/3200 [04:52&lt;00:00, 10.92it/s]
Loss against our validation dataset: 4.164705707877874
</code></pre></div>
<p>We get 4.16! That's truly terrible, worse than both the original base model that we trained on FineWeb's non-edu dataset, and than the OpenAI GPT-2 small weights.</p>
<p>Let's see what we get from the closer-to-real-world instruction fine-tuning test. Five epochs turns out to be best:</p>
<p><img alt="Loss over five epochs training our FineWeb-Edu base model on Alpaca" src="/post-assets/llm-from-scratch-28-training-a-base-model-from-scratch/instruction-fine-tune-5-epochs-losses-plot-our-model-fineweb-edu.png" /></p>
<p>I won't bother running it past Llama 3 7B, as that's proven unhelpful, so we'll go straight to GPT-5.1.</p>
<div class="language-text highlight"><pre><span></span><code>Number of scores: 110 of 110
Average score: 15.18
</code></pre></div>
<p>Gosh! So it's judged slightly worse than our weights based on FineWeb. That does surprise me a bit. I was definitely expecting the Edu version of the dataset to give us a better model.</p>
<p>So: OpenAI medium &gt; OpenAI small &gt; our FineWeb base model &gt; our FineWeb-Edu base model. That last pairing does surprise me a bit. Handwaving wildly, perhaps the more "regular" nature of the Edu dataset meant that the model saw less variation in its training set, and that actually made it learn less?</p>
<p>I think there's one more experiment I want to do before bringing this (<em>very</em> lengthy) post to a close. We've shown that Chinchilla-optimal training of models produces worse results than OpenAI's original, we think longer, train.</p>
<p>What would happen if we continued training for another two days?</p>
<h3 id="continuing-training">Continuing training<a class="headerlink" href="#continuing-training" title="Permanent link">&para;</a></h3>
<p>As I have it easily to hand, I want to use the FineWeb-Edu model for this. I want to start with the best checkpoint (which happens to be the last one), and train it on another 3.2B tokens from FineWeb-Edu. Let's see what we get.</p>
<p>Getting a dataset is going to be a bit messy, as our existing script to generate the safetensors datasets just grabs tokens from the original dataset until it gets 534,200 batches of 6 sequences, each of 1024 tokens (3,282,124,800 total).</p>
<p>Might as well hack it (and note that this is something worth improving for any later experiments). I'll just loop round the code to do that twice, throwing away the first set of 3.2B tokens.</p>
<p>I was pretty sure that the ordering of the datasets I'm getting is fixed, but perhaps not -- it spent time regenerating the train/val split at the start of the script, so there's no guarantee we have different data this time. That feels like a note-to-self about data pipeline hygiene -- if the train/val split is randomised by the infra I'm using, I should persist the raw data in case I need to use more data than I though I would need to.</p>
<p>Still, for this experiment, we can play relatively fast and loose. After all, GPT-2 small -- the original OpenAI weights -- was trained on multiple epochs, so it saw tokens multiple times. What we're trying to see here is what happens if you train for longer; a more scientific experiment can happen later (if at all...).</p>
<p>Anyway, we have 3.2B tokens that should at least be reasonably different from the original 3.2B.</p>
<p>Right, let's clean up some disk space so that we have enough for the new train (deleted some old optimiser checkpoints, keeping the metadata and the weights).</p>
<p>Now, we create a new checkpoints directory, and we can copy the last/best checkpoint from the original FineWeb-Edu train there. Hack the <code>train_ds_offset</code> in there to zero, create <code>best</code> and <code>latest</code> symlinks, and then we can "restart" from that checkpoint. Due to the way the restart-from-checkpoint code works in the training script, that means that it will start with an offset of 1 into the dataset, so we're dropping one of about 530,000 iterations, but that's not exactly the end of the world.</p>
<p><img alt="Training and validation loss over a second period of two days, FineWeb-Edu" src="/post-assets/llm-from-scratch-28-training-a-base-model-from-scratch/big-training-run-chart-fineweb-edu-2x.png" /></p>
<p>There are some interesting spikes on validation loss in there -- in particular that one at around iteration 300,000 where it goes up from 3.6 or so to 7.5 for two validation periods (which, remember, happen every ~30 minutes, or every 7020 iterations).</p>
<p>My guess is that we got some kind of gradient spike prior to those, which led to a bad update to the parameters. However, it looks like the loss recovered really quickly after it, so while gradient clipping (that is, limiting the size of the gradients so that one-off spikes don't cause massive updates) might have prevented them, I don't think it would have improved matters much -- we might have "lost" an hour so of training, but out of a 44-hour train (48 hours including breaks for validation), it's not the end of the world.</p>
<p>But, looking at the raw numbers, after our second two days of training on a fresh sample from FineWeb-Edu 10B, we've managed to get the loss on our validation set down from 3.693 to... drumroll... 3.661. And that's on the "best" measurement, which was an hour before the end. The last validation number was 3.663.</p>
<p>By spending twice the time, we've managed to get our loss down by 0.032, which is a touch less than 1%. Even measured in terms of perplexity (which, being an exponential, is more sensitive to this kind of change), we've gone from 40.2 to 38.9, which is hardly show-stopping.</p>
<p>Let's see how this one measures up against the non-edu FineWeb validation dataset that we originally used to calibrate our first training run. Run it, and:</p>
<div class="language-text highlight"><pre><span></span><code>(llm-from-scratch) giles@perry:~/Dev/llm-from-scratch (main)$ python test_our_weights_against_our_dataset.py
100%|âââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ| 3200/3200 [04:53&lt;00:00, 10.89it/s]
Loss against our validation dataset: 4.134009174928069
</code></pre></div>
<p>...we get 4.13 -- that's opposed to 4.16 on the last model, trained on half as much data.</p>
<p>Well, maybe it's a much better base model for instruction fine-tuning? Let's give that a go, again with the Alpaca training set from the book. 8 epochs turns out to be the right number:</p>
<p><img alt="Loss over eight epochs training our &quot;double-trained&quot; FineWeb-Edu base model on Alpaca" src="/post-assets/llm-from-scratch-28-training-a-base-model-from-scratch/instruction-fine-tune-8-epochs-losses-plot-our-model-fineweb-edu-2x.png" /></p>
<div class="language-text highlight"><pre><span></span><code>Number of scores: 110 of 110
Average score: 16.62
</code></pre></div>
<p>Certainly better than the 15.18 that we got on our Chinchilla-optimal FineWeb-Edu model, and a bit better than the 16.14 we got on the Chinchilla-optimal FineWeb one. So by training for double the time on twice the data, we've definitely got a better model. It's just not <em>that much</em> better.</p>
<p>I think that's more -- significantly more -- than enough experimentation for one blog post, so let's do some analysis.</p>
<h3 id="flops">FLOPs<a class="headerlink" href="#flops" title="Permanent link">&para;</a></h3>
<p>I want to sanity-check the number of FLOPs spent on this train, just to make sure that I hadn't messed up. Feel free to skip this if you want to jump straight to the conclusion :-)</p>
<p>In appendix F, the Chinchilla paper mentions a common approximation for how many FLOPs, C, you spend training a model with N parameters over D tokens:</p>
<p>C=6DN</p>
<p>So based on that, each of those training runs cost us (using the exact numbers for N and D) this many FLOPs:</p>
<p>C=6×3,282,124,800×163,009,536=3,210,105,844,452,556,800=3.21×1018FLOPS</p>
<p>They also give a more carefully-worked out calculation; it doesn't look all that difficult -- it's just a case of plugging in the numbers from our architecture and pulling out a result 4 -- but the numbers they get from that are generally within 10% of the simpler calculations, so we may as well stick with the above. 5</p>
<p>Now, in terms of how many FLOPs we actually spent... well, manufacturers' datasheets for hardware are based on carefully-selected benchmarks and won't really be comparable to the code we were running (especially given that it's my crappy code based on top of a huge stack of PyTorch, CUDA kernels, CUDA itself, and so on), but we can do a <a href="https://en.wikipedia.org/wiki/Fermi_problem">Fermi estimate</a>.</p>
<p>From Wikipedia, the <a href="https://en.wikipedia.org/wiki/List_of_Nvidia_graphics_processing_units#RTX_30_series">RTX 3090</a> has 35.58 TFLOPS performance on FP32. Way back earlier in this post, when I was measuring how many tokens per second I could get locally, the first experiment capped out at 12,599 tokens/second with FP32. <code>nvtop</code> showed the GPU usage at 100%, so let's say (again, this is very approximate) that we were getting about 35.58 TFLOPs and that enabled 12,599 tokens/second.</p>
<p>We wound up training at about 19,921 tokens/second after adding in mixed precision and using the tensor cores. So, hand-wavingly we can say that we were getting</p>
<p>19,92112,599×35.58=56.26TFLOPs</p>
<p>Now, we trained for 44 hours (48 including validation), so the total number of training FLOPs should have been the number of seconds in that times the total FLOPS 6 of 56.27×1012</p>
<p>44×60×60×56.27×1012=8.91×1018</p>
<p>That's pleasingly close to the 3.19×1018 above! I can easily imagine that the stack we're using could somewhat-more-than-halve performance from the theoretically optimal, or that we're running at 50% of the GPU's theoretical capacity, or some combination of the two. We're in the same order of magnitude, and for a Fermi approximation, that's what matters.</p>
<p>Now, looking at figure 3 in the Chinchilla paper, their IsoFLOP curves (each one showing the loss they got on their training set for models of a particular size, using the same number of FLOPs for each curve), we can see that the top one, which is training runs of 6×1018 FLOPs, the lowest point is pretty much bang-on the 168M point on the X axis.</p>
<p>So that is at least reassuring that we did do a proper Chinchilla-optimal train here. (Their loss on that chart is showing 3, but they're using a different dataset, so I don't think it's comparable.)</p>
<h3 id="but-why-is-our-model-worse-than-openais">But why is our model worse than OpenAI's?<a class="headerlink" href="#but-why-is-our-model-worse-than-openais" title="Permanent link">&para;</a></h3>
<p>Apart from the obvious answer of "skill issue", let's see if there are any obvious reasons why the base model I've trained (and retrained) in this post is worse than the original OpenAI GPT-2 small. Let's review the results first:</p>
<p>| FineWeb train | FineWeb-Edu train | FineWeb-Edu extended train | OpenAI weights<br />
---|---|---|---|---<br />
Val loss on own dataset | 3.94 | 3.693 | 3.661 | 2.80 7<br />
Val loss on FineWeb dataset | 3.94 | 4.16 | 4.13 | 3.50<br />
Alpaca answers judged by GPT-5.1 | 16.14 | 15.18 | 16.62 | 20.39  </p>
<p>The first row is not super-interesting, it's the second and third that matter.</p>
<ul>
<li>On <em>our own</em> validation set from FineWeb, our we have OpenAI &gt; our FineWeb train &gt; our FineWeb-Edu extended train &gt; our FineWeb-Edu train</li>
<li>On the answers judged by GPT-5.1 after instruction fine-tuning, we have OpenAI &gt; our FineWeb-Edu extended train &gt; our FineWeb train &gt; our FineWeb-Edu train</li>
</ul>
<p>OpenAI is clearly winning by quite some margin! Earlier on I assumed that the difference was that they trained on more data, but let's be a bit more systematic here.</p>
<p>What specific differences do we have to the original train? Again, the amount of data in the paper is frustratingly limited, but:</p>
<h4 id="amount-of-training-data">Amount of training data<a class="headerlink" href="#amount-of-training-data" title="Permanent link">&para;</a></h4>
<p>Right at the start, I estimated that the WebText dataset they trained on was about 10B tokens. We've trained on 3.2B tokens for two of our models, and 6.4B tokens for the extended train one.</p>
<p>That could well have an effect. There's more information in their larger dataset, both in terms of raw facts like "Jane Austen wrote Pride and Prejudice", and in terms of information about the structure of language.</p>
<p>On the other hand, their dataset is, as they say, comprised of the contents of web pages that were linked from Reddit posts with more than three upvotes. FineWeb (and even more FineWeb-Edu) is a much more curated dataset, so you would expect it has more facts, and better structure -- less of the slop and junk that Andrej Karpathy talked about in his interview with Dwarkesh Patel.</p>
<p>So I'm not sure that this is it, but it's worth keeping in mind.</p>
<h4 id="number-of-epochs">Number of epochs<a class="headerlink" href="#number-of-epochs" title="Permanent link">&para;</a></h4>
<p>Again, we don't know how many epochs they trained on, but the report I linked to right at the start of this post estimated that they trained for 60, while I calculated based on their numbers that it would be 41 epochs with WebText.</p>
<p>It certainly makes sense that grinding along, epoch after epoch, will get your loss down, at least on the training set! And there's also a phenomenon with certain kinds of neural networks where if keep training past the point where you're overfitting (that is, validation loss starts rising while training loss continues to fall), suddenly the model can have an "aha" moment and <a href="https://arxiv.org/abs/2201.02177">start generalising again</a>. 8</p>
<p>It's not quite comparable, because it was not a second epoch, but rather continued training with more data, but we were able to eke out an extra reduction of 0.032 in loss by training our FineWeb-Edu model for twice as long. If we'd trained it for 40 times as long, then we presumably would have managed to grind it down even further. I have no idea how much further we could get it, but I'd guess that it's going to be worse than linear (that is, each extra two days gets you less loss reduction than the previous) -- so we can bound the loss reduction at a <em>maximum</em> of 39×0.032=1.248.</p>
<p>So... maybe? It would be a dull experiment to run, though, taking 78 days. If I want to do that, it would be better to find a way to do it quickly, so that I can get a better feedback loop going. The reason this post has taken so long has in part been because each training run has taken so long (as well as trips to London and other life stuff).</p>
<h4 id="architectural-differences">Architectural differences<a class="headerlink" href="#architectural-differences" title="Permanent link">&para;</a></h4>
<p>The original GPT-2 model from OpenAI had bias on the Wq, Wk and Wv projections -- that is, they were normal NN biased linear layers rather than simple matrices, so they did a projection into their respective spaces followed by a translation. In the book, Raschka says that this is not normally done these days, which is why I didn't do it for this base model train.</p>
<p>But perhaps it actually is valuable with this architecture or size? Modern models presumably differ in multiple ways, and perhaps the bias would have been useful for this old design.</p>
<p>Likewise, weight-tying -- the original GPT-2 re-used its embedding matrix to do the final projection from embedding space to vocab space, rather than having a separate one. That seems intuitively clever but not necessarily "right", given that it gives the model less flexibility in what it can output from the last layer. But perhaps with this size and architecture, it's the right thing to do?</p>
<h4 id="dropout">Dropout<a class="headerlink" href="#dropout" title="Permanent link">&para;</a></h4>
<p>Contrariwise, having made those two changes to GPT-2 because I believed that modern models don't work that way, there was one "modern" change that I didn't make. In his post on the architectural changes since GPT-2, Raschka mentioned that dropout is normally not used nowadays. This looked to me like it was due to the move to single-epoch training. But single-epoch training was exactly what we were doing in this post! Perhaps I was holding myself back by keeping dropout in place.</p>
<h4 id="the-learning-rate">The learning rate<a class="headerlink" href="#the-learning-rate" title="Permanent link">&para;</a></h4>
<p>I don't have a good intuition as to what the right level is for this at the moment. My code blindly uses the optimiser setup from the book:</p>
<div class="language-text highlight"><pre><span></span><code>    optimizer = torch.optim.AdamW(
        model.parameters(),
        lr=0.0004, weight_decay=0.1
    )
</code></pre></div>
<p>I have at best a vague understanding of how those work, at least when using an optimiser (LR for simple gradient descent isn't too hard to understand, although it's hard to work out an intuition for what the right value might be in any given case). Additionally, in the Chinchilla paper, they talk about using a cosine function to vary the learning rate, which is something I'm completely unfamiliar with.</p>
<h4 id="the-precision">The precision<a class="headerlink" href="#the-precision" title="Permanent link">&para;</a></h4>
<p>I gained about a day in training time by using AMP and the TF32 tensor cores; however, I lost precision. I don't know for sure, but I suspect that the original weights were trained with pure full-fat FP32. Perhaps reducing precision lost something? I know that modern models are often trained with lower precisions, but perhaps that's balanced out by something else?</p>
<h4 id="the-batch-size">The batch size<a class="headerlink" href="#the-batch-size" title="Permanent link">&para;</a></h4>
<p>This is the one that I think it least likely, but it's worth mentioning. The post that I linked to estimating the size of the training run for GPT-2 small mentioned that they used a batch size of 512, which (of course) is completely impossible on consumer hardware like mine. Indeed, I think you'd be lucky to get 512 onto a single 8-GPU node -- we're talking serious cluster training scale here. Larger batches lead to more stable updates to the gradients. So maybe that helped for OpenAI when they did their train? I suspect it did, but I'm pretty much certain that it's not a large part of the difference.</p>
<p>(Counterpoint: Gemini thinks that this might actually be a big part of the problem! It recommends using gradient accumulation -- that is, not stepping the optimiser every iteration, but instead giving gradients time to build up -- as a way of getting a larger batch effective batch size.)</p>
<h4 id="exploding-gradients">Exploding gradients<a class="headerlink" href="#exploding-gradients" title="Permanent link">&para;</a></h4>
<p>While it doesn't look like we had any issues with these on the original FineWeb and FineWeb-Edu trains, they definitely did kick in on the extended Edu train. The code to clip them is easy enough, and I think it's likely that the original GPT-2 trains would have had it. I doubt this was a major part of the difference, but it probably would have helped, at least a bit.</p>
<hr />
<p>Anyway, I think that's it in terms of differences that I can see between my train and OpenAI's (as always, comments welcome -- let me know if you spot any others!), so it's time to (finally) wrap this post up.</p>
<h3 id="conclusion">Conclusion<a class="headerlink" href="#conclusion" title="Permanent link">&para;</a></h3>
<p>At the start of this (ridiculously long) post, I asked the question: can we train a GPT-2 style base model at home on a single RTX 3090. The answer is a resounding "yes we can", which is great! Training base models: not just for the GPU-rich. If you have a couple of days and a decent graphics card, you can train a Chinchilla-optimal GPT-2 pretty easily.</p>
<p>But the model itself isn't quite as good as the original GPT-2 small one, and I have some ideas about why that might be. Testing any of those would take quite a long time, given that each training run takes two days.</p>
<p>Now, my next planned step was to see whether I could work out how to move this up to the cloud and train the same model on an 8x A100 or similar machine on Lambda Labs. This still sounds like an excellent plan! With his <code>nanochat</code> project, Karpathy trains a larger model on more tokens in four hours; if we could get the experiment time down to one hour (plausible if training time is linear in both tokens and parameters) then it would be much easier to check out those hypotheses above. 9</p>
<p>So, I think that's still the right way to go: after training a base model at home for free (if you ignore the electricity costs -- and it's cold enough in Lisbon right now that the heat from the PC was probably saving me money on my home heating bill -- and the cost of having bought the RTX 3090 in the first place), the next step is to see how cheaply we can train it in the cloud.</p>
<p>Stay tuned :-)</p>
<p><a href="/2026/01/llm-from-scratch-29-ddp-training-a-base-model-in-the-cloud">Here's a link to the next post in this series</a>.</p>
<hr />
<ol>
<li>
<p>It's useful here, but it does make me wonder how good FineWeb would be for training a base model with a longer context length, however. ↩</p>
</li>
<li>
<p>There are ways to get comparable numbers even with a different tokeniser, using a bits-per-byte or nats-per-byte measure. Let's say we're using the normal cross entropy loss with the natural logarithm; that means that loss is expressed in nats. So you add up all of the per-token losses and divide it by the number of bytes across all of the inputs you've seen, and that would give you nats-per-byte. Likewise, if you used log2 for cross entropy, you'd get bits-per-byte. The latter is used in the Chinchilla paper (eg. table A5) as a way to compare their model with the Gopher model. I did consider digging into this a bit, but I think it's a bit of a side quest for now. ↩</p>
</li>
<li>
<p>Those evals cost me $0.09 in API credits, which is actually a little more than I was expecting -- there were some responses which took quite a while to come back, though, and I believe that the GPT 5.1 model spends time thinking when it seems appropriate, so perhaps I spent a bit on thinking tokens. ↩</p>
</li>
<li>
<p>Apart from a reference to a "dense layer", which I'm unsure about -- I believe it's the linear feed-forward layer after the attention calculations, though, as that doesn't appear elsewhere, and the calculation looks right. I also noticed that they don't have any terms in there for things like normalisation, which seems odd for such a carefully-worked-out formula; I assume they are small enough to vanish into the noise. ↩</p>
</li>
<li>
<p>If you want a more careful calculation of the numbers -- and indeed a really nice explanation of some of the details of the Chinchilla paper, I recommend <a href="https://tomekkorbak.com/2022/10/10/compute-optimal-gpt2/">this blog post from Tomek Korbak</a>. ↩</p>
</li>
<li>
<p>I hate that we appear to have settled on FLOPs with a lower-case "s" for "floating-point operations" when "FLOPS" (and equivalently MFLOPS, GFLOPS, TFLOPS) with an upper-case "S" already meant "floating-point operations per second" because the difference in capitalisation should really not change the units. But here we are. ↩</p>
</li>
<li>
<p>I estimated the OpenAI weights loss on their own dataset by taking the perplexity number for the small model from figure 4, which is about 16.5, and then taking its natural log. ↩</p>
</li>
<li>
<p>The authors of the paper call it "grokking", which is a great name, but is so overloaded in the context of LLMs (even if you disregard xAI's <a href="https://x.ai/grok">Grok</a>) that I'm slightly loath to use it here. This phenomenon also looks somewhat more limited in scope than I thought -- I'd been under the impression that it happens a lot with LLMs, but it looks like it's more a thing that happens with small models trained on very structured datasets. ↩</p>
</li>
<li>
<p>It would also be interesting to see how easy it is to offload the optimiser to the CPU: in my old fine-tuning experiments I found that freed up a ton of VRAM, so we could benefit from that and maybe get the batch size up to something closer to the 512 that OpenAI apparently trained with. ↩</p>
</li>
</ol>
<p><a href="/2025/11/smart-instruction-following-and-prompt-injection">« Why smart instruction-following makes prompt injection easier</a> <a href="/2026/01/llm-from-scratch-29-ddp-training-a-base-model-in-the-cloud">Writing an LLM from scratch, part 29 -- using DistributedDataParallel to train a base model from scratch in the cloud »</a></p>
<p>Copyright (c) 2006-2026 by Giles Thomas. This work is licensed under a <a href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>. </p>







  
    
  
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="最后更新">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1zM12.5 7v5.2l4 2.4-1 1L11 13V7zM11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-iso_date" title="2026年2月6日 08:52:17 UTC">2026-02-06</span>
  </span>

    
    
    
    
  </aside>


  



  <form class="md-feedback" name="feedback" hidden>
    <fieldset>
      <legend class="md-feedback__title">
        这篇文章有帮助吗？
      </legend>
      <div class="md-feedback__inner">
        <div class="md-feedback__list">
          
            <button class="md-feedback__icon md-icon" type="submit" title="有帮助" data-md-value="1">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5 9v12H1V9zm4 12a2 2 0 0 1-2-2V9c0-.55.22-1.05.59-1.41L14.17 1l1.06 1.06c.27.27.44.64.44 1.05l-.03.32L14.69 8H21a2 2 0 0 1 2 2v2c0 .26-.05.5-.14.73l-3.02 7.05C19.54 20.5 18.83 21 18 21zm0-2h9.03L21 12v-2h-8.79l1.13-5.32L9 9.03z"/></svg>
            </button>
          
            <button class="md-feedback__icon md-icon" type="submit" title="没帮助" data-md-value="0">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 15V3h4v12zM15 3a2 2 0 0 1 2 2v10c0 .55-.22 1.05-.59 1.41L9.83 23l-1.06-1.06c-.27-.27-.44-.64-.44-1.06l.03-.31.95-4.57H3a2 2 0 0 1-2-2v-2c0-.26.05-.5.14-.73l3.02-7.05C4.46 3.5 5.17 3 6 3zm0 2H5.97L3 12v2h8.78l-1.13 5.32L15 14.97z"/></svg>
            </button>
          
        </div>
        <div class="md-feedback__note">
          
            <div data-md-value="1" hidden>
              
              
                
              
              
              
                
                
              
              感谢反馈！
            </div>
          
            <div data-md-value="0" hidden>
              
              
                
              
              
              
                
                
              
              感谢反馈！我们会改进。
            </div>
          
        </div>
      </div>
    </fieldset>
  </form>


                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2026 - OpenClaw
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        
<div class="md-social">
  
    
    
    
    
    <a href="https://github.com/mrgolftech" target="_blank" rel="noopener" title="GitHub" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../..", "features": ["navigation.instant", "navigation.tracking", "navigation.tabs", "navigation.sections", "navigation.expand", "navigation.top", "search.suggest", "search.highlight", "search.share", "content.code.copy", "content.action.edit"], "search": "../../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.79ae519e.min.js"></script>
      
    
  </body>
</html>