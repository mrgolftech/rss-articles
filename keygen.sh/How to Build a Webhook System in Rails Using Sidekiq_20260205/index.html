
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="技术博客文章聚合 - Hacker News 2025年最受欢迎的博客">
      
      
        <meta name="author" content="OpenClaw">
      
      
        <link rel="canonical" href="https://mrgolftech.github.io/rss-articles/keygen.sh/How%20to%20Build%20a%20Webhook%20System%20in%20Rails%20Using%20Sidekiq_20260205/">
      
      
      
      
        
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.3">
    
    
      
        <title>How to Build a Webhook System in Rails Using Sidekiq - Hacker News 精选博客</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.484c7ddc.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      
  


    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#how-to-build-a-webhook-system-in-rails-using-sidekiq" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="Hacker News 精选博客" class="md-header__button md-logo" aria-label="Hacker News 精选博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Hacker News 精选博客
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              How to Build a Webhook System in Rails Using Sidekiq
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="切换到深色模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换到深色模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="切换到浅色模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换到浅色模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="分享" aria-label="分享" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/mrgolftech/rss-articles" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    rss-articles
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
  
    
  
  首页

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../blogs/" class="md-tabs__link">
        
  
  
    
  
  所有博客

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Hacker News 精选博客" class="md-nav__button md-logo" aria-label="Hacker News 精选博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Hacker News 精选博客
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/mrgolftech/rss-articles" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    rss-articles
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    首页
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../blogs/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    所有博客
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  


  
    <a href="https://github.com/mrgolftech/rss-articles/edit/master/docs/keygen.sh/How to Build a Webhook System in Rails Using Sidekiq_20260205.md" title="编辑此页" class="md-content__button md-icon" rel="edit">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75z"/></svg>
    </a>
  
  


<h1 id="how-to-build-a-webhook-system-in-rails-using-sidekiq">How to Build a Webhook System in Rails Using Sidekiq<a class="headerlink" href="#how-to-build-a-webhook-system-in-rails-using-sidekiq" title="Permanent link">&para;</a></h1>
<p><strong>来源:</strong> https://keygen.sh
<strong>链接:</strong> https://keygen.sh/blog/how-to-build-a-webhook-system-in-rails-using-sidekiq/
<strong>日期:</strong> Wed, 16 Jun 2021 05:00:00 GMT</p>
<hr />
<p><a href="https://github.com/keygen-sh/keygen-api">Keygen is Fair SourceStar us on GitHub <em>arrow_right_alt</em></a></p>
<p><a href="/"> Keygen</a></p>
<p><em>menu</em></p>
<ul>
<li>Use Cases <em>expand_more</em><ul>
<li><a href="/software-licensing-api/"> <em>lock_open</em> Software Application Licensing</a>Use Keygen's flagship software licensing API to add license key validation, device activation and entitlements to any software product. </li>
<li><a href="/software-distribution-api/"><em>cloud_download</em> Software Artifact Distribution</a>Use Keygen's supplementary software distribution API to securely deliver artifacts and offer automatic updates to licensed users. </li>
<li><a href="/integrate/zapier/"><em>bolt</em> No-code Licensing Automation</a>Use Zapier to integrate Keygen with your favorite tools, such as Stripe for payments, and Postmark for transactional emails. No code required. </li>
<li><a href="/for-on-prem-software/">__For On-Premise/Multi-Prem</a></li>
<li><a href="/for-go-programs/"> __For Go Programs</a></li>
<li><a href="/for-ios-apps/"> __For iOS Apps</a></li>
<li><a href="/for-mac-apps/"> __For Mac Applications</a></li>
<li><a href="/for-android-apps/"> __For Android Apps</a></li>
<li><a href="/for-windows-programs/"> __For Windows Programs</a></li>
<li><a href="/for-docker-images/"> __For Container Images</a></li>
<li><a href="/for-electron-apps/"> __For Electron Apps</a></li>
<li><a href="/for-wordpress-plugins/"> __For WordPress Plugins</a></li>
<li><a href="/for-tauri-apps/"> For Tauri Apps</a></li>
<li><a href="/for-python-packages/"> __For Python Packages</a></li>
<li><a href="/for-composer-packages/"> __For PHP Packages</a></li>
<li><a href="/for-npm-packages/"> __For Node Packages</a></li>
<li><a href="/for-rubygems/"> __For RubyGems</a></li>
</ul>
</li>
<li>Demos <em>expand_more</em><ul>
<li><a href="/demo/license-activation-portal/"> <em>phonelink_lock</em> License Activation Portal Demo</a></li>
<li><a href="/demo/license-key-validation/"> <em>vpn_key</em> License Key Validation Demo</a></li>
<li><a href="https://app.keygen.sh/demo">Try Dashboard Demo </a></li>
</ul>
</li>
<li>Developers <em>expand_more</em><ul>
<li><a href="/docs/self-hosting/"> <em>dns</em> Self-Host Keygen</a>Learn how to self-host Keygen's Community Edition for free, or self-host our Enterprise Edition for your business. </li>
<li><a href="/docs/relay/"><em>lan</em> Keygen Relay NEW</a>Use Keygen Relay to securely distribute node-locked licenses in offline and air-gapped environments. </li>
<li><a href="/docs/cli/"><em>terminal</em> Developer CLI</a>Use Keygen's official CLI to sign and publish software releases. Integrate with our SDKs for secure automatic upgrades. </li>
<li><a href="/docs/"><em>import_contacts</em> Documentation </a></li>
<li><a href="/docs/api/"><em>data_object</em> API Reference </a></li>
<li><a href="/changelog/"><em>update</em> Changelog </a></li>
<li><a href="/security/"><em>security</em> Security </a></li>
<li><a href="https://github.com/keygen-sh/keygen-api"><em>code</em> Source Code </a></li>
</ul>
</li>
<li>Company <em>expand_more</em><ul>
<li><a href="https://github.com/keygen-sh/keygen-api"> __Read the Source Code</a> Keygen is an Fair Source software licensing and distribution API. View the source code on GitHub to learn more. <a href="/build-vs-buy/"><em>compare_arrows</em> Build vs Buy</a>Businesses of all sizes face the question of whether to build or buy a licensing solution. </li>
<li><a href="/open-source/"><em>volunteer_activism</em> Open Source </a></li>
<li><a href="/license/"><em>description</em> Fair Source </a></li>
<li><a href="/about/"><em>business</em> About </a></li>
<li><a href="/jobs/"><em>badge</em> Careers </a></li>
<li><a href="/blog/"><em>article</em> Blog </a></li>
<li><a href="/cdn-cgi/l/email-protection#8cfff9fcfce3fef8cce7e9f5ebe9e2a2ffe4"><em>support</em> Get Support </a></li>
</ul>
</li>
<li><a href="/pricing/">Pricing </a></li>
<li><a href="https://app.keygen.sh/login">Log in </a></li>
<li><a href="https://app.keygen.sh/register?plan=984180df-07b3-4dc1-b138-ca68a0f913ed">Sign Up</a></li>
</ul>
<h1 id="how-to-build-a-webhook-system-in-rails-using-sidekiq_1">How to Build a Webhook System in Rails Using Sidekiq<a class="headerlink" href="#how-to-build-a-webhook-system-in-rails-using-sidekiq_1" title="Permanent link">&para;</a></h1>
<p>Wednesday, Jun 16th 2021</p>
<p>It's 2021, and we're in the heyday of SaaS. As the SaaS economy has grown, so has the need for these services to communicate events to each other asynchronously. Complex business logic can often span across both internal and external services, and one way external communication is accomplished is with a design pattern called "webhooks."</p>
<p>If you've ever integrated with an API service such as <a href="https://stripe.com">Stripe</a>, you're probably well aware of what a webhook is. For Stripe, events like <code>customer.created</code> and <code>invoice.*</code> are <em>table-stakes</em> for many businesses. (At least they are for ours.)</p>
<p>Many other services, and even our own API, send webhooks for important events. There are even <a href="https://zapier.com">entire businesses built on the concept of webhooks</a>.</p>
<p>Suffice it to say â webhooks are here to stay. They've gone from nice-to-have to must-have for any sort of API-based SaaS.</p>
<p>Speaking of SaaS â</p>
<p>There are a number of webhooks-as-a-service options out there, such as <a href="https://hostedhooks.com/">HostedHooks</a> and YC-backed <a href="https://www.svix.com/">Svix</a>. But much to my dismay, none of these existed back when I started Keygen, so I figured I'd share the knowledge on how I've built mine over the years.</p>
<hr />
<p>It's actually kind of funny â back in 2017, I had a similar idea scribbled down in my "notebook of start up ideas", but never got around to building it as I've been too busy with Keygen over the past 5 years. But I'm glad others have ran with the idea.</p>
<hr />
<p>But running a webhook system yourself has its, ehmâ¦ quirks? The quirks are usually due to misbehaved webhook endpoints, but we'll touch more on that later. It seems like every month I'm adjusting things to handle new quirks.</p>
<p>Another thing that can take some time to get right is a retry cadence that works for both you and your users, which we'll also cover in a bit more detail later on.</p>
<p>Anyways â</p>
<p>These days, you may want to spend some time and ask yourself the build-vs-buy question. Using a third-party for webhooks may save you time (and money.)</p>
<p>But today, we're going to build. And we can move fast when we're on Rails.</p>
<h2 id="defining-our-webhook-resources">Defining our webhook resources<a class="headerlink" href="#defining-our-webhook-resources" title="Permanent link">&para;</a></h2>
<p>In its simplest form, a webhook system is built on top of the <a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">pub/sub design pattern</a>:</p>
<blockquote>
<p>Some event <strong><em>e</em></strong> happens in our service, and we want to notify all subscribers <strong><em>s</em></strong>.</p>
</blockquote>
<p>In the context of a webhook, an event <strong><em>e</em></strong> will consist of the following information:</p>
<ul>
<li>An <code>event</code> â this will be an event name, for example <code>payment.successful</code>, <code>license.expired</code>, or <code>user.updated</code>.</li>
<li>A <code>payload</code> â this will be the data we'll be sending to subscribers. Typically, it's a snapshot of the affected resource. For example, the <code>user.updated</code> event may send a snapshot of the user after it was updated.</li>
</ul>
<p>And a subscriber <strong><em>s</em></strong> will consist of the following information:</p>
<ul>
<li>A <code>url</code> â this will be the URL that the webhook is delivered to.</li>
</ul>
<p>Since we don't know how big the set of <strong><em>s</em></strong> is, we don't want to run these notifications inline with our normal application code. Why? Because the bigger <strong><em>s</em></strong> is, the slower our app will be, and we also have no control over deliveribility speed, other than through setting an upper bound on webhook execution time with a timeout.</p>
<p>So rather than run inline, we'll need some sort of queueing and background job system so that we can asynchronously process notifications to each subscriber.</p>
<p>If you've ever used Rails, you're probably familiar with the ubiquitous <a href="https://sidekiq.org">Sidekiq</a> gem.</p>
<p>Sidekiq is powerful background job library that we'll be using to queue up webhook events and process them asynchronously. And we'll also be leaning on Sidekiq to handle the bulk of our retry logic (more on this later.)</p>
<p><strong>Have an open-source library you 'd like to dual-license like Sidekiq?</strong> Dual-licensing open-source is all the rage these days, and we can help with that. By using our licensing and distribution APIs, you can easily distribute commercial license keys and allow license-gated downloads of your "premium" gems or libraries. </p>
<p>The webhook system we're going to build today is actually modeled after Keygen's webhook system. As of writing, Keygen has processed nearly <strong>250 million</strong> webhook events using Sidekiq. (Thanks for your work, Mike!)</p>
<h2 id="building-out-our-models">Building out our models<a class="headerlink" href="#building-out-our-models" title="Permanent link">&para;</a></h2>
<p>To kick things off, let's create a new Rails 6 API application:</p>
<div class="language-text highlight"><pre><span></span><code>$ rails new . --api --database postgresql \

    --skip-active-storage \

    --skip-action-cable

$ rails new . --api --database postgresql \
    --skip-active-storage \
    --skip-action-cable
_content_copy_
</code></pre></div>
<p>Then we'll want to create our first table, a <strong>webhook endpoint</strong>. These are going to represent the subscribers <strong><em>s</em></strong> in our webhook system.</p>
<p>Let's generate a new migration:</p>
<div class="language-text highlight"><pre><span></span><code>$ rails g migration CreateWebhookEndpoints

$ rails g migration CreateWebhookEndpoints
_content_copy_
</code></pre></div>
<p>Next, we'll want to define the schema, which only consists of a <code>url</code>:</p>
<div class="language-text highlight"><pre><span></span><code>class CreateWebhookEndpoints &lt; ActiveRecord::Migration[5.2]

  def change

    create_table :webhook_endpoints do |t|

      t.string :url, null: false



      t.timestamps null: false

    end

  end

end

class CreateWebhookEndpoints &lt; ActiveRecord::Migration[5.2]
  def change
    create_table :webhook_endpoints do |t|
      t.string :url, null: false

      t.timestamps null: false
    end
  end
end
_content_copy_
</code></pre></div>
<p>Now before we run our migration, let's also go ahead and define the other table in our system, the <strong>webhook event</strong>. As the name implies, these will represent the events <strong><em>e</em></strong> in our webhook system. Let's generate another migration:</p>
<div class="language-text highlight"><pre><span></span><code>$ rails g migration CreateWebhookEvents

$ rails g migration CreateWebhookEvents
_content_copy_
</code></pre></div>
<p>Then let's define the schema, which consists of a reference to a webhook endpoint, as well as the <code>event</code> and <code>payload</code> attributes we discussed earlier:</p>
<div class="language-text highlight"><pre><span></span><code>class CreateWebhookEvents &lt; ActiveRecord::Migration[5.2]

  def change

    create_table :webhook_events do |t|

      t.integer :webhook_endpoint_id, null: false, index: true



      t.string :event, null: false

      t.text :payload, null: false



      t.timestamps null: false

    end

  end

end

class CreateWebhookEvents &lt; ActiveRecord::Migration[5.2]
  def change
    create_table :webhook_events do |t|
      t.integer :webhook_endpoint_id, null: false, index: true

      t.string :event, null: false
      t.text :payload, null: false

      t.timestamps null: false
    end
  end
end
_content_copy_
</code></pre></div>
<p>Now let's go ahead and run those migrations:</p>
<div class="language-text highlight"><pre><span></span><code>$ rails db:migrate

$ rails db:migrate
_content_copy_
</code></pre></div>
<p>Next, we'll want to define the 2 models. We'll start with the webhook endpoint:</p>
<div class="language-text highlight"><pre><span></span><code>class WebhookEndpoint &lt; ApplicationRecord

  has_many :webhook_events, inverse_of: :webhook_endpoint



  validates :url, presence: true

end

class WebhookEndpoint &lt; ApplicationRecord
  has_many :webhook_events, inverse_of: :webhook_endpoint

  validates :url, presence: true
end
_content_copy_
</code></pre></div>
<p>Lastly, we'll define the webhook event model:</p>
<div class="language-text highlight"><pre><span></span><code>class WebhookEvent &lt; ApplicationRecord

  belongs_to :webhook_endpoint, inverse_of: :webhook_events



  validates :event, presence: true

  validates :payload, presence: true

end

class WebhookEvent &lt; ApplicationRecord
  belongs_to :webhook_endpoint, inverse_of: :webhook_events

  validates :event, presence: true
  validates :payload, presence: true
end
_content_copy_
</code></pre></div>
<p>Okay, phew â</p>
<p>Let's go ahead and test out what we've got in the console:</p>
<div class="language-text highlight"><pre><span></span><code>$ rails c

&gt; WebhookEndpoint.create!(url: &#39;https://functions.ecorp.example/webhooks&#39;)

# =&gt; #&lt;WebhookEndpoint

#       id: 1,

#       url: &quot;https://functions.ecorp.example/webhooks&quot;,

#       created_at: &quot;2021-06-14 22:14:53.587473000 +0000&quot;,

#       updated_at: &quot;2021-06-14 22:14:53.587473000 +0000&quot;

#     &gt;

&gt; WebhookEvent.create!(

    webhook_endpoint: _,

    event: &#39;events.test&#39;,

    payload: { test: 1 }

  )

# =&gt; #&lt;WebhookEvent

#       id: 1,

#       webhook_endpoint_id: 1,

#       event: &quot;events.test&quot;,

#       payload: { &quot;test&quot; =&gt; 1 },

#       created_at: &quot;2021-06-14 22:17:06.908392000 +0000&quot;,

#       updated_at: &quot;2021-06-14 22:17:06.908392000 +0000&quot;

#     &gt;

$ rails c
&gt; WebhookEndpoint.create!(url: &#39;https://functions.ecorp.example/webhooks&#39;)
# =&gt; #&lt;WebhookEndpoint
#       id: 1,
#       url: &quot;https://functions.ecorp.example/webhooks&quot;,
#       created_at: &quot;2021-06-14 22:14:53.587473000 +0000&quot;,
#       updated_at: &quot;2021-06-14 22:14:53.587473000 +0000&quot;
#     &gt;
&gt; WebhookEvent.create!(
    webhook_endpoint: _,
    event: &#39;events.test&#39;,
    payload: { test: 1 }
  )
# =&gt; #&lt;WebhookEvent
#       id: 1,
#       webhook_endpoint_id: 1,
#       event: &quot;events.test&quot;,
#       payload: { &quot;test&quot; =&gt; 1 },
#       created_at: &quot;2021-06-14 22:17:06.908392000 +0000&quot;,
#       updated_at: &quot;2021-06-14 22:17:06.908392000 +0000&quot;
#     &gt;
_content_copy_
</code></pre></div>
<h2 id="building-our-webhook-worker">Building our webhook worker<a class="headerlink" href="#building-our-webhook-worker" title="Permanent link">&para;</a></h2>
<p>Now that we have an event queued up, we need to process it. We've talked a lot about Sidekiq, so let's write our webhook worker.</p>
<h3 id="installing-dependencies">Installing dependencies<a class="headerlink" href="#installing-dependencies" title="Permanent link">&para;</a></h3>
<p>To start, let's go ahead and add Sidekiq and Redis to our <code>Gemfile</code>:</p>
<div class="language-text highlight"><pre><span></span><code>+gem &#39;sidekiq&#39;

+gem &#39;redis&#39;

gem &#39;sidekiq&#39; # [tl! ++]
gem &#39;redis&#39; # [tl! ++]
_content_copy_
</code></pre></div>
<p>We're also going to need an HTTP library so that we can send webhook events to webhook endpoints. Let's add the popular <a href="https://github.com/httprb/http"><code>http.rb</code></a> gem.</p>
<div class="language-text highlight"><pre><span></span><code>+gem &#39;http&#39;

gem &#39;http&#39; # [tl! ++]
_content_copy_
</code></pre></div>
<p>And we'll run Bundler to install everything:</p>
<div class="language-text highlight"><pre><span></span><code>$ bundle

$ bundle
_content_copy_
</code></pre></div>
<h3 id="defining-our-webhook-worker">Defining our webhook worker<a class="headerlink" href="#defining-our-webhook-worker" title="Permanent link">&para;</a></h3>
<p>Next up we'll want to create a new <code>app/workers</code> directory for our worker classes to live in, to keep our Sidekiq workers distinct from any ActiveJobs.</p>
<div class="language-text highlight"><pre><span></span><code>$ mkdir app/workers

$ touch app/workers/webhook_worker.rb

$ mkdir app/workers
$ touch app/workers/webhook_worker.rb
_content_copy_
</code></pre></div>
<p>Now, let's define the base logic for our webhook worker. It's going to accept a webhook ID as an input parameter, use that to query the endpoint, then <code>POST</code> the event payload to the endpoint's URL. If it fails, it'll retry.</p>
<div class="language-text highlight"><pre><span></span><code>require &#39;http.rb&#39;



class WebhookWorker

  include Sidekiq::Worker



  def perform(webhook_event_id)

    webhook_event = WebhookEvent.find_by(id: webhook_event_id)

    return if

      webhook_event.nil?



    webhook_endpoint = webhook_event.webhook_endpoint

    return if

      webhook_endpoint.nil?



    # Send the webhook request with a 30 second timeout.

    response = HTTP.timeout(30)

                   .headers(

                     &#39;User-Agent&#39; =&gt; &#39;rails_webhook_system/1.0&#39;,

                     &#39;Content-Type&#39; =&gt; &#39;application/json&#39;,

                   )

                   .post(

                     webhook_endpoint.url,

                     body: {

                       event: webhook_event.event,

                       payload: webhook_event.payload,

                     }.to_json

                   )



    # Raise a failed request error and let Sidekiq handle retrying.

    raise FailedRequestError unless

      response.status.success?

  end



  private



  # General failed request error that we&#39;re going to use to signal

  # Sidekiq to retry our webhook worker.

  class FailedRequestError &lt; StandardError; end

end

require &#39;http.rb&#39;

class WebhookWorker
  include Sidekiq::Worker

  def perform(webhook_event_id)
    webhook_event = WebhookEvent.find_by(id: webhook_event_id)
    return if
      webhook_event.nil?

    webhook_endpoint = webhook_event.webhook_endpoint
    return if
      webhook_endpoint.nil?

    # Send the webhook request with a 30 second timeout.
    response = HTTP.timeout(30)
                   .headers(
                     &#39;User-Agent&#39; =&gt; &#39;rails_webhook_system/1.0&#39;,
                     &#39;Content-Type&#39; =&gt; &#39;application/json&#39;,
                   )
                   .post(
                     webhook_endpoint.url,
                     body: {
                       event: webhook_event.event,
                       payload: webhook_event.payload,
                     }.to_json
                   )

    # Raise a failed request error and let Sidekiq handle retrying.
    raise FailedRequestError unless
      response.status.success?
  end

  private

  # General failed request error that we&#39;re going to use to signal
  # Sidekiq to retry our webhook worker.
  class FailedRequestError &lt; StandardError; end
end
_content_copy_
</code></pre></div>
<p>As you can see, our webhook system is actually relatively simple. And it's going to stay that way apart from a little subscription management and some special-case error handling. But overall, you may be surprised at how "simple" this system is.</p>
<p>Since we're leaning on Sidekiq to handle queueing, processing and retries, all we <em>really</em> have to do is handle delivery. We're attempting delivery by sending an HTTP <code>POST</code> request to the endpoint's URL with a JSON-encoded payload:</p>
<div class="language-text highlight"><pre><span></span><code>{

  &quot;event&quot;: &quot;events.test&quot;,

  &quot;payload&quot;: {

    &quot;test&quot;: 1

  }

}

{
  &quot;event&quot;: &quot;events.test&quot;,
  &quot;payload&quot;: {
    &quot;test&quot;: 1
  }
}
_content_copy_
</code></pre></div>
<p><strong>A quick note:</strong> since we're raising an exception here, this is going to get a bitâ¦ <em>noisy.</em> I have some log line filters in place to ignore the verbose stack traces from <code>FailedRequestError</code>, so keep that idea tucked away. You can also silence the stack trace by overriding <code>FailedRequestError#backtrace</code>, e.g. <code>def backtrace = nil</code>. </p>
<p>This whole thing could probably be done without relying on errors for control flow, but I can't be bothered. It works as-is, and ignoring noisy log lines is cheap. </p>
<h3 id="delivering-our-first-webhook">Delivering our first webhook<a class="headerlink" href="#delivering-our-first-webhook" title="Permanent link">&para;</a></h3>
<p>Let's go ahead and attempt to deliver our first webhook event. For now, we'll run jobs inline from the console, rather than queue them:</p>
<div class="language-text highlight"><pre><span></span><code>$ rails c

&gt; WebhookWorker.new.perform(WebhookEvent.last.id)

# =&gt; Traceback (most recent call last):

#      2: from (irb):1

#      1: from app/workers/webhook_worker.rb:24:in `perform&#39;

#    HTTP::TimeoutError (execution expired)

$ rails c
&gt; WebhookWorker.new.perform(WebhookEvent.last.id)
# =&gt; Traceback (most recent call last):
#      2: from (irb):1
#      1: from app/workers/webhook_worker.rb:24:in `perform&#39;
#    HTTP::TimeoutError (execution expired)
_content_copy_
</code></pre></div>
<p>Unless you happen to have a server running at the endpoint you entered, you're probably going to get a timeout error after about 30 seconds.</p>
<p>Which brings us to our first error case: <strong>timeouts</strong>.</p>
<h3 id="handing-delivery-timeouts">Handing delivery timeouts<a class="headerlink" href="#handing-delivery-timeouts" title="Permanent link">&para;</a></h3>
<p>First thing's first â let's go ahead and update our worker class to rescue from that error class so that we can handle it more gracefully:</p>
<div class="language-text highlight"><pre><span></span><code> def perform(webhook_event_id)

   ...

+rescue HTTP::TimeoutError

+

 end

def perform(webhook_event_id)
  ...
rescue HTTP::TimeoutError # [tl! ++]
  # [tl! ++]
end
_content_copy_
</code></pre></div>
<p>But what does "gracefully" mean here? Well, let's think about this from a developer's perspective â what do they want to know? They probably want to know their webhook endpoint just timed out, right?</p>
<p>Ideally, we'd send them an alert. But we won't go that deep today. At the very least, we need a way to store an error on the webhook event model.</p>
<p>But rather than just store errors, why don't we go ahead and store the entire <code>response</code>? Providing visibility into what response the endpoint actually sent will offer a nice developer experience when they're tasked with debugging a webhook integration.</p>
<p>Rather than dig through logs, they can look at their recent failed webhook events.</p>
<p>Let's go ahead and generate a new migration for that:</p>
<div class="language-text highlight"><pre><span></span><code>$ rails g migration AddResponseToWebhookEvents

$ rails g migration AddResponseToWebhookEvents
_content_copy_
</code></pre></div>
<p>And we'll add a new <code>jsonb</code> column to our webhook events called <code>response</code>:</p>
<div class="language-text highlight"><pre><span></span><code>class AddResponseToWebhookEvents &lt; ActiveRecord::Migration[5.2]

  def change

    add_column :webhook_events, :response, :jsonb, default: {}

  end

end

class AddResponseToWebhookEvents &lt; ActiveRecord::Migration[5.2]
  def change
    add_column :webhook_events, :response, :jsonb, default: {}
  end
end
_content_copy_
</code></pre></div>
<p>Now let's adjust our worker to store the response object, both for typical responses as well as for newly discovered timeout errors:</p>
<div class="language-text highlight"><pre><span></span><code>def perform(webhook_event_id)

  webhook_event = WebhookEvent.find_by(id: webhook_event_id)

  return if

    webhook_event.nil?



  webhook_endpoint = webhook_event.webhook_endpoint

  return if

    webhook_endpoint.nil?



  # Send the webhook request with a 30 second timeout.

  response = HTTP.timeout(30)

                 .headers(

                   &#39;User-Agent&#39; =&gt; &#39;rails_webhook_system/1.0&#39;,

                   &#39;Content-Type&#39; =&gt; &#39;application/json&#39;,

                 )

                 .post(

                   webhook_endpoint.url,

                   body: {

                     event: webhook_event.event,

                     payload: webhook_event.payload,

                   }.to_json

                 )



  # Store the webhook response.

  webhook_event.update(response: {

    headers: response.headers.to_h,

    code: response.code.to_i,

    body: response.body.to_s,

  })



  # Raise a failed request error and let Sidekiq handle retrying.

  raise FailedRequestError unless

    response.status.success?

rescue HTTP::TimeoutError

  # This error means the webhook endpoint timed out. We can either

  # raise a failed request error to trigger a retry, or leave it

  # as-is and consider timeouts terminal. We&#39;ll do the latter.

  webhook_event.update(response: { error: &#39;TIMEOUT_ERROR&#39; })

end

def perform(webhook_event_id)
  webhook_event = WebhookEvent.find_by(id: webhook_event_id)
  return if
    webhook_event.nil?

  webhook_endpoint = webhook_event.webhook_endpoint
  return if
    webhook_endpoint.nil?

  # Send the webhook request with a 30 second timeout.
  response = HTTP.timeout(30)
                 .headers(
                   &#39;User-Agent&#39; =&gt; &#39;rails_webhook_system/1.0&#39;,
                   &#39;Content-Type&#39; =&gt; &#39;application/json&#39;,
                 )
                 .post(
                   webhook_endpoint.url,
                   body: {
                     event: webhook_event.event,
                     payload: webhook_event.payload,
                   }.to_json
                 )

  # Store the webhook response.
  webhook_event.update(response: {
    headers: response.headers.to_h,
    code: response.code.to_i,
    body: response.body.to_s,
  })

  # Raise a failed request error and let Sidekiq handle retrying.
  raise FailedRequestError unless
    response.status.success?
rescue HTTP::TimeoutError
  # This error means the webhook endpoint timed out. We can either
  # raise a failed request error to trigger a retry, or leave it
  # as-is and consider timeouts terminal. We&#39;ll do the latter.
  webhook_event.update(response: { error: &#39;TIMEOUT_ERROR&#39; })
end
_content_copy_
</code></pre></div>
<p>Okay, now that we've (hopefully) handled timeouts, let's try delivering the event again:</p>
<div class="language-text highlight"><pre><span></span><code>$ rails c

&gt; WebhookWorker.new.perform(WebhookEvent.last.id)

# =&gt; true

&gt; WebhookEvent.last.response

# =&gt; { &quot;error&quot; =&gt; &quot;TIMEOUT_ERROR&quot; }

$ rails c
&gt; WebhookWorker.new.perform(WebhookEvent.last.id)
# =&gt; true
&gt; WebhookEvent.last.response
# =&gt; { &quot;error&quot; =&gt; &quot;TIMEOUT_ERROR&quot; }
_content_copy_
</code></pre></div>
<p>Nice! As you can see, our <code>response</code> column now says there was a timeout error. We obviously don't want to continue using <code>ecorp.example</code> as our test server, so let's update our endpoint to something else, say, a Rails server on port <code>3000</code>.</p>
<p>In a new terminal pane, let's start up our Rails server:</p>
<div class="language-text highlight"><pre><span></span><code>rails s

rails s
_content_copy_
</code></pre></div>
<p>Then let's update our endpoint:</p>
<div class="language-text highlight"><pre><span></span><code>$ rails c

&gt; WebhookEndpoint.last.update!(url: &#39;http://localhost:3000/webhooks&#39;)

# =&gt; true

$ rails c
&gt; WebhookEndpoint.last.update!(url: &#39;http://localhost:3000/webhooks&#39;)
# =&gt; true
_content_copy_
</code></pre></div>
<p>Lastly, let's kick off a new webhook worker:</p>
<div class="language-text highlight"><pre><span></span><code>$ rails c

&gt; WebhookWorker.new.perform(WebhookEvent.last.id)

# =&gt; Traceback (most recent call last):

#      2: from (irb):17

#      1: from app/workers/webhook_worker.rb:76:in `perform&#39;

#    WebhookWorker::FailedRequestError (WebhookWorker::FailedRequestError)

&gt; WebhookEvent.last.response

# =&gt; { &quot;body&quot; =&gt; &quot;...&quot;, &quot;code&quot; =&gt; 404, &quot;headers&quot; =&gt; { ... } }

$ rails c
&gt; WebhookWorker.new.perform(WebhookEvent.last.id)
# =&gt; Traceback (most recent call last):
#      2: from (irb):17
#      1: from app/workers/webhook_worker.rb:76:in `perform&#39;
#    WebhookWorker::FailedRequestError (WebhookWorker::FailedRequestError)
&gt; WebhookEvent.last.response
# =&gt; { &quot;body&quot; =&gt; &quot;...&quot;, &quot;code&quot; =&gt; 404, &quot;headers&quot; =&gt; { ... } }
_content_copy_
</code></pre></div>
<p>As we can see, the worker is (correctly) raising the failed request error for the <code>404</code> response, which will signal Sidekiq to automatically retry the job. And you should also see a line in your server logs indicating the <code>404</code>:</p>
<div class="language-text highlight"><pre><span></span><code>ActionController::RoutingError (No route matches [POST] &quot;/webhooks&quot;):

ActionController::RoutingError (No route matches [POST] &quot;/webhooks&quot;):
_content_copy_
</code></pre></div>
<p>Now before we go any further, we need to adjust our webhook server to return a <code>204</code> response for the <code>/webhooks</code> route. To keep things simple, we'll add an inline <code>proc</code> handler that returns a basic Rack response.</p>
<p>Let's edit our <code>config/routes.rb</code> file with a new route:</p>
<div class="language-text highlight"><pre><span></span><code> Rails.application.routes.draw do

-  # For details on the DSL available within this file, see https://guides.rubyonrails.org/routing.html

+  post &#39;/webhooks&#39;, to: proc { [204, {}, []] }

 end

Rails.application.routes.draw do
  # For details on the DSL available within this file, see https://guides.rubyonrails.org/routing.html [tl! --]
  post &#39;/webhooks&#39;, to: proc { [204, {}, []] } # [tl! ++]
end
_content_copy_
</code></pre></div>
<p>And then let's attempt to deliver the webhook one more time again:</p>
<div class="language-text highlight"><pre><span></span><code>$ rails c

&gt; WebhookWorker.new.perform(WebhookEvent.last.id)

# =&gt; nil

&gt; WebhookEvent.last.response

# =&gt; { &quot;body&quot; =&gt; &quot;&quot;, &quot;code&quot; =&gt; 204, &quot;headers&quot; =&gt; { ... } }

$ rails c
&gt; WebhookWorker.new.perform(WebhookEvent.last.id)
# =&gt; nil
&gt; WebhookEvent.last.response
# =&gt; { &quot;body&quot; =&gt; &quot;&quot;, &quot;code&quot; =&gt; 204, &quot;headers&quot; =&gt; { ... } }
_content_copy_
</code></pre></div>
<p>Note the lack of a failed request error, and our status code is <code>204</code>. We should also see a log line in our Rails server logs indicating the request was sent:</p>
<div class="language-text highlight"><pre><span></span><code>Started POST &quot;/webhooks&quot; for ::1 at 2021-06-15 10:04:34 -0500

Started POST &quot;/webhooks&quot; for ::1 at 2021-06-15 10:04:34 -0500
_content_copy_
</code></pre></div>
<h2 id="broadcasting-our-webhook-events">Broadcasting our webhook events<a class="headerlink" href="#broadcasting-our-webhook-events" title="Permanent link">&para;</a></h2>
<p>Now, creating webhook events and delivering them inline from the console is kind of cumbersome. We've also been sending the same event every time. Let's write a service object that helps streamline the process of broadcasting new events to our webhook endpoints.</p>
<p>Let's create a new <code>services</code> directory, and a file for our new service object:</p>
<div class="language-text highlight"><pre><span></span><code>$ mkdir app/services

$ touch app/services/broadcast_webhook_service.rb

$ mkdir app/services
$ touch app/services/broadcast_webhook_service.rb
_content_copy_
</code></pre></div>
<p>Our service object is going to accept an <code>event</code> and a <code>payload</code>, and it will create a new webhook event for each endpoint and queue it up for delivery:</p>
<div class="language-text highlight"><pre><span></span><code>class BroadcastWebhookService

  def self.call(event:, payload:)

    new(event: event, payload: payload).call

  end



  def call

    WebhookEndpoint.find_each do |webhook_endpoint|

      webhook_event = WebhookEvent.create!(

        webhook_endpoint: webhook_endpoint,

        event: event,

        payload: payload,

      )



      WebhookWorker.perform_async(webhook_event.id)

    end

  end



  private



  attr_reader :event, :payload



  def initialize(event:, payload:)

    @event   = event

    @payload = payload

  end

end

class BroadcastWebhookService
  def self.call(event:, payload:)
    new(event: event, payload: payload).call
  end

  def call
    WebhookEndpoint.find_each do |webhook_endpoint|
      webhook_event = WebhookEvent.create!(
        webhook_endpoint: webhook_endpoint,
        event: event,
        payload: payload,
      )

      WebhookWorker.perform_async(webhook_event.id)
    end
  end

  private

  attr_reader :event, :payload

  def initialize(event:, payload:)
    @event   = event
    @payload = payload
  end
end
_content_copy_
</code></pre></div>
<p>In the real world, this service may only want to broadcast events to endpoints belonging to specific users, for example if your app is multi-tenant. But right now, we aren't going to worry about that sort of detail.</p>
<p>Let's test the service out in our console:</p>
<div class="language-text highlight"><pre><span></span><code>$ rails c

&gt; WebhookEvent.delete_all

# =&gt; 1

&gt; BroadcastWebhookService.call(event: &#39;events.test&#39;, payload: { test: 2 })

# =&gt; nil

&gt; WebhookEvent.last

# =&gt; #&lt;WebhookEvent

#       id: 2,

#       webhook_endpoint_id: 1,

#       event: &quot;events.test&quot;,

#       payload: { &quot;test&quot; =&gt; 2 },

#       created_at: &quot;2021-06-15 15:43:21.767801000 +0000&quot;,

#       updated_at: &quot;2021-06-15 15:43:21.767801000 +0000&quot;,

#       response: {}

#     &gt;

$ rails c
&gt; WebhookEvent.delete_all
# =&gt; 1
&gt; BroadcastWebhookService.call(event: &#39;events.test&#39;, payload: { test: 2 })
# =&gt; nil
&gt; WebhookEvent.last
# =&gt; #&lt;WebhookEvent
#       id: 2,
#       webhook_endpoint_id: 1,
#       event: &quot;events.test&quot;,
#       payload: { &quot;test&quot; =&gt; 2 },
#       created_at: &quot;2021-06-15 15:43:21.767801000 +0000&quot;,
#       updated_at: &quot;2021-06-15 15:43:21.767801000 +0000&quot;,
#       response: {}
#     &gt;
_content_copy_
</code></pre></div>
<p>Curious â <code>response</code> is empty, and we don't see any request logs for our Rails server. What gives? Well, we queued up the webhook worker, but we're no longer processing it inline. We'll need to boot up a Sidekiq process and let our workers work.</p>
<p>In a new terminal pane:</p>
<div class="language-text highlight"><pre><span></span><code>$ sidekiq

$ sidekiq
_content_copy_
</code></pre></div>
<p>Then we can go back to our console session and check the last event:</p>
<div class="language-text highlight"><pre><span></span><code>$ rails c

&gt; WebhookEvent.last

# =&gt; #&lt;WebhookEvent

#       id: 2,

#       webhook_endpoint_id: 2,

#       event: &quot;events.test&quot;,

#       payload: { &quot;test&quot; =&gt; 2 },

#       created_at: &quot;2021-06-15 15:48:32.801960000 +0000&quot;,

#       updated_at: &quot;2021-06-15 15:48:32.810783000 +0000&quot;,

#       response: {

#         &quot;body&quot; =&gt; &quot;&quot;,

#         &quot;code&quot; =&gt; 204,

#         &quot;headers&quot; =&gt; { ... }

#       }

#     &gt;

$ rails c
&gt; WebhookEvent.last
# =&gt; #&lt;WebhookEvent
#       id: 2,
#       webhook_endpoint_id: 2,
#       event: &quot;events.test&quot;,
#       payload: { &quot;test&quot; =&gt; 2 },
#       created_at: &quot;2021-06-15 15:48:32.801960000 +0000&quot;,
#       updated_at: &quot;2021-06-15 15:48:32.810783000 +0000&quot;,
#       response: {
#         &quot;body&quot; =&gt; &quot;&quot;,
#         &quot;code&quot; =&gt; 204,
#         &quot;headers&quot; =&gt; { ... }
#       }
#     &gt;
_content_copy_
</code></pre></div>
<p>The event was delivered successfully, as indicated by the <code>204</code> response.</p>
<h2 id="subscribing-to-certain-events">Subscribing to certain events<a class="headerlink" href="#subscribing-to-certain-events" title="Permanent link">&para;</a></h2>
<p>As your list of event types grows, your users are likely to only care about a handful of them. For example, our API service sends over 60 different event types, but we've found that each customer on average only listens to about 5 of them (which 5 depends on the licensing and billing model for the given business).</p>
<p>Allowing users to subscribe to only the events they need lets us:</p>
<ol>
<li>Reduces our costs by not queueing up and delivering superfluous webhooks.</li>
<li>Reduces their costs by not spamming webhooks they don't need.</li>
</ol>
<p>It's a win-win.</p>
<p>Let's update our webhook endpoints to be able to subscribe to certain events. To start, let's add a new <code>subscriptions</code> column to our webhook endpoints:</p>
<div class="language-text highlight"><pre><span></span><code>$ rails g migration AddSubscriptionsToWebhookEndpoints

$ rails g migration AddSubscriptionsToWebhookEndpoints
_content_copy_
</code></pre></div>
<p>Then we'll throw this into the migration file:</p>
<div class="language-text highlight"><pre><span></span><code>class AddSubscriptionsToWebhookEndpoints &lt; ActiveRecord::Migration[5.2]

  def change

    add_column :webhook_endpoints, :subscriptions, :jsonb, default: [&#39;*&#39;]

  end

end

class AddSubscriptionsToWebhookEndpoints &lt; ActiveRecord::Migration[5.2]
  def change
    add_column :webhook_endpoints, :subscriptions, :jsonb, default: [&#39;*&#39;]
  end
end
_content_copy_
</code></pre></div>
<p>Note the default <code>*</code> wildcard value. We're going to use that to signal that the endpoint will subscribe to all event types. Rare for production, useful for development.</p>
<p>Let's run the migration:</p>
<div class="language-text highlight"><pre><span></span><code>$ rails db:migrate

$ rails db:migrate
_content_copy_
</code></pre></div>
<p>And then let's update our webhook endpoint model to require at least 1 subscription, and also add a helper method to the model for checking if a given endpoint is subscribed to an event type. We'll use this throughout our webhook system.</p>
<div class="language-text highlight"><pre><span></span><code> class WebhookEndpoint &lt; ApplicationRecord

   has_many :webhook_events, inverse_of: :webhook_endpoint



+  validates :subscriptions, length: { minimum: 1 }, presence: true

   validates :url, presence: true

+

+  def subscribed?(event)

+    (subscriptions &amp; [&#39;*&#39;, event]).any?

+  end

 end

class WebhookEndpoint &lt; ApplicationRecord
  has_many :webhook_events, inverse_of: :webhook_endpoint

  validates :subscriptions, length: { minimum: 1 }, presence: true # [tl! ++]
  validates :url, presence: true
  # [tl! ++]
  def subscribed?(event) # [tl! ++]
    (subscriptions &amp; [&#39;*&#39;, event]).any? # [tl! ++]
  end # [tl! ++]
end
_content_copy_
</code></pre></div>
<p>We can test this out by updating our endpoint's subscriptions:</p>
<div class="language-text highlight"><pre><span></span><code>$ rails c

&gt; WebhookEndpoint.last.subscriptions

# =&gt; [&quot;*&quot;]

&gt; WebhookEndpoint.last.subscribed?(&#39;events.noop&#39;)

# =&gt; true

&gt; WebhookEndpoint.last.subscribed?(&#39;events.test&#39;)

# =&gt; true

&gt; WebhookEndpoint.last.update!(subscriptions: [&#39;events.test&#39;])

# =&gt; true

&gt; WebhookEndpoint.last.subscribed?(&#39;events.noop&#39;)

# =&gt; false

&gt; WebhookEndpoint.last.subscribed?(&#39;events.test&#39;)

# =&gt; true

$ rails c
&gt; WebhookEndpoint.last.subscriptions
# =&gt; [&quot;*&quot;]
&gt; WebhookEndpoint.last.subscribed?(&#39;events.noop&#39;)
# =&gt; true
&gt; WebhookEndpoint.last.subscribed?(&#39;events.test&#39;)
# =&gt; true
&gt; WebhookEndpoint.last.update!(subscriptions: [&#39;events.test&#39;])
# =&gt; true
&gt; WebhookEndpoint.last.subscribed?(&#39;events.noop&#39;)
# =&gt; false
&gt; WebhookEndpoint.last.subscribed?(&#39;events.test&#39;)
# =&gt; true
_content_copy_
</code></pre></div>
<p>Next, we'll adjust our service object to skip over endpoints that are not subscribed to the current event being broadcast:</p>
<div class="language-text highlight"><pre><span></span><code> def call

   WebhookEndpoint.find_each do |webhook_endpoint|

+    next unless

+      webhook_endpoint.subscribed?(event)

+

     webhook_event = WebhookEvent.create!(

       webhook_endpoint: webhook_endpoint,

       event: event,

       payload: payload,

     )



     WebhookWorker.perform_async(webhook_event.id)

   end

 end

def call
  WebhookEndpoint.find_each do |webhook_endpoint|
    next unless # [tl! ++]
      webhook_endpoint.subscribed?(event) # [tl! ++]
    # [tl! ++]
    webhook_event = WebhookEvent.create!(
      webhook_endpoint: webhook_endpoint,
      event: event,
      payload: payload,
    )

    WebhookWorker.perform_async(webhook_event.id)
  end
end
_content_copy_
</code></pre></div>
<p>Lastly, we'll also want to update our worker to do the same, just in case a webhook is in the process of being delivered but the user has since unsubscribed to that event.</p>
<p>For example, if a given event is particularly noisy, it may cause performance issues for the end-user's webhook server and they may want to retroactively unsubscribe from the noisy event. (For instance, our <code>license.validation.*</code> events can get pretty noisy depending on the licensing integration.)</p>
<p>Let's adjust our webhook worker to skip over event types that the webhook endpoint is no longer subscribed to:</p>
<div class="language-text highlight"><pre><span></span><code> def perform(webhook_event_id)

   webhook_event = WebhookEvent.find_by(id: webhook_event_id)

   return if

     webhook_event.nil?



   webhook_endpoint = webhook_event.webhook_endpoint

   return if

     webhook_endpoint.nil?

+

+  return unless

+    webhook_endpoint.subscribed?(webhook_event.event)



   # Send the webhook request with a 30 second timeout.

   response = HTTP.timeout(30)

                  .headers(

                    &#39;User-Agent&#39; =&gt; &#39;rails_webhook_system/1.0&#39;,

                    &#39;Content-Type&#39; =&gt; &#39;application/json&#39;,

                  )

                  .post(

                    webhook_endpoint.url,

                    body: {

                      event: webhook_event.event,

                      payload: webhook_event.payload,

                    }.to_json

                  )



   # Store the webhook response.

   webhook_event.update(response: {

     headers: response.headers.to_h,

     code: response.code.to_i,

     body: response.body.to_s,

   })



   # Raise a failed request error and let Sidekiq handle retrying.

   raise FailedRequestError unless

     response.status.success?

 rescue HTTP::TimeoutError

 # This error means the webhook endpoint timed out. We can either

   # raise a failed request error to trigger a retry, or leave it

   # as-is and consider timeouts terminal. We&#39;ll do the latter.

   webhook_event.update(response: { error: &#39;TIMEOUT_ERROR&#39; })

 end

def perform(webhook_event_id)
  webhook_event = WebhookEvent.find_by(id: webhook_event_id)
  return if
    webhook_event.nil?

  webhook_endpoint = webhook_event.webhook_endpoint
  return if
    webhook_endpoint.nil?
  # [tl! ++]
  return unless # [tl! ++]
    webhook_endpoint.subscribed?(webhook_event.event) # [tl! ++]

  # Send the webhook request with a 30 second timeout.
  response = HTTP.timeout(30)
                 .headers(
                   &#39;User-Agent&#39; =&gt; &#39;rails_webhook_system/1.0&#39;,
                   &#39;Content-Type&#39; =&gt; &#39;application/json&#39;,
                 )
                 .post(
                   webhook_endpoint.url,
                   body: {
                     event: webhook_event.event,
                     payload: webhook_event.payload,
                   }.to_json
                 )

  # Store the webhook response.
  webhook_event.update(response: {
    headers: response.headers.to_h,
    code: response.code.to_i,
    body: response.body.to_s,
  })

  # Raise a failed request error and let Sidekiq handle retrying.
  raise FailedRequestError unless
    response.status.success?
rescue HTTP::TimeoutError
# This error means the webhook endpoint timed out. We can either
  # raise a failed request error to trigger a retry, or leave it
  # as-is and consider timeouts terminal. We&#39;ll do the latter.
  webhook_event.update(response: { error: &#39;TIMEOUT_ERROR&#39; })
end
_content_copy_
</code></pre></div>
<p>We can once again test this out by queueing up a new event that our endpoint isn't subscribed to. Let's do this from the console:</p>
<div class="language-text highlight"><pre><span></span><code>$ rails c

&gt; WebhookEvent.count

# =&gt; 2

&gt; BroadcastWebhookService.call(event: &#39;events.noop&#39;, payload: { test: 3 })

# =&gt; nil

&gt; WebhookEvent.count

# =&gt; 2

$ rails c
&gt; WebhookEvent.count
# =&gt; 2
&gt; BroadcastWebhookService.call(event: &#39;events.noop&#39;, payload: { test: 3 })
# =&gt; nil
&gt; WebhookEvent.count
# =&gt; 2
_content_copy_
</code></pre></div>
<h2 id="improving-our-retry-cadence">Improving our retry cadence<a class="headerlink" href="#improving-our-retry-cadence" title="Permanent link">&para;</a></h2>
<p>Right now, we're using Sidekiq's default retry cadence, which is an exponential backoff. This is great for normal background jobs, but in our case, potentially retrying seconds after a failed webhook usually just exacerbates the problem. Sidekiq's default retry cadence is <code>retry_count ** 4</code>, which starts small and <em>eventually</em> gets large.</p>
<p>For example, if a webhook server is timing out because of too many requests, retrying all of them in quick succession until the backoff grows large enough isn't going to help the situation. We can alleviate that risk by adding in a little bit of "jitter" into the retry cadence and increasing the exponent from <code>4</code> to <code>5</code>:</p>
<div class="language-text highlight"><pre><span></span><code> class WebhookWorker

   include Sidekiq::Worker

+

+  sidekiq_retry_in do |retry_count|

+    # Exponential backoff, with a random 30-second to 10-minute &quot;jitter&quot;

+    # added in to help spread out any webhook &quot;bursts.&quot;

+    jitter = rand(30.seconds..10.minutes).to_i

+

+    (retry_count ** 5) + jitter

+  end



   def perform(webhook_event_id)

     ...

   end

 end

class WebhookWorker
  include Sidekiq::Worker
  # [tl! ++]
  sidekiq_retry_in do |retry_count| # [tl! ++]
    # Exponential backoff, with a random 30-second to 10-minute &quot;jitter&quot;   [tl! ++]
    # added in to help spread out any webhook &quot;bursts.&quot;                    [tl! ++]
    jitter = rand(30.seconds..10.minutes).to_i # [tl! ++]
    # [tl! ++]
    (retry_count ** 5) + jitter # [tl! ++]
  end # [tl! ++]

  def perform(webhook_event_id)
    ...
  end
end
_content_copy_
</code></pre></div>
<p>This should do a couple things:</p>
<ol>
<li>Reduce occurrences of instantaneous retries, reducing the chance of us exacerbating any issues with the webhook server.</li>
<li>Help space out sudden large bursts of failing webhooks by using a random jitter between 30 seconds and 10 minutes.</li>
</ol>
<p>One other thing we can also do is limit the amount of times a webhook will retry:</p>
<div class="language-text highlight"><pre><span></span><code> class WebhookWorker

   include Sidekiq::Worker



+  sidekiq_options retry: 10, dead: false

   sidekiq_retry_in do |retry_count|

     # Exponential backoff, with a random 30-second to 10-minute &quot;jitter&quot;

     # added in to help spread out any webhook &quot;bursts.&quot;

     jitter = rand(30.seconds..10.minutes).to_i



     (retry_count ** 5) + jitter

   end



   def perform(webhook_event_id)

     ...

   end

 end

class WebhookWorker
  include Sidekiq::Worker

  sidekiq_options retry: 10, dead: false # [tl! ++]
  sidekiq_retry_in do |retry_count|
    # Exponential backoff, with a random 30-second to 10-minute &quot;jitter&quot;
    # added in to help spread out any webhook &quot;bursts.&quot;
    jitter = rand(30.seconds..10.minutes).to_i

    (retry_count ** 5) + jitter
  end

  def perform(webhook_event_id)
    ...
  end
end
_content_copy_
</code></pre></div>
<p>Here we've set the maximum number of retries to <code>10</code>, and we've also told Sidekiq to not store these failed webhooks in its set of "dead" jobs. We don't care about dead webhook jobs. With our retry exponent of <code>5</code> and a maximum retry limit of <code>10</code>, retries should occur over approximately 3 days:</p>
<div class="language-text highlight"><pre><span></span><code>$ rails c

&gt; include ActionView::Helpers::DateHelper

&gt; total = 0.0

&gt; 10.times { |i| total += ((i + 1) ** 5) + rand(30.seconds..10.minutes) }

&gt; distance_of_time_in_words(total)

# =&gt; &quot;3 days&quot;

$ rails c
&gt; include ActionView::Helpers::DateHelper
&gt; total = 0.0
&gt; 10.times { |i| total += ((i + 1) ** 5) + rand(30.seconds..10.minutes) }
&gt; distance_of_time_in_words(total)
# =&gt; &quot;3 days&quot;
_content_copy_
</code></pre></div>
<p>The exponent and retry limit can be increased to spread the retries out over a longer duration. (The values can also be decreased, of course.)</p>
<h2 id="disabling-our-webhook-endpoints">Disabling our webhook endpoints<a class="headerlink" href="#disabling-our-webhook-endpoints" title="Permanent link">&para;</a></h2>
<p>Another great feature to have is being able to disable webhook endpoints. This could come in handy for us when we want to disable a problem endpoint, but not delete it (so that the problem can be resolved by the endpoint owner.) This feature can also come in handy for our users, by allowing them to keep certain webhook endpoints on-hand, but only have them enabled when they need them.</p>
<p>To accomplish this, we'll want to add a new <code>enabled</code> column to our webhook endpoints:</p>
<p>(There's a relatively wide changeset here â we're touching a lot of files.)</p>
<div class="language-text highlight"><pre><span></span><code>$ rails g migration AddEnabledToWebhookEndpoints

$ rails g migration AddEnabledToWebhookEndpoints
_content_copy_
</code></pre></div>
<p>And then within the migration, we'll want to have this:</p>
<div class="language-text highlight"><pre><span></span><code>class AddEnabledToWebhookEndpoints &lt; ActiveRecord::Migration[5.2]

  def change

    add_column :webhook_endpoints, :enabled, :boolean,

      default: true,

      index: true

  end

end

class AddEnabledToWebhookEndpoints &lt; ActiveRecord::Migration[5.2]
  def change
    add_column :webhook_endpoints, :enabled, :boolean,
      default: true,
      index: true
  end
end
_content_copy_
</code></pre></div>
<p>And we'll want to run the migration:</p>
<div class="language-text highlight"><pre><span></span><code>$ rails db:migrate

$ rails db:migrate
_content_copy_
</code></pre></div>
<p>Next, we'll want to update the webhook endpoint model to have an <code>enabled</code> scope, and we'll also add a bang-method to <code>disable!</code> a webhook endpoint:</p>
<div class="language-text highlight"><pre><span></span><code> class WebhookEndpoint &lt; ApplicationRecord

   has_many :webhook_events, inverse_of: :webhook_endpoint



   validates :subscriptions, length: { minimum: 1 }, presence: true

   validates :url, presence: true

+

+  scope :enabled, -&gt; { where(enabled: true) }



   def subscribed?(event)

    (subscriptions &amp; [&#39;*&#39;, event]).any?

   end

+

+  def disable!

+    update!(enabled: false)

+  end

 end

class WebhookEndpoint &lt; ApplicationRecord
  has_many :webhook_events, inverse_of: :webhook_endpoint

  validates :subscriptions, length: { minimum: 1 }, presence: true
  validates :url, presence: true
  # [tl! ++]
  scope :enabled, -&gt; { where(enabled: true) } # [tl! ++]

  def subscribed?(event)
   (subscriptions &amp; [&#39;*&#39;, event]).any?
  end
  # [tl! ++]
  def disable! # [tl! ++]
    update!(enabled: false) # [tl! ++]
  end # [tl! ++]
end
_content_copy_
</code></pre></div>
<p>Next, the broadcast webhook service needs to utilize the new <code>enabled</code> scope so that we only broadcast events to endpoints that are enabled:</p>
<div class="language-text highlight"><pre><span></span><code> def call

-  WebhookEndpoint.find_each do |webhook_endpoint|

+  WebhookEndpoint.enabled.find_each do |webhook_endpoint|

     ...

   end

 end

def call
  WebhookEndpoint.find_each do |webhook_endpoint| # [tl! --]
  WebhookEndpoint.enabled.find_each do |webhook_endpoint| # [tl! ++]
    ...
  end
end
_content_copy_
</code></pre></div>
<p>Finally, we'll update the webhook worker to bail early if the endpoint is disabled:</p>
<div class="language-text highlight"><pre><span></span><code> def perform(webhook_event_id)

   ...

   return unless

-    webhook_endpoint.subscribed?(webhook_event.event)

+    webhook_endpoint.subscribed?(webhook_event.event) &amp;&amp;

+    webhook_endpoint.enabled?

   ...

 end

def perform(webhook_event_id)
  ...
  return unless
    webhook_endpoint.subscribed?(webhook_event.event) # [tl! --]
    webhook_endpoint.subscribed?(webhook_event.event) &amp;&amp; # [tl! ++]
    webhook_endpoint.enabled? # [tl! ++]
  ...
end
_content_copy_
</code></pre></div>
<p>If we go ahead and disable our endpoint and then broadcast a new event, we shouldn't see a webhook delivery occur:</p>
<div class="language-text highlight"><pre><span></span><code>$ rails c

&gt; WebhookEndpoint.last.update!(enabled: false)

# =&gt; true

&gt; WebhookEvent.count

# =&gt; 2

&gt; BroadcastWebhookService.call(event: &#39;events.test&#39;, payload: { test: 4 })

# =&gt; nil

&gt; WebhookEvent.count

# =&gt; 2

$ rails c
&gt; WebhookEndpoint.last.update!(enabled: false)
# =&gt; true
&gt; WebhookEvent.count
# =&gt; 2
&gt; BroadcastWebhookService.call(event: &#39;events.test&#39;, payload: { test: 4 })
# =&gt; nil
&gt; WebhookEvent.count
# =&gt; 2
_content_copy_
</code></pre></div>
<p>If we had a failed webhook event being retried, and then we disabled the event's endpoint, the worker should stop attempting to retry. We aren't going to test that scenario, but it should be covered by the changeset here.</p>
<h2 id="improving-our-error-handling">Improving our error handling<a class="headerlink" href="#improving-our-error-handling" title="Permanent link">&para;</a></h2>
<p>When it comes to sending webhooks, there are a plethora of errors that can occur. From DNS issues, to TLS issues, to an <a href="https://ngrok.com">ngrok</a> tunnel no longer being active, to various type of timeouts and connection errors.</p>
<p>For now, we're going to handle the first 2: DNS and TLS issues.</p>
<p>Let's adjust our worker to rescue from a couple error classes:</p>
<ol>
<li><code>OpenSSL::SSL::SSLError</code> â this means the TLS connection failed, often due to an expired cert. In my experience, these are often short-lived and resolve within the 3 day delivery window that we've configured for retries.</li>
<li>
<p><code>HTTP::ConnectionError</code> â this is a general "catch-all" from <code>http.rb</code>. From my experience it usually means DNS, but it's kind of nuanced.</p>
<p>def perform(webhook_event_id)</p>
<p>...</p>
<p>rescue OpenSSL::SSL::SSLError</p>
<p># Since TLS issues may be due to an expired cert, we'll continue retrying</p>
<p># since the issue may get resolved within the 3 day retry window. This</p>
<p># may be a good place to send an alert to the endpoint owner.</p>
<p>webhook_event.update(response: { error: 'TLS_ERROR' })</p>
<p># Signal the webhook for retry.</p>
<p>raise FailedRequestError</p>
<p>rescue HTTP::ConnectionError</p>
<p># This error usually means DNS issues. To save us the bandwidth,</p>
<p># we're going to disable the endpoint. This would also be a good</p>
<p># location to send an alert to the endpoint owner.</p>
<p>webhook_event.update(response: { error: 'CONNECTION_ERROR' })</p>
<p># Disable the problem endpoint.</p>
<p>webhook_endpoint.disable!</p>
<p>rescue HTTP::TimeoutError</p>
<p># This error means the webhook endpoint timed out. We can either</p>
<p># raise a failed request error to trigger a retry, or leave it</p>
<p># as-is and consider timeouts terminal. We'll do the latter.</p>
<p>webhook_event.update(response: { error: 'TIMEOUT_ERROR' })</p>
<p>end</p>
<p>def perform(webhook_event_id)
  ...
rescue OpenSSL::SSL::SSLError
  # Since TLS issues may be due to an expired cert, we'll continue retrying
  # since the issue may get resolved within the 3 day retry window. This
  # may be a good place to send an alert to the endpoint owner.
  webhook_event.update(response: { error: 'TLS_ERROR' })</p>
<p># Signal the webhook for retry.
  raise FailedRequestError
rescue HTTP::ConnectionError
  # This error usually means DNS issues. To save us the bandwidth,
  # we're going to disable the endpoint. This would also be a good
  # location to send an alert to the endpoint owner.
  webhook_event.update(response: { error: 'CONNECTION_ERROR' })</p>
<p># Disable the problem endpoint.
  webhook_endpoint.disable!
rescue HTTP::TimeoutError
  # This error means the webhook endpoint timed out. We can either
  # raise a failed request error to trigger a retry, or leave it
  # as-is and consider timeouts terminal. We'll do the latter.
  webhook_event.update(response: { error: 'TIMEOUT_ERROR' })
end
<em>content_copy</em></p>
</li>
</ol>
<p>How we handle each of these errors ends up being pretty arbitrary. I just chose these to exemplify how to handle a few different scenarios:</p>
<ol>
<li>Retrying the webhook after an error occurs</li>
<li>Disabling an endpoint after a fatal error</li>
<li>Not retrying after an error</li>
</ol>
<h2 id="using-pattern-matching-for-special-cases">Using pattern matching for special cases<a class="headerlink" href="#using-pattern-matching-for-special-cases" title="Permanent link">&para;</a></h2>
<p>I mentioned <a href="https://ngrok.com">ngrok</a> earlier and I wanted to share some information on how you could use Ruby's new <a href="https://docs.ruby-lang.org/en/3.0.0/doc/syntax/pattern_matching_rdoc.html">pattern matching</a> to handle certain response patterns differently. We'll be applying this to ngrok specifically, but you could use the same logic to match against other types of responses as well.</p>
<p>Take an example â when an ngrok user creates a tunnel to a local server, and then adds that URL as a webhook endpoint, often times the tunnel session will be killed at the end of the day, but the webhook endpoint will still be enabled. I've found this to be a common occurrence with various localhost tunnel services.</p>
<p>One way we can handle these ngrok tunnels is by using pattern matching to match against certain response codes and response bodies from ngrok endpoints.</p>
<p>There are 3 scenarios for ngrok endpoints that we're going to cover today:</p>
<ol>
<li>When an ngrok URL no longer exists. This will return a <code>404</code> response code. We'll handle this by completely deleting the endpoint, since non-stable URLs are randomly generated and cannot be recreated.</li>
<li>When an ngrok URL is active, but the server being tunneled to is no longer running. This will return a <code>502</code> and usually occurs when the developer kills their local server at the end of a work day, but forgets to kill the ngrok session. We'll keep retrying this one, since the ngrok process records the events which can be replayed later on.</li>
<li>When a <a href="https://ngrok.com/docs#getting-started-stable">"stable" ngrok URL</a> is valid but there is no active tunnel session. This will return a <code>504</code>. We'll automatically disable this endpoint.</li>
</ol>
<p>Let's modify our webhook worker to be able to handle these scenarios:</p>
<div class="language-text highlight"><pre><span></span><code>def perform(webhook_event_id)

  ...



  # Exit early if the webhook was successful.

  return if

    response.status.success?



  # Handle response errors.

  case webhook_event

  in webhook_endpoint: { url: /\.ngrok\.io/ },

     response: { code: 404, body: /tunnel .+?\.ngrok\.io not found/i }

    # Automatically delete dead ngrok tunnel endpoints. This error likely

    # means that the developer forgot to remove their temporary ngrok

    # webhook endpoint, seeing as it no longer exists.

    webhook_endpoint.destroy!

  in webhook_endpoint: { url: /\.ngrok\.io/ },

     response: { code: 502 }

    # The bad gateway error usually means that the tunnel is still open

    # but the local server is no longer responding for any number of

    # reasons. We&#39;re going to automatically retry.

    raise FailedRequestError

  in webhook_endpoint: { url: /\.ngrok\.io/ },

     response: { code: 504 }

    # Automatically disable these since the endpoint is likely an ngrok

    # &quot;stable&quot; URL, but it&#39;s not currently running. To save bandwidth,

    # we do not want to automatically retry.

    webhook_endpoint.disable!

  else

    # Raise a failed request error and let Sidekiq handle retrying.

    raise FailedRequestError

  end



  ...

end

def perform(webhook_event_id)
  ...

  # Exit early if the webhook was successful.
  return if
    response.status.success?

  # Handle response errors.
  case webhook_event
  in webhook_endpoint: { url: /\.ngrok\.io/ },
     response: { code: 404, body: /tunnel .+?\.ngrok\.io not found/i }
    # Automatically delete dead ngrok tunnel endpoints. This error likely
    # means that the developer forgot to remove their temporary ngrok
    # webhook endpoint, seeing as it no longer exists.
    webhook_endpoint.destroy!
  in webhook_endpoint: { url: /\.ngrok\.io/ },
     response: { code: 502 }
    # The bad gateway error usually means that the tunnel is still open
    # but the local server is no longer responding for any number of
    # reasons. We&#39;re going to automatically retry.
    raise FailedRequestError
  in webhook_endpoint: { url: /\.ngrok\.io/ },
     response: { code: 504 }
    # Automatically disable these since the endpoint is likely an ngrok
    # &quot;stable&quot; URL, but it&#39;s not currently running. To save bandwidth,
    # we do not want to automatically retry.
    webhook_endpoint.disable!
  else
    # Raise a failed request error and let Sidekiq handle retrying.
    raise FailedRequestError
  end

  ...
end
_content_copy_
</code></pre></div>
<p>Now to actually be able to pattern match against our webhook event model, we'll need to add a <code>deconstruct_keys</code> method:</p>
<div class="language-text highlight"><pre><span></span><code> class WebhookEvent &lt; ApplicationRecord

   belongs_to :webhook_endpoint, inverse_of: :webhook_events



   validates :event, presence: true

   validates :payload, presence: true



+  def deconstruct_keys(keys)

+    {

+      webhook_endpoint: { url: webhook_endpoint.url },

+      event: event,

+      payload: payload,

+      response: response.symbolize_keys,

+    }

+  end

 end

class WebhookEvent &lt; ApplicationRecord
  belongs_to :webhook_endpoint, inverse_of: :webhook_events

  validates :event, presence: true
  validates :payload, presence: true

  def deconstruct_keys(keys) # [tl! ++]
    { # [tl! ++]
      webhook_endpoint: { url: webhook_endpoint.url }, # [tl! ++]
      event: event, # [tl! ++]
      payload: payload, # [tl! ++]
      response: response.symbolize_keys, # [tl! ++]
    } # [tl! ++]
  end # [tl! ++]
end
_content_copy_
</code></pre></div>
<p>This will allow us to match against the hash pattern we define. In our case, we're surfacing the <code>webhook_endpoint</code>, <code>event</code>, <code>payload</code> and the <code>response</code> object.</p>
<p>We can test these scenarios by creating an ngrok tunnel to our local Rails server:</p>
<div class="language-text highlight"><pre><span></span><code>$ ngrok http 3000

$ ngrok http 3000
_content_copy_
</code></pre></div>
<p>Then we can update our webhook endpoint to use the generated ngrok URL:</p>
<div class="language-text highlight"><pre><span></span><code>$ rails c

&gt; WebhookEndpoint.last.update!(

    url: &#39;https://349df8f512ea.ngrok.io/webhooks&#39;

  )

# =&gt; true

$ rails c
&gt; WebhookEndpoint.last.update!(
    url: &#39;https://349df8f512ea.ngrok.io/webhooks&#39;
  )
# =&gt; true
_content_copy_
</code></pre></div>
<p>Next, we can queue up a new webhook event to send:</p>
<div class="language-text highlight"><pre><span></span><code>$ rails c

&gt; BroadcastWebhookService.call(event: &#39;events.test&#39;, payload: { test: 5 })

# =&gt; nil

&gt; WebhookEvent.last.response

# =&gt; { &quot;body&quot; =&gt; &quot;&quot;, &quot;code&quot; =&gt; 204, &quot;headers&quot; =&gt; { ... } }

$ rails c
&gt; BroadcastWebhookService.call(event: &#39;events.test&#39;, payload: { test: 5 })
# =&gt; nil
&gt; WebhookEvent.last.response
# =&gt; { &quot;body&quot; =&gt; &quot;&quot;, &quot;code&quot; =&gt; 204, &quot;headers&quot; =&gt; { ... } }
_content_copy_
</code></pre></div>
<p>Looking at our ngrok logs, we see a <code>204</code> status code for that webhook. Now, let's kill our ngrok process and send another event:</p>
<div class="language-text highlight"><pre><span></span><code>$ rails c

&gt; WebhookEndpoint.count

# =&gt; 1

&gt; BroadcastWebhookService.call(event: &#39;events.test&#39;, payload: { test: 6 })

# =&gt; nil

&gt; WebhookEndpoint.count

# =&gt; 0

$ rails c
&gt; WebhookEndpoint.count
# =&gt; 1
&gt; BroadcastWebhookService.call(event: &#39;events.test&#39;, payload: { test: 6 })
# =&gt; nil
&gt; WebhookEndpoint.count
# =&gt; 0
_content_copy_
</code></pre></div>
<p>Using pattern matching, our worker (correctly) determined that the bad ngrok webhook endpoint should be deleted, since it's now returning a <code>404</code>.</p>
<p>Similarly, we can test the other scenarios, for example by keeping the ngrok session active but killing the local Rails server process. But I'll leave that as an exercise for the curious reader.</p>
<h2 id="caveats-and-summary">Caveats and summary<a class="headerlink" href="#caveats-and-summary" title="Permanent link">&para;</a></h2>
<p>Today, we've covered how to build a webhook system using Rails and Sidekiq. We've learned how we can rely on Sidekiq to do the heavy-lifting for us, and then we broke out Ruby's new pattern matching syntax for some special-case response handling.</p>
<p>So what's next? Here are things to try and look out for:</p>
<ul>
<li>Assert that webhook endpoints are non-malicious (one big thing to assert is that they are not pointing to the system itself!)</li>
<li>Assert that webhook endpoints use TLS.</li>
<li>Assert that webhook jobs are unique (see <a href="https://sidekiq.org/products/pro.html">Sidekiq Pro</a>'s unique jobs feature, or the <code>sidekiq-unique-jobs</code> gem.)</li>
<li>Assert that the webhook event <code>response</code> is not too large. (Some endpoints will try to send you the entire Internet to store.)</li>
<li>Add the ability to manually retry events.</li>
<li>Add better error handling.</li>
<li>Add logging (!)</li>
</ul>
<p>You can view <a href="https://github.com/ezekg/example-rails-webhook-system">the full example app</a> on GitHub.</p>
<p>Until next time.</p>
<hr />
<p>If you find any errors in my code, or if you can think of ways to improve things, <a href="https://x.com/_m27e">ping me via Twitter</a>. </p>
<p>Â© 2016â2026 Keygen LLC â All Rights Reserved â Reach out &lt;<a href="/cdn-cgi/l/email-protection">[email protected]</a>&gt;<br />
The Keygen name, logo, and mark are trademarks of Keygen LLC in the United States</p>
<ul>
<li><a href="https://status.keygen.sh">Status</a></li>
<li><a href="/about/">About</a></li>
<li><a href="/security/">Security</a></li>
<li><a href="/changelog/">Changelog</a></li>
<li><a href="/privacy/">Privacy</a></li>
<li><a href="/terms/">Terms</a></li>
<li><a href="/terms/sla/">SLA</a></li>
<li><a href="/blog/">Blog</a></li>
<li><a href="/jobs/">Jobs</a></li>
<li><a href="/press/">Press</a></li>
<li><a href="/license/">License</a></li>
<li><a href="/cla/">CLA</a></li>
<li><a href="https://github.com/keygen-sh"> __</a></li>
<li><a href="https://hub.docker.com/u/keygen">__</a></li>
<li><a href="https://discord.gg/TRrhSaWSsN"></a></li>
<li><a href="https://twitter.com/keygen_sh">__</a></li>
</ul>







  
    
  
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="最后更新">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1zM12.5 7v5.2l4 2.4-1 1L11 13V7zM11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-iso_date" title="2026年2月27日 22:12:04 UTC">2026-02-27</span>
  </span>

    
    
    
    
  </aside>


  



  <form class="md-feedback" name="feedback" hidden>
    <fieldset>
      <legend class="md-feedback__title">
        这篇文章有帮助吗？
      </legend>
      <div class="md-feedback__inner">
        <div class="md-feedback__list">
          
            <button class="md-feedback__icon md-icon" type="submit" title="有帮助" data-md-value="1">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5 9v12H1V9zm4 12a2 2 0 0 1-2-2V9c0-.55.22-1.05.59-1.41L14.17 1l1.06 1.06c.27.27.44.64.44 1.05l-.03.32L14.69 8H21a2 2 0 0 1 2 2v2c0 .26-.05.5-.14.73l-3.02 7.05C19.54 20.5 18.83 21 18 21zm0-2h9.03L21 12v-2h-8.79l1.13-5.32L9 9.03z"/></svg>
            </button>
          
            <button class="md-feedback__icon md-icon" type="submit" title="没帮助" data-md-value="0">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 15V3h4v12zM15 3a2 2 0 0 1 2 2v10c0 .55-.22 1.05-.59 1.41L9.83 23l-1.06-1.06c-.27-.27-.44-.64-.44-1.06l.03-.31.95-4.57H3a2 2 0 0 1-2-2v-2c0-.26.05-.5.14-.73l3.02-7.05C4.46 3.5 5.17 3 6 3zm0 2H5.97L3 12v2h8.78l-1.13 5.32L15 14.97z"/></svg>
            </button>
          
        </div>
        <div class="md-feedback__note">
          
            <div data-md-value="1" hidden>
              
              
                
              
              
              
                
                
              
              感谢反馈！
            </div>
          
            <div data-md-value="0" hidden>
              
              
                
              
              
              
                
                
              
              感谢反馈！我们会改进。
            </div>
          
        </div>
      </div>
    </fieldset>
  </form>


                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2026 - OpenClaw
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        
<div class="md-social">
  
    
    
    
    
    <a href="https://github.com/mrgolftech" target="_blank" rel="noopener" title="GitHub" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../..", "features": ["navigation.instant", "navigation.tracking", "navigation.tabs", "navigation.sections", "navigation.expand", "navigation.top", "search.suggest", "search.highlight", "search.share", "content.code.copy", "content.action.edit"], "search": "../../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.79ae519e.min.js"></script>
      
    
  </body>
</html>