
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="技术博客文章聚合 - Hacker News 2025年最受欢迎的博客">
      
      
        <meta name="author" content="OpenClaw">
      
      
        <link rel="canonical" href="https://mrgolftech.github.io/rss-articles/mjg59.dreamwidth.org/Cordoomceps%20-%20replacing%20an%20Amiga%27s%20brain%20with%20Doom_20260205/">
      
      
      
      
        
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.1">
    
    
      
        <title>Cordoomceps - replacing an Amiga's brain with Doom\n\n来源: https://mjg59.dreamwidth.org\n链接: https://mjg59.dreamwidth.org/73001.html\n日期: Tue, 05 Aug 2025 00:30:19 GMT\n\n---\n\nThere's a lovely device called a\npistorm\n, an adapter board that glues a Raspberry Pi GPIO bus to a Motorola 68000 bus. The intended use case is that you plug it into a 68000 device and then run an emulator that reads instructions from hardware (ROM or RAM) and emulates them. You're still limited by the ~7MHz bus that the hardware is running at, but you can run the instructions as fast as you want.\nThese days you're supposed to run a custom built OS on the Pi that just does 68000 emulation, but initially it ran Linux on the Pi and a userland 68000 emulator process. And, well, that got me thinking. The emulator takes 68000 instructions, emulates them, and then talks to the hardware to implement the effects of those instructions. What if we, well, just don't? What if we just run all of our code in Linux on an ARM core and then talk to the Amiga hardware?\nWe're going to ignore x86 here, because it's weird - but most hardware that wants software to be able to communicate with it maps itself into the same address space that RAM is in. You can write to a byte of RAM, or you can write to a piece of hardware that's effectively pretending to be RAM[1]. The Amiga wasn't unusual in this respect in the 80s, and to talk to the graphics hardware you speak to a special address range that gets sent to that hardware instead of to RAM. The CPU knows nothing about this. It just indicates it wants to write to an address, and then sends the data.\nSo, if we are the CPU, we can just indicate that we want to write to an address, and provide the data. And those addresses can correspond to the hardware. So, we can write to the RAM that belongs to the Amiga, and we can write to the hardware that isn't RAM but pretends to be. And that means we can run whatever we want on the Pi and then access Amiga hardware.\nAnd, obviously, the thing we want to run is Doom, because that's what everyone runs in fucked up hardware situations.\nDoom was Amiga kryptonite. Its entire graphical model was based on memory directly representing the contents of your display, and being able to modify that by just moving pixels around. This worked because at the time VGA displays supported having a memory layout where each pixel on your screen was represented by a byte in memory containing an 8 bit value that corresponded to a lookup table containing the RGB value for that pixel.\nThe Amiga was, well, not good at this. Back in the 80s, when the Amiga hardware was developed, memory was expensive. Dedicating that much RAM to the video hardware was unthinkable - the Amiga 1000 initially shipped with only 256K of RAM, and you could fill all of that with a sufficiently colourful picture. So instead of having the idea of each pixel being associated with a specific area of memory, the Amiga used bitmaps. A bitmap is an area of memory that represents the screen, but only represents one bit of the colour depth. If you have a black and white display, you only need one bitmap. If you want to display four colours, you need two. More colours, more bitmaps. And each bitmap is stored in an independent area of RAM. You never use more memory than you need to display the number of colours you want to.\nBut that means that each bitplane contains packed information - every byte of data in a bitplane contains the bit value for 8 different pixels, because each bitplane contains one bit of information per pixel. To update one pixel on screen, you need to read from every bitmap, update one bit, and write it back, and that's a lot of additional memory accesses. Doom, but on the Amiga, was slow not just because the CPU was slow, but because there was a lot of manipulation of data to turn it into the format the Amiga wanted and then push that over a fairly slow memory bus to have it displayed.\nThe\nCDTV\nwas an aesthetically pleasing piece of hardware that absolutely sucked. It was an Amiga 500 in a hi-fi box with a caddy-loading CD drive, and it ran software that was just awful. There's no path to remediation here. No compelling apps were ever released. It's a terrible device. I love it. I bought one in 1996 because a local computer store had one and I pointed out that the company selling it had gone bankrupt some years earlier and literally nobody in my farming town was ever going to have any interest in buying a CD player that made a whirring noise when you turned it on because it had a fan and eventually they just sold it to me for not much money, and ever since then I wanted to have a CD player that ran Linux and well spoiler 30 years later I'm nearly there. That CDTV is going to be our test subject. We're going to try to get Doom running on it without executing any 68000 instructions.\nWe're facing two main problems here. The first is that all Amigas have a firmware ROM called Kickstart that runs at powerup. No matter how little you care about using any OS functionality, you can't start running your code until Kickstart has run. This means even documentation describing bare metal Amiga programming assumes that the hardware is already in the state that Kickstart left it in. This will become important later. The second is that we're going to need to actually write the code to use the Amiga hardware.\nFirst,\nlet's talk about Amiga graphics\n. We've already covered bitmaps, but for anyone used to modern hardware that's not the weirdest thing about what we're dealing with here. The CDTV's chipset supports a maximum of 64 colours in a mode called "Extra Half-Brite", or EHB, where you have 32 colours arbitrarily chosen from a palette and then 32 more colours that are identical but with half the intensity. For 64 colours we need 6 bitplanes, each of which can be located arbitrarily in the region of RAM accessible to the chipset ("chip RAM", distinguished from "fast ram" that's only accessible to the CPU). We tell the chipset where our bitplanes are and it displays them. Or, well, it does for a frame - after that the registers that pointed at our bitplanes no longer do, because when the hardware was DMAing through the bitplanes to display them it was incrementing those registers to point at the next address to DMA from. Which means that every frame we need to set those registers back.\nMaking sure you have code that's called every frame just to make your graphics work sounds intensely irritating, so Commodore gave us a way to avoid doing that. The chipset includes a coprocessor called "copper". Copper doesn't have a large set of features - in fact, it only has three. The first is that it can program chipset registers. The second is that it can wait for a specific point in screen scanout. The third (which we don't care about here) is that it can optionally skip an instruction if a certain point in screen scanout has already been reached. We can write a program (a "copper list") for the copper that tells it to program the chipset registers with the locations of our bitplanes and then wait until the end of the frame, at which point it will repeat the process. Now our bitplane pointers are always valid at the start of a frame.\nOk! We know how to display stuff. Now we just need to deal with not having 256 colours, and the whole "Doom expects pixels" thing. For the first of these, I stole code from\nADoom\n, the only Amiga doom port I could easily find source for. This looks at the 256 colour palette loaded by Doom and calculates the closest approximation it can within the constraints of EHB. ADoom also includes a bunch of CPU-specific assembly optimisation for converting the "chunky" Doom graphic buffer into the "planar" Amiga bitplanes, none of which I used because (a) it's all for 68000 series CPUs and we're running on ARM, and (b) I have a quad core CPU running at 1.4GHz and I'm going to be pushing all the graphics over a 7.14MHz bus, the graphics mode conversion is\nnot\ngoing to be the bottleneck here. Instead I just wrote a series of nested for loops that iterate through each pixel and update each bitplane and called it a day. The set of bitplanes I'm operating on here is allocated on the Linux side so I can read and write to them without being restricted by the speed of the Amiga bus (remember, each byte in each bitplane is going to be updated 8 times per frame, because it holds bits associated with 8 pixels), and then copied over to the Amiga's RAM once the frame is complete.\nAnd, kind of astonishingly, this works! Once I'd figured out where I was going wrong with RGB ordering and which order the bitplanes go in, I had a recognisable copy of Doom running. Unfortunately there were weird graphical glitches - sometimes blocks would be entirely the wrong colour. It took me a while to figure out what was going on and then I felt stupid. Recording the screen and watching in slow motion revealed that the glitches often showed parts of two frames displaying at once. The Amiga hardware is taking responsibility for scanning out the frames, and the code on the Linux side isn't synchronised with it at all. That means I could update the bitplanes while the Amiga was scanning them out, resulting in a mashup of planes from two different Doom frames being used as one Amiga frame. One approach to avoid this would be to tie the Doom event loop to the Amiga, blocking my writes until the end of scanout. The other is to use double-buffering - have two sets of bitplanes, one being displayed and the other being written to. This consumes more RAM but since I'm not using the Amiga RAM for anything else that's not a problem. With this approach I have two copper lists, one for each set of bitplanes, and switch between them on each frame. This improved things a lot but not entirely, and there's still glitches when the palette is being updated (because there's only one set of colour registers), something Doom does rather a lot, so I'm going to need to implement proper synchronisation.\nExcept. This was only working if I ran a 68K emulator first in order to run Kickstart. If I tried accessing the hardware without doing that, things were in a weird state. I could update the colour registers, but accessing RAM didn't work - I could read stuff out, but anything I wrote vanished. Some more digging cleared that up. When you turn on a CPU it needs to start executing code from somewhere. On modern x86 systems it starts from a hardcoded address of 0xFFFFFFF0, which was traditionally a long way any RAM. The 68000 family instead reads its start address from address 0x00000004, which overlaps with where the Amiga chip RAM is. We can't write anything to RAM until we're executing code, and we can't execute code until we tell the CPU where the code is, which seems like a problem. This is solved on the Amiga by powering up in a state where the Kickstart ROM is "overlayed" onto address 0. The CPU reads the start address from the ROM, which causes it to jump into the ROM and start executing code there. Early on, the code tells the hardware to stop overlaying the ROM onto the low addresses, and now the RAM is available. This is poorly documented because it's not something you need to care if you execute Kickstart which every actual Amiga does and I'm only in this position because I've made poor life choices, but ok that explained things. To turn off the overlay you write to a register in one of the Complex Interface Adaptor (CIA) chips, and things start working like you'd expect.\nExcept, they don't. Writing to that register did nothing for me. I assumed that there was some other register I needed to write to first, and went to the extent of tracing every register access that occurred when running the emulator and replaying those in my code. Nope, still broken. What I finally discovered is that you need to pulse the reset line on the board before some of the hardware starts working - powering it up doesn't put you in a well defined state, but resetting it does.\nSo, I now have a slightly graphically glitchy copy of Doom running without any sound, displaying on an Amiga whose brain has been replaced with a parasitic Linux. Further updates will likely make things even worse. Code is, of course,\navailable\n.\n[1] This is why we had trouble with late era 32 bit systems and 4GB of RAM - a bunch of your hardware wanted to be in the same address space and so you couldn't put RAM there so you ended up with less than 4GB of RAM\ncomments - Hacker News 精选博客</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.484c7ddc.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      
  


    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#cordoomceps-replacing-an-amigas-brain-with-doomnn-httpsmjg59dreamwidthorgn-httpsmjg59dreamwidthorg73001htmln-tue-05-aug-2025-003019-gmtnn-nntheres-a-lovely-device-called-anpistormn-an-adapter-board-that-glues-a-raspberry-pi-gpio-bus-to-a-motorola-68000-bus-the-intended-use-case-is-that-you-plug-it-into-a-68000-device-and-then-run-an-emulator-that-reads-instructions-from-hardware-rom-or-ram-and-emulates-them-youre-still-limited-by-the-7mhz-bus-that-the-hardware-is-running-at-but-you-can-run-the-instructions-as-fast-as-you-wantnthese-days-youre-supposed-to-run-a-custom-built-os-on-the-pi-that-just-does-68000-emulation-but-initially-it-ran-linux-on-the-pi-and-a-userland-68000-emulator-process-and-well-that-got-me-thinking-the-emulator-takes-68000-instructions-emulates-them-and-then-talks-to-the-hardware-to-implement-the-effects-of-those-instructions-what-if-we-well-just-dont-what-if-we-just-run-all-of-our-code-in-linux-on-an-arm-core-and-then-talk-to-the-amiga-hardwarenwere-going-to-ignore-x86-here-because-its-weird-but-most-hardware-that-wants-software-to-be-able-to-communicate-with-it-maps-itself-into-the-same-address-space-that-ram-is-in-you-can-write-to-a-byte-of-ram-or-you-can-write-to-a-piece-of-hardware-thats-effectively-pretending-to-be-ram1-the-amiga-wasnt-unusual-in-this-respect-in-the-80s-and-to-talk-to-the-graphics-hardware-you-speak-to-a-special-address-range-that-gets-sent-to-that-hardware-instead-of-to-ram-the-cpu-knows-nothing-about-this-it-just-indicates-it-wants-to-write-to-an-address-and-then-sends-the-datanso-if-we-are-the-cpu-we-can-just-indicate-that-we-want-to-write-to-an-address-and-provide-the-data-and-those-addresses-can-correspond-to-the-hardware-so-we-can-write-to-the-ram-that-belongs-to-the-amiga-and-we-can-write-to-the-hardware-that-isnt-ram-but-pretends-to-be-and-that-means-we-can-run-whatever-we-want-on-the-pi-and-then-access-amiga-hardwarenand-obviously-the-thing-we-want-to-run-is-doom-because-thats-what-everyone-runs-in-fucked-up-hardware-situationsndoom-was-amiga-kryptonite-its-entire-graphical-model-was-based-on-memory-directly-representing-the-contents-of-your-display-and-being-able-to-modify-that-by-just-moving-pixels-around-this-worked-because-at-the-time-vga-displays-supported-having-a-memory-layout-where-each-pixel-on-your-screen-was-represented-by-a-byte-in-memory-containing-an-8-bit-value-that-corresponded-to-a-lookup-table-containing-the-rgb-value-for-that-pixelnthe-amiga-was-well-not-good-at-this-back-in-the-80s-when-the-amiga-hardware-was-developed-memory-was-expensive-dedicating-that-much-ram-to-the-video-hardware-was-unthinkable-the-amiga-1000-initially-shipped-with-only-256k-of-ram-and-you-could-fill-all-of-that-with-a-sufficiently-colourful-picture-so-instead-of-having-the-idea-of-each-pixel-being-associated-with-a-specific-area-of-memory-the-amiga-used-bitmaps-a-bitmap-is-an-area-of-memory-that-represents-the-screen-but-only-represents-one-bit-of-the-colour-depth-if-you-have-a-black-and-white-display-you-only-need-one-bitmap-if-you-want-to-display-four-colours-you-need-two-more-colours-more-bitmaps-and-each-bitmap-is-stored-in-an-independent-area-of-ram-you-never-use-more-memory-than-you-need-to-display-the-number-of-colours-you-want-tonbut-that-means-that-each-bitplane-contains-packed-information-every-byte-of-data-in-a-bitplane-contains-the-bit-value-for-8-different-pixels-because-each-bitplane-contains-one-bit-of-information-per-pixel-to-update-one-pixel-on-screen-you-need-to-read-from-every-bitmap-update-one-bit-and-write-it-back-and-thats-a-lot-of-additional-memory-accesses-doom-but-on-the-amiga-was-slow-not-just-because-the-cpu-was-slow-but-because-there-was-a-lot-of-manipulation-of-data-to-turn-it-into-the-format-the-amiga-wanted-and-then-push-that-over-a-fairly-slow-memory-bus-to-have-it-displayednthencdtvnwas-an-aesthetically-pleasing-piece-of-hardware-that-absolutely-sucked-it-was-an-amiga-500-in-a-hi-fi-box-with-a-caddy-loading-cd-drive-and-it-ran-software-that-was-just-awful-theres-no-path-to-remediation-here-no-compelling-apps-were-ever-released-its-a-terrible-device-i-love-it-i-bought-one-in-1996-because-a-local-computer-store-had-one-and-i-pointed-out-that-the-company-selling-it-had-gone-bankrupt-some-years-earlier-and-literally-nobody-in-my-farming-town-was-ever-going-to-have-any-interest-in-buying-a-cd-player-that-made-a-whirring-noise-when-you-turned-it-on-because-it-had-a-fan-and-eventually-they-just-sold-it-to-me-for-not-much-money-and-ever-since-then-i-wanted-to-have-a-cd-player-that-ran-linux-and-well-spoiler-30-years-later-im-nearly-there-that-cdtv-is-going-to-be-our-test-subject-were-going-to-try-to-get-doom-running-on-it-without-executing-any-68000-instructionsnwere-facing-two-main-problems-here-the-first-is-that-all-amigas-have-a-firmware-rom-called-kickstart-that-runs-at-powerup-no-matter-how-little-you-care-about-using-any-os-functionality-you-cant-start-running-your-code-until-kickstart-has-run-this-means-even-documentation-describing-bare-metal-amiga-programming-assumes-that-the-hardware-is-already-in-the-state-that-kickstart-left-it-in-this-will-become-important-later-the-second-is-that-were-going-to-need-to-actually-write-the-code-to-use-the-amiga-hardwarenfirstnlets-talk-about-amiga-graphicsn-weve-already-covered-bitmaps-but-for-anyone-used-to-modern-hardware-thats-not-the-weirdest-thing-about-what-were-dealing-with-here-the-cdtvs-chipset-supports-a-maximum-of-64-colours-in-a-mode-called-extra-half-brite-or-ehb-where-you-have-32-colours-arbitrarily-chosen-from-a-palette-and-then-32-more-colours-that-are-identical-but-with-half-the-intensity-for-64-colours-we-need-6-bitplanes-each-of-which-can-be-located-arbitrarily-in-the-region-of-ram-accessible-to-the-chipset-chip-ram-distinguished-from-fast-ram-thats-only-accessible-to-the-cpu-we-tell-the-chipset-where-our-bitplanes-are-and-it-displays-them-or-well-it-does-for-a-frame-after-that-the-registers-that-pointed-at-our-bitplanes-no-longer-do-because-when-the-hardware-was-dmaing-through-the-bitplanes-to-display-them-it-was-incrementing-those-registers-to-point-at-the-next-address-to-dma-from-which-means-that-every-frame-we-need-to-set-those-registers-backnmaking-sure-you-have-code-thats-called-every-frame-just-to-make-your-graphics-work-sounds-intensely-irritating-so-commodore-gave-us-a-way-to-avoid-doing-that-the-chipset-includes-a-coprocessor-called-copper-copper-doesnt-have-a-large-set-of-features-in-fact-it-only-has-three-the-first-is-that-it-can-program-chipset-registers-the-second-is-that-it-can-wait-for-a-specific-point-in-screen-scanout-the-third-which-we-dont-care-about-here-is-that-it-can-optionally-skip-an-instruction-if-a-certain-point-in-screen-scanout-has-already-been-reached-we-can-write-a-program-a-copper-list-for-the-copper-that-tells-it-to-program-the-chipset-registers-with-the-locations-of-our-bitplanes-and-then-wait-until-the-end-of-the-frame-at-which-point-it-will-repeat-the-process-now-our-bitplane-pointers-are-always-valid-at-the-start-of-a-framenok-we-know-how-to-display-stuff-now-we-just-need-to-deal-with-not-having-256-colours-and-the-whole-doom-expects-pixels-thing-for-the-first-of-these-i-stole-code-fromnadoomn-the-only-amiga-doom-port-i-could-easily-find-source-for-this-looks-at-the-256-colour-palette-loaded-by-doom-and-calculates-the-closest-approximation-it-can-within-the-constraints-of-ehb-adoom-also-includes-a-bunch-of-cpu-specific-assembly-optimisation-for-converting-the-chunky-doom-graphic-buffer-into-the-planar-amiga-bitplanes-none-of-which-i-used-because-a-its-all-for-68000-series-cpus-and-were-running-on-arm-and-b-i-have-a-quad-core-cpu-running-at-14ghz-and-im-going-to-be-pushing-all-the-graphics-over-a-714mhz-bus-the-graphics-mode-conversion-isnnotngoing-to-be-the-bottleneck-here-instead-i-just-wrote-a-series-of-nested-for-loops-that-iterate-through-each-pixel-and-update-each-bitplane-and-called-it-a-day-the-set-of-bitplanes-im-operating-on-here-is-allocated-on-the-linux-side-so-i-can-read-and-write-to-them-without-being-restricted-by-the-speed-of-the-amiga-bus-remember-each-byte-in-each-bitplane-is-going-to-be-updated-8-times-per-frame-because-it-holds-bits-associated-with-8-pixels-and-then-copied-over-to-the-amigas-ram-once-the-frame-is-completenand-kind-of-astonishingly-this-works-once-id-figured-out-where-i-was-going-wrong-with-rgb-ordering-and-which-order-the-bitplanes-go-in-i-had-a-recognisable-copy-of-doom-running-unfortunately-there-were-weird-graphical-glitches-sometimes-blocks-would-be-entirely-the-wrong-colour-it-took-me-a-while-to-figure-out-what-was-going-on-and-then-i-felt-stupid-recording-the-screen-and-watching-in-slow-motion-revealed-that-the-glitches-often-showed-parts-of-two-frames-displaying-at-once-the-amiga-hardware-is-taking-responsibility-for-scanning-out-the-frames-and-the-code-on-the-linux-side-isnt-synchronised-with-it-at-all-that-means-i-could-update-the-bitplanes-while-the-amiga-was-scanning-them-out-resulting-in-a-mashup-of-planes-from-two-different-doom-frames-being-used-as-one-amiga-frame-one-approach-to-avoid-this-would-be-to-tie-the-doom-event-loop-to-the-amiga-blocking-my-writes-until-the-end-of-scanout-the-other-is-to-use-double-buffering-have-two-sets-of-bitplanes-one-being-displayed-and-the-other-being-written-to-this-consumes-more-ram-but-since-im-not-using-the-amiga-ram-for-anything-else-thats-not-a-problem-with-this-approach-i-have-two-copper-lists-one-for-each-set-of-bitplanes-and-switch-between-them-on-each-frame-this-improved-things-a-lot-but-not-entirely-and-theres-still-glitches-when-the-palette-is-being-updated-because-theres-only-one-set-of-colour-registers-something-doom-does-rather-a-lot-so-im-going-to-need-to-implement-proper-synchronisationnexcept-this-was-only-working-if-i-ran-a-68k-emulator-first-in-order-to-run-kickstart-if-i-tried-accessing-the-hardware-without-doing-that-things-were-in-a-weird-state-i-could-update-the-colour-registers-but-accessing-ram-didnt-work-i-could-read-stuff-out-but-anything-i-wrote-vanished-some-more-digging-cleared-that-up-when-you-turn-on-a-cpu-it-needs-to-start-executing-code-from-somewhere-on-modern-x86-systems-it-starts-from-a-hardcoded-address-of-0xfffffff0-which-was-traditionally-a-long-way-any-ram-the-68000-family-instead-reads-its-start-address-from-address-0x00000004-which-overlaps-with-where-the-amiga-chip-ram-is-we-cant-write-anything-to-ram-until-were-executing-code-and-we-cant-execute-code-until-we-tell-the-cpu-where-the-code-is-which-seems-like-a-problem-this-is-solved-on-the-amiga-by-powering-up-in-a-state-where-the-kickstart-rom-is-overlayed-onto-address-0-the-cpu-reads-the-start-address-from-the-rom-which-causes-it-to-jump-into-the-rom-and-start-executing-code-there-early-on-the-code-tells-the-hardware-to-stop-overlaying-the-rom-onto-the-low-addresses-and-now-the-ram-is-available-this-is-poorly-documented-because-its-not-something-you-need-to-care-if-you-execute-kickstart-which-every-actual-amiga-does-and-im-only-in-this-position-because-ive-made-poor-life-choices-but-ok-that-explained-things-to-turn-off-the-overlay-you-write-to-a-register-in-one-of-the-complex-interface-adaptor-cia-chips-and-things-start-working-like-youd-expectnexcept-they-dont-writing-to-that-register-did-nothing-for-me-i-assumed-that-there-was-some-other-register-i-needed-to-write-to-first-and-went-to-the-extent-of-tracing-every-register-access-that-occurred-when-running-the-emulator-and-replaying-those-in-my-code-nope-still-broken-what-i-finally-discovered-is-that-you-need-to-pulse-the-reset-line-on-the-board-before-some-of-the-hardware-starts-working-powering-it-up-doesnt-put-you-in-a-well-defined-state-but-resetting-it-doesnso-i-now-have-a-slightly-graphically-glitchy-copy-of-doom-running-without-any-sound-displaying-on-an-amiga-whose-brain-has-been-replaced-with-a-parasitic-linux-further-updates-will-likely-make-things-even-worse-code-is-of-coursenavailablenn1-this-is-why-we-had-trouble-with-late-era-32-bit-systems-and-4gb-of-ram-a-bunch-of-your-hardware-wanted-to-be-in-the-same-address-space-and-so-you-couldnt-put-ram-there-so-you-ended-up-with-less-than-4gb-of-ramncomments" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="Hacker News 精选博客" class="md-header__button md-logo" aria-label="Hacker News 精选博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Hacker News 精选博客
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Cordoomceps - replacing an Amiga's brain with Doom\n\n来源: https://mjg59.dreamwidth.org\n链接: https://mjg59.dreamwidth.org/73001.html\n日期: Tue, 05 Aug 2025 00:30:19 GMT\n\n---\n\nThere's a lovely device called a\npistorm\n, an adapter board that glues a Raspberry Pi GPIO bus to a Motorola 68000 bus. The intended use case is that you plug it into a 68000 device and then run an emulator that reads instructions from hardware (ROM or RAM) and emulates them. You're still limited by the ~7MHz bus that the hardware is running at, but you can run the instructions as fast as you want.\nThese days you're supposed to run a custom built OS on the Pi that just does 68000 emulation, but initially it ran Linux on the Pi and a userland 68000 emulator process. And, well, that got me thinking. The emulator takes 68000 instructions, emulates them, and then talks to the hardware to implement the effects of those instructions. What if we, well, just don't? What if we just run all of our code in Linux on an ARM core and then talk to the Amiga hardware?\nWe're going to ignore x86 here, because it's weird - but most hardware that wants software to be able to communicate with it maps itself into the same address space that RAM is in. You can write to a byte of RAM, or you can write to a piece of hardware that's effectively pretending to be RAM[1]. The Amiga wasn't unusual in this respect in the 80s, and to talk to the graphics hardware you speak to a special address range that gets sent to that hardware instead of to RAM. The CPU knows nothing about this. It just indicates it wants to write to an address, and then sends the data.\nSo, if we are the CPU, we can just indicate that we want to write to an address, and provide the data. And those addresses can correspond to the hardware. So, we can write to the RAM that belongs to the Amiga, and we can write to the hardware that isn't RAM but pretends to be. And that means we can run whatever we want on the Pi and then access Amiga hardware.\nAnd, obviously, the thing we want to run is Doom, because that's what everyone runs in fucked up hardware situations.\nDoom was Amiga kryptonite. Its entire graphical model was based on memory directly representing the contents of your display, and being able to modify that by just moving pixels around. This worked because at the time VGA displays supported having a memory layout where each pixel on your screen was represented by a byte in memory containing an 8 bit value that corresponded to a lookup table containing the RGB value for that pixel.\nThe Amiga was, well, not good at this. Back in the 80s, when the Amiga hardware was developed, memory was expensive. Dedicating that much RAM to the video hardware was unthinkable - the Amiga 1000 initially shipped with only 256K of RAM, and you could fill all of that with a sufficiently colourful picture. So instead of having the idea of each pixel being associated with a specific area of memory, the Amiga used bitmaps. A bitmap is an area of memory that represents the screen, but only represents one bit of the colour depth. If you have a black and white display, you only need one bitmap. If you want to display four colours, you need two. More colours, more bitmaps. And each bitmap is stored in an independent area of RAM. You never use more memory than you need to display the number of colours you want to.\nBut that means that each bitplane contains packed information - every byte of data in a bitplane contains the bit value for 8 different pixels, because each bitplane contains one bit of information per pixel. To update one pixel on screen, you need to read from every bitmap, update one bit, and write it back, and that's a lot of additional memory accesses. Doom, but on the Amiga, was slow not just because the CPU was slow, but because there was a lot of manipulation of data to turn it into the format the Amiga wanted and then push that over a fairly slow memory bus to have it displayed.\nThe\nCDTV\nwas an aesthetically pleasing piece of hardware that absolutely sucked. It was an Amiga 500 in a hi-fi box with a caddy-loading CD drive, and it ran software that was just awful. There's no path to remediation here. No compelling apps were ever released. It's a terrible device. I love it. I bought one in 1996 because a local computer store had one and I pointed out that the company selling it had gone bankrupt some years earlier and literally nobody in my farming town was ever going to have any interest in buying a CD player that made a whirring noise when you turned it on because it had a fan and eventually they just sold it to me for not much money, and ever since then I wanted to have a CD player that ran Linux and well spoiler 30 years later I'm nearly there. That CDTV is going to be our test subject. We're going to try to get Doom running on it without executing any 68000 instructions.\nWe're facing two main problems here. The first is that all Amigas have a firmware ROM called Kickstart that runs at powerup. No matter how little you care about using any OS functionality, you can't start running your code until Kickstart has run. This means even documentation describing bare metal Amiga programming assumes that the hardware is already in the state that Kickstart left it in. This will become important later. The second is that we're going to need to actually write the code to use the Amiga hardware.\nFirst,\nlet's talk about Amiga graphics\n. We've already covered bitmaps, but for anyone used to modern hardware that's not the weirdest thing about what we're dealing with here. The CDTV's chipset supports a maximum of 64 colours in a mode called "Extra Half-Brite", or EHB, where you have 32 colours arbitrarily chosen from a palette and then 32 more colours that are identical but with half the intensity. For 64 colours we need 6 bitplanes, each of which can be located arbitrarily in the region of RAM accessible to the chipset ("chip RAM", distinguished from "fast ram" that's only accessible to the CPU). We tell the chipset where our bitplanes are and it displays them. Or, well, it does for a frame - after that the registers that pointed at our bitplanes no longer do, because when the hardware was DMAing through the bitplanes to display them it was incrementing those registers to point at the next address to DMA from. Which means that every frame we need to set those registers back.\nMaking sure you have code that's called every frame just to make your graphics work sounds intensely irritating, so Commodore gave us a way to avoid doing that. The chipset includes a coprocessor called "copper". Copper doesn't have a large set of features - in fact, it only has three. The first is that it can program chipset registers. The second is that it can wait for a specific point in screen scanout. The third (which we don't care about here) is that it can optionally skip an instruction if a certain point in screen scanout has already been reached. We can write a program (a "copper list") for the copper that tells it to program the chipset registers with the locations of our bitplanes and then wait until the end of the frame, at which point it will repeat the process. Now our bitplane pointers are always valid at the start of a frame.\nOk! We know how to display stuff. Now we just need to deal with not having 256 colours, and the whole "Doom expects pixels" thing. For the first of these, I stole code from\nADoom\n, the only Amiga doom port I could easily find source for. This looks at the 256 colour palette loaded by Doom and calculates the closest approximation it can within the constraints of EHB. ADoom also includes a bunch of CPU-specific assembly optimisation for converting the "chunky" Doom graphic buffer into the "planar" Amiga bitplanes, none of which I used because (a) it's all for 68000 series CPUs and we're running on ARM, and (b) I have a quad core CPU running at 1.4GHz and I'm going to be pushing all the graphics over a 7.14MHz bus, the graphics mode conversion is\nnot\ngoing to be the bottleneck here. Instead I just wrote a series of nested for loops that iterate through each pixel and update each bitplane and called it a day. The set of bitplanes I'm operating on here is allocated on the Linux side so I can read and write to them without being restricted by the speed of the Amiga bus (remember, each byte in each bitplane is going to be updated 8 times per frame, because it holds bits associated with 8 pixels), and then copied over to the Amiga's RAM once the frame is complete.\nAnd, kind of astonishingly, this works! Once I'd figured out where I was going wrong with RGB ordering and which order the bitplanes go in, I had a recognisable copy of Doom running. Unfortunately there were weird graphical glitches - sometimes blocks would be entirely the wrong colour. It took me a while to figure out what was going on and then I felt stupid. Recording the screen and watching in slow motion revealed that the glitches often showed parts of two frames displaying at once. The Amiga hardware is taking responsibility for scanning out the frames, and the code on the Linux side isn't synchronised with it at all. That means I could update the bitplanes while the Amiga was scanning them out, resulting in a mashup of planes from two different Doom frames being used as one Amiga frame. One approach to avoid this would be to tie the Doom event loop to the Amiga, blocking my writes until the end of scanout. The other is to use double-buffering - have two sets of bitplanes, one being displayed and the other being written to. This consumes more RAM but since I'm not using the Amiga RAM for anything else that's not a problem. With this approach I have two copper lists, one for each set of bitplanes, and switch between them on each frame. This improved things a lot but not entirely, and there's still glitches when the palette is being updated (because there's only one set of colour registers), something Doom does rather a lot, so I'm going to need to implement proper synchronisation.\nExcept. This was only working if I ran a 68K emulator first in order to run Kickstart. If I tried accessing the hardware without doing that, things were in a weird state. I could update the colour registers, but accessing RAM didn't work - I could read stuff out, but anything I wrote vanished. Some more digging cleared that up. When you turn on a CPU it needs to start executing code from somewhere. On modern x86 systems it starts from a hardcoded address of 0xFFFFFFF0, which was traditionally a long way any RAM. The 68000 family instead reads its start address from address 0x00000004, which overlaps with where the Amiga chip RAM is. We can't write anything to RAM until we're executing code, and we can't execute code until we tell the CPU where the code is, which seems like a problem. This is solved on the Amiga by powering up in a state where the Kickstart ROM is "overlayed" onto address 0. The CPU reads the start address from the ROM, which causes it to jump into the ROM and start executing code there. Early on, the code tells the hardware to stop overlaying the ROM onto the low addresses, and now the RAM is available. This is poorly documented because it's not something you need to care if you execute Kickstart which every actual Amiga does and I'm only in this position because I've made poor life choices, but ok that explained things. To turn off the overlay you write to a register in one of the Complex Interface Adaptor (CIA) chips, and things start working like you'd expect.\nExcept, they don't. Writing to that register did nothing for me. I assumed that there was some other register I needed to write to first, and went to the extent of tracing every register access that occurred when running the emulator and replaying those in my code. Nope, still broken. What I finally discovered is that you need to pulse the reset line on the board before some of the hardware starts working - powering it up doesn't put you in a well defined state, but resetting it does.\nSo, I now have a slightly graphically glitchy copy of Doom running without any sound, displaying on an Amiga whose brain has been replaced with a parasitic Linux. Further updates will likely make things even worse. Code is, of course,\navailable\n.\n[1] This is why we had trouble with late era 32 bit systems and 4GB of RAM - a bunch of your hardware wanted to be in the same address space and so you couldn't put RAM there so you ended up with less than 4GB of RAM\ncomments
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="切换到深色模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换到深色模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="切换到浅色模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换到浅色模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="分享" aria-label="分享" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/mrgolftech/rss-articles" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    rss-articles
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
  
    
  
  首页

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../../blogs/" class="md-tabs__link">
        
  
  
    
  
  所有博客

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Hacker News 精选博客" class="md-nav__button md-logo" aria-label="Hacker News 精选博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Hacker News 精选博客
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/mrgolftech/rss-articles" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    rss-articles
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    首页
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../blogs/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    所有博客
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  


  
    <a href="https://github.com/mrgolftech/rss-articles/edit/master/docs/mjg59.dreamwidth.org/Cordoomceps - replacing an Amiga's brain with Doom_20260205.md" title="编辑此页" class="md-content__button md-icon" rel="edit">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75z"/></svg>
    </a>
  
  


<h1 id="cordoomceps-replacing-an-amigas-brain-with-doomnn-httpsmjg59dreamwidthorgn-httpsmjg59dreamwidthorg73001htmln-tue-05-aug-2025-003019-gmtnn-nntheres-a-lovely-device-called-anpistormn-an-adapter-board-that-glues-a-raspberry-pi-gpio-bus-to-a-motorola-68000-bus-the-intended-use-case-is-that-you-plug-it-into-a-68000-device-and-then-run-an-emulator-that-reads-instructions-from-hardware-rom-or-ram-and-emulates-them-youre-still-limited-by-the-7mhz-bus-that-the-hardware-is-running-at-but-you-can-run-the-instructions-as-fast-as-you-wantnthese-days-youre-supposed-to-run-a-custom-built-os-on-the-pi-that-just-does-68000-emulation-but-initially-it-ran-linux-on-the-pi-and-a-userland-68000-emulator-process-and-well-that-got-me-thinking-the-emulator-takes-68000-instructions-emulates-them-and-then-talks-to-the-hardware-to-implement-the-effects-of-those-instructions-what-if-we-well-just-dont-what-if-we-just-run-all-of-our-code-in-linux-on-an-arm-core-and-then-talk-to-the-amiga-hardwarenwere-going-to-ignore-x86-here-because-its-weird-but-most-hardware-that-wants-software-to-be-able-to-communicate-with-it-maps-itself-into-the-same-address-space-that-ram-is-in-you-can-write-to-a-byte-of-ram-or-you-can-write-to-a-piece-of-hardware-thats-effectively-pretending-to-be-ram1-the-amiga-wasnt-unusual-in-this-respect-in-the-80s-and-to-talk-to-the-graphics-hardware-you-speak-to-a-special-address-range-that-gets-sent-to-that-hardware-instead-of-to-ram-the-cpu-knows-nothing-about-this-it-just-indicates-it-wants-to-write-to-an-address-and-then-sends-the-datanso-if-we-are-the-cpu-we-can-just-indicate-that-we-want-to-write-to-an-address-and-provide-the-data-and-those-addresses-can-correspond-to-the-hardware-so-we-can-write-to-the-ram-that-belongs-to-the-amiga-and-we-can-write-to-the-hardware-that-isnt-ram-but-pretends-to-be-and-that-means-we-can-run-whatever-we-want-on-the-pi-and-then-access-amiga-hardwarenand-obviously-the-thing-we-want-to-run-is-doom-because-thats-what-everyone-runs-in-fucked-up-hardware-situationsndoom-was-amiga-kryptonite-its-entire-graphical-model-was-based-on-memory-directly-representing-the-contents-of-your-display-and-being-able-to-modify-that-by-just-moving-pixels-around-this-worked-because-at-the-time-vga-displays-supported-having-a-memory-layout-where-each-pixel-on-your-screen-was-represented-by-a-byte-in-memory-containing-an-8-bit-value-that-corresponded-to-a-lookup-table-containing-the-rgb-value-for-that-pixelnthe-amiga-was-well-not-good-at-this-back-in-the-80s-when-the-amiga-hardware-was-developed-memory-was-expensive-dedicating-that-much-ram-to-the-video-hardware-was-unthinkable-the-amiga-1000-initially-shipped-with-only-256k-of-ram-and-you-could-fill-all-of-that-with-a-sufficiently-colourful-picture-so-instead-of-having-the-idea-of-each-pixel-being-associated-with-a-specific-area-of-memory-the-amiga-used-bitmaps-a-bitmap-is-an-area-of-memory-that-represents-the-screen-but-only-represents-one-bit-of-the-colour-depth-if-you-have-a-black-and-white-display-you-only-need-one-bitmap-if-you-want-to-display-four-colours-you-need-two-more-colours-more-bitmaps-and-each-bitmap-is-stored-in-an-independent-area-of-ram-you-never-use-more-memory-than-you-need-to-display-the-number-of-colours-you-want-tonbut-that-means-that-each-bitplane-contains-packed-information-every-byte-of-data-in-a-bitplane-contains-the-bit-value-for-8-different-pixels-because-each-bitplane-contains-one-bit-of-information-per-pixel-to-update-one-pixel-on-screen-you-need-to-read-from-every-bitmap-update-one-bit-and-write-it-back-and-thats-a-lot-of-additional-memory-accesses-doom-but-on-the-amiga-was-slow-not-just-because-the-cpu-was-slow-but-because-there-was-a-lot-of-manipulation-of-data-to-turn-it-into-the-format-the-amiga-wanted-and-then-push-that-over-a-fairly-slow-memory-bus-to-have-it-displayednthencdtvnwas-an-aesthetically-pleasing-piece-of-hardware-that-absolutely-sucked-it-was-an-amiga-500-in-a-hi-fi-box-with-a-caddy-loading-cd-drive-and-it-ran-software-that-was-just-awful-theres-no-path-to-remediation-here-no-compelling-apps-were-ever-released-its-a-terrible-device-i-love-it-i-bought-one-in-1996-because-a-local-computer-store-had-one-and-i-pointed-out-that-the-company-selling-it-had-gone-bankrupt-some-years-earlier-and-literally-nobody-in-my-farming-town-was-ever-going-to-have-any-interest-in-buying-a-cd-player-that-made-a-whirring-noise-when-you-turned-it-on-because-it-had-a-fan-and-eventually-they-just-sold-it-to-me-for-not-much-money-and-ever-since-then-i-wanted-to-have-a-cd-player-that-ran-linux-and-well-spoiler-30-years-later-im-nearly-there-that-cdtv-is-going-to-be-our-test-subject-were-going-to-try-to-get-doom-running-on-it-without-executing-any-68000-instructionsnwere-facing-two-main-problems-here-the-first-is-that-all-amigas-have-a-firmware-rom-called-kickstart-that-runs-at-powerup-no-matter-how-little-you-care-about-using-any-os-functionality-you-cant-start-running-your-code-until-kickstart-has-run-this-means-even-documentation-describing-bare-metal-amiga-programming-assumes-that-the-hardware-is-already-in-the-state-that-kickstart-left-it-in-this-will-become-important-later-the-second-is-that-were-going-to-need-to-actually-write-the-code-to-use-the-amiga-hardwarenfirstnlets-talk-about-amiga-graphicsn-weve-already-covered-bitmaps-but-for-anyone-used-to-modern-hardware-thats-not-the-weirdest-thing-about-what-were-dealing-with-here-the-cdtvs-chipset-supports-a-maximum-of-64-colours-in-a-mode-called-extra-half-brite-or-ehb-where-you-have-32-colours-arbitrarily-chosen-from-a-palette-and-then-32-more-colours-that-are-identical-but-with-half-the-intensity-for-64-colours-we-need-6-bitplanes-each-of-which-can-be-located-arbitrarily-in-the-region-of-ram-accessible-to-the-chipset-chip-ram-distinguished-from-fast-ram-thats-only-accessible-to-the-cpu-we-tell-the-chipset-where-our-bitplanes-are-and-it-displays-them-or-well-it-does-for-a-frame-after-that-the-registers-that-pointed-at-our-bitplanes-no-longer-do-because-when-the-hardware-was-dmaing-through-the-bitplanes-to-display-them-it-was-incrementing-those-registers-to-point-at-the-next-address-to-dma-from-which-means-that-every-frame-we-need-to-set-those-registers-backnmaking-sure-you-have-code-thats-called-every-frame-just-to-make-your-graphics-work-sounds-intensely-irritating-so-commodore-gave-us-a-way-to-avoid-doing-that-the-chipset-includes-a-coprocessor-called-copper-copper-doesnt-have-a-large-set-of-features-in-fact-it-only-has-three-the-first-is-that-it-can-program-chipset-registers-the-second-is-that-it-can-wait-for-a-specific-point-in-screen-scanout-the-third-which-we-dont-care-about-here-is-that-it-can-optionally-skip-an-instruction-if-a-certain-point-in-screen-scanout-has-already-been-reached-we-can-write-a-program-a-copper-list-for-the-copper-that-tells-it-to-program-the-chipset-registers-with-the-locations-of-our-bitplanes-and-then-wait-until-the-end-of-the-frame-at-which-point-it-will-repeat-the-process-now-our-bitplane-pointers-are-always-valid-at-the-start-of-a-framenok-we-know-how-to-display-stuff-now-we-just-need-to-deal-with-not-having-256-colours-and-the-whole-doom-expects-pixels-thing-for-the-first-of-these-i-stole-code-fromnadoomn-the-only-amiga-doom-port-i-could-easily-find-source-for-this-looks-at-the-256-colour-palette-loaded-by-doom-and-calculates-the-closest-approximation-it-can-within-the-constraints-of-ehb-adoom-also-includes-a-bunch-of-cpu-specific-assembly-optimisation-for-converting-the-chunky-doom-graphic-buffer-into-the-planar-amiga-bitplanes-none-of-which-i-used-because-a-its-all-for-68000-series-cpus-and-were-running-on-arm-and-b-i-have-a-quad-core-cpu-running-at-14ghz-and-im-going-to-be-pushing-all-the-graphics-over-a-714mhz-bus-the-graphics-mode-conversion-isnnotngoing-to-be-the-bottleneck-here-instead-i-just-wrote-a-series-of-nested-for-loops-that-iterate-through-each-pixel-and-update-each-bitplane-and-called-it-a-day-the-set-of-bitplanes-im-operating-on-here-is-allocated-on-the-linux-side-so-i-can-read-and-write-to-them-without-being-restricted-by-the-speed-of-the-amiga-bus-remember-each-byte-in-each-bitplane-is-going-to-be-updated-8-times-per-frame-because-it-holds-bits-associated-with-8-pixels-and-then-copied-over-to-the-amigas-ram-once-the-frame-is-completenand-kind-of-astonishingly-this-works-once-id-figured-out-where-i-was-going-wrong-with-rgb-ordering-and-which-order-the-bitplanes-go-in-i-had-a-recognisable-copy-of-doom-running-unfortunately-there-were-weird-graphical-glitches-sometimes-blocks-would-be-entirely-the-wrong-colour-it-took-me-a-while-to-figure-out-what-was-going-on-and-then-i-felt-stupid-recording-the-screen-and-watching-in-slow-motion-revealed-that-the-glitches-often-showed-parts-of-two-frames-displaying-at-once-the-amiga-hardware-is-taking-responsibility-for-scanning-out-the-frames-and-the-code-on-the-linux-side-isnt-synchronised-with-it-at-all-that-means-i-could-update-the-bitplanes-while-the-amiga-was-scanning-them-out-resulting-in-a-mashup-of-planes-from-two-different-doom-frames-being-used-as-one-amiga-frame-one-approach-to-avoid-this-would-be-to-tie-the-doom-event-loop-to-the-amiga-blocking-my-writes-until-the-end-of-scanout-the-other-is-to-use-double-buffering-have-two-sets-of-bitplanes-one-being-displayed-and-the-other-being-written-to-this-consumes-more-ram-but-since-im-not-using-the-amiga-ram-for-anything-else-thats-not-a-problem-with-this-approach-i-have-two-copper-lists-one-for-each-set-of-bitplanes-and-switch-between-them-on-each-frame-this-improved-things-a-lot-but-not-entirely-and-theres-still-glitches-when-the-palette-is-being-updated-because-theres-only-one-set-of-colour-registers-something-doom-does-rather-a-lot-so-im-going-to-need-to-implement-proper-synchronisationnexcept-this-was-only-working-if-i-ran-a-68k-emulator-first-in-order-to-run-kickstart-if-i-tried-accessing-the-hardware-without-doing-that-things-were-in-a-weird-state-i-could-update-the-colour-registers-but-accessing-ram-didnt-work-i-could-read-stuff-out-but-anything-i-wrote-vanished-some-more-digging-cleared-that-up-when-you-turn-on-a-cpu-it-needs-to-start-executing-code-from-somewhere-on-modern-x86-systems-it-starts-from-a-hardcoded-address-of-0xfffffff0-which-was-traditionally-a-long-way-any-ram-the-68000-family-instead-reads-its-start-address-from-address-0x00000004-which-overlaps-with-where-the-amiga-chip-ram-is-we-cant-write-anything-to-ram-until-were-executing-code-and-we-cant-execute-code-until-we-tell-the-cpu-where-the-code-is-which-seems-like-a-problem-this-is-solved-on-the-amiga-by-powering-up-in-a-state-where-the-kickstart-rom-is-overlayed-onto-address-0-the-cpu-reads-the-start-address-from-the-rom-which-causes-it-to-jump-into-the-rom-and-start-executing-code-there-early-on-the-code-tells-the-hardware-to-stop-overlaying-the-rom-onto-the-low-addresses-and-now-the-ram-is-available-this-is-poorly-documented-because-its-not-something-you-need-to-care-if-you-execute-kickstart-which-every-actual-amiga-does-and-im-only-in-this-position-because-ive-made-poor-life-choices-but-ok-that-explained-things-to-turn-off-the-overlay-you-write-to-a-register-in-one-of-the-complex-interface-adaptor-cia-chips-and-things-start-working-like-youd-expectnexcept-they-dont-writing-to-that-register-did-nothing-for-me-i-assumed-that-there-was-some-other-register-i-needed-to-write-to-first-and-went-to-the-extent-of-tracing-every-register-access-that-occurred-when-running-the-emulator-and-replaying-those-in-my-code-nope-still-broken-what-i-finally-discovered-is-that-you-need-to-pulse-the-reset-line-on-the-board-before-some-of-the-hardware-starts-working-powering-it-up-doesnt-put-you-in-a-well-defined-state-but-resetting-it-doesnso-i-now-have-a-slightly-graphically-glitchy-copy-of-doom-running-without-any-sound-displaying-on-an-amiga-whose-brain-has-been-replaced-with-a-parasitic-linux-further-updates-will-likely-make-things-even-worse-code-is-of-coursenavailablenn1-this-is-why-we-had-trouble-with-late-era-32-bit-systems-and-4gb-of-ram-a-bunch-of-your-hardware-wanted-to-be-in-the-same-address-space-and-so-you-couldnt-put-ram-there-so-you-ended-up-with-less-than-4gb-of-ramncomments">Cordoomceps - replacing an Amiga's brain with Doom\n\n<strong>来源:</strong> https://mjg59.dreamwidth.org\n<strong>链接:</strong> https://mjg59.dreamwidth.org/73001.html\n<strong>日期:</strong> Tue, 05 Aug 2025 00:30:19 GMT\n\n---\n\nThere's a lovely device called a\npistorm\n, an adapter board that glues a Raspberry Pi GPIO bus to a Motorola 68000 bus. The intended use case is that you plug it into a 68000 device and then run an emulator that reads instructions from hardware (ROM or RAM) and emulates them. You're still limited by the ~7MHz bus that the hardware is running at, but you can run the instructions as fast as you want.\nThese days you're supposed to run a custom built OS on the Pi that just does 68000 emulation, but initially it ran Linux on the Pi and a userland 68000 emulator process. And, well, that got me thinking. The emulator takes 68000 instructions, emulates them, and then talks to the hardware to implement the effects of those instructions. What if we, well, just don't? What if we just run all of our code in Linux on an ARM core and then talk to the Amiga hardware?\nWe're going to ignore x86 here, because it's weird - but most hardware that wants software to be able to communicate with it maps itself into the same address space that RAM is in. You can write to a byte of RAM, or you can write to a piece of hardware that's effectively pretending to be RAM[1]. The Amiga wasn't unusual in this respect in the 80s, and to talk to the graphics hardware you speak to a special address range that gets sent to that hardware instead of to RAM. The CPU knows nothing about this. It just indicates it wants to write to an address, and then sends the data.\nSo, if we are the CPU, we can just indicate that we want to write to an address, and provide the data. And those addresses can correspond to the hardware. So, we can write to the RAM that belongs to the Amiga, and we can write to the hardware that isn't RAM but pretends to be. And that means we can run whatever we want on the Pi and then access Amiga hardware.\nAnd, obviously, the thing we want to run is Doom, because that's what everyone runs in fucked up hardware situations.\nDoom was Amiga kryptonite. Its entire graphical model was based on memory directly representing the contents of your display, and being able to modify that by just moving pixels around. This worked because at the time VGA displays supported having a memory layout where each pixel on your screen was represented by a byte in memory containing an 8 bit value that corresponded to a lookup table containing the RGB value for that pixel.\nThe Amiga was, well, not good at this. Back in the 80s, when the Amiga hardware was developed, memory was expensive. Dedicating that much RAM to the video hardware was unthinkable - the Amiga 1000 initially shipped with only 256K of RAM, and you could fill all of that with a sufficiently colourful picture. So instead of having the idea of each pixel being associated with a specific area of memory, the Amiga used bitmaps. A bitmap is an area of memory that represents the screen, but only represents one bit of the colour depth. If you have a black and white display, you only need one bitmap. If you want to display four colours, you need two. More colours, more bitmaps. And each bitmap is stored in an independent area of RAM. You never use more memory than you need to display the number of colours you want to.\nBut that means that each bitplane contains packed information - every byte of data in a bitplane contains the bit value for 8 different pixels, because each bitplane contains one bit of information per pixel. To update one pixel on screen, you need to read from every bitmap, update one bit, and write it back, and that's a lot of additional memory accesses. Doom, but on the Amiga, was slow not just because the CPU was slow, but because there was a lot of manipulation of data to turn it into the format the Amiga wanted and then push that over a fairly slow memory bus to have it displayed.\nThe\nCDTV\nwas an aesthetically pleasing piece of hardware that absolutely sucked. It was an Amiga 500 in a hi-fi box with a caddy-loading CD drive, and it ran software that was just awful. There's no path to remediation here. No compelling apps were ever released. It's a terrible device. I love it. I bought one in 1996 because a local computer store had one and I pointed out that the company selling it had gone bankrupt some years earlier and literally nobody in my farming town was ever going to have any interest in buying a CD player that made a whirring noise when you turned it on because it had a fan and eventually they just sold it to me for not much money, and ever since then I wanted to have a CD player that ran Linux and well spoiler 30 years later I'm nearly there. That CDTV is going to be our test subject. We're going to try to get Doom running on it without executing any 68000 instructions.\nWe're facing two main problems here. The first is that all Amigas have a firmware ROM called Kickstart that runs at powerup. No matter how little you care about using any OS functionality, you can't start running your code until Kickstart has run. This means even documentation describing bare metal Amiga programming assumes that the hardware is already in the state that Kickstart left it in. This will become important later. The second is that we're going to need to actually write the code to use the Amiga hardware.\nFirst,\nlet's talk about Amiga graphics\n. We've already covered bitmaps, but for anyone used to modern hardware that's not the weirdest thing about what we're dealing with here. The CDTV's chipset supports a maximum of 64 colours in a mode called "Extra Half-Brite", or EHB, where you have 32 colours arbitrarily chosen from a palette and then 32 more colours that are identical but with half the intensity. For 64 colours we need 6 bitplanes, each of which can be located arbitrarily in the region of RAM accessible to the chipset ("chip RAM", distinguished from "fast ram" that's only accessible to the CPU). We tell the chipset where our bitplanes are and it displays them. Or, well, it does for a frame - after that the registers that pointed at our bitplanes no longer do, because when the hardware was DMAing through the bitplanes to display them it was incrementing those registers to point at the next address to DMA from. Which means that every frame we need to set those registers back.\nMaking sure you have code that's called every frame just to make your graphics work sounds intensely irritating, so Commodore gave us a way to avoid doing that. The chipset includes a coprocessor called "copper". Copper doesn't have a large set of features - in fact, it only has three. The first is that it can program chipset registers. The second is that it can wait for a specific point in screen scanout. The third (which we don't care about here) is that it can optionally skip an instruction if a certain point in screen scanout has already been reached. We can write a program (a "copper list") for the copper that tells it to program the chipset registers with the locations of our bitplanes and then wait until the end of the frame, at which point it will repeat the process. Now our bitplane pointers are always valid at the start of a frame.\nOk! We know how to display stuff. Now we just need to deal with not having 256 colours, and the whole "Doom expects pixels" thing. For the first of these, I stole code from\nADoom\n, the only Amiga doom port I could easily find source for. This looks at the 256 colour palette loaded by Doom and calculates the closest approximation it can within the constraints of EHB. ADoom also includes a bunch of CPU-specific assembly optimisation for converting the "chunky" Doom graphic buffer into the "planar" Amiga bitplanes, none of which I used because (a) it's all for 68000 series CPUs and we're running on ARM, and (b) I have a quad core CPU running at 1.4GHz and I'm going to be pushing all the graphics over a 7.14MHz bus, the graphics mode conversion is\nnot\ngoing to be the bottleneck here. Instead I just wrote a series of nested for loops that iterate through each pixel and update each bitplane and called it a day. The set of bitplanes I'm operating on here is allocated on the Linux side so I can read and write to them without being restricted by the speed of the Amiga bus (remember, each byte in each bitplane is going to be updated 8 times per frame, because it holds bits associated with 8 pixels), and then copied over to the Amiga's RAM once the frame is complete.\nAnd, kind of astonishingly, this works! Once I'd figured out where I was going wrong with RGB ordering and which order the bitplanes go in, I had a recognisable copy of Doom running. Unfortunately there were weird graphical glitches - sometimes blocks would be entirely the wrong colour. It took me a while to figure out what was going on and then I felt stupid. Recording the screen and watching in slow motion revealed that the glitches often showed parts of two frames displaying at once. The Amiga hardware is taking responsibility for scanning out the frames, and the code on the Linux side isn't synchronised with it at all. That means I could update the bitplanes while the Amiga was scanning them out, resulting in a mashup of planes from two different Doom frames being used as one Amiga frame. One approach to avoid this would be to tie the Doom event loop to the Amiga, blocking my writes until the end of scanout. The other is to use double-buffering - have two sets of bitplanes, one being displayed and the other being written to. This consumes more RAM but since I'm not using the Amiga RAM for anything else that's not a problem. With this approach I have two copper lists, one for each set of bitplanes, and switch between them on each frame. This improved things a lot but not entirely, and there's still glitches when the palette is being updated (because there's only one set of colour registers), something Doom does rather a lot, so I'm going to need to implement proper synchronisation.\nExcept. This was only working if I ran a 68K emulator first in order to run Kickstart. If I tried accessing the hardware without doing that, things were in a weird state. I could update the colour registers, but accessing RAM didn't work - I could read stuff out, but anything I wrote vanished. Some more digging cleared that up. When you turn on a CPU it needs to start executing code from somewhere. On modern x86 systems it starts from a hardcoded address of 0xFFFFFFF0, which was traditionally a long way any RAM. The 68000 family instead reads its start address from address 0x00000004, which overlaps with where the Amiga chip RAM is. We can't write anything to RAM until we're executing code, and we can't execute code until we tell the CPU where the code is, which seems like a problem. This is solved on the Amiga by powering up in a state where the Kickstart ROM is "overlayed" onto address 0. The CPU reads the start address from the ROM, which causes it to jump into the ROM and start executing code there. Early on, the code tells the hardware to stop overlaying the ROM onto the low addresses, and now the RAM is available. This is poorly documented because it's not something you need to care if you execute Kickstart which every actual Amiga does and I'm only in this position because I've made poor life choices, but ok that explained things. To turn off the overlay you write to a register in one of the Complex Interface Adaptor (CIA) chips, and things start working like you'd expect.\nExcept, they don't. Writing to that register did nothing for me. I assumed that there was some other register I needed to write to first, and went to the extent of tracing every register access that occurred when running the emulator and replaying those in my code. Nope, still broken. What I finally discovered is that you need to pulse the reset line on the board before some of the hardware starts working - powering it up doesn't put you in a well defined state, but resetting it does.\nSo, I now have a slightly graphically glitchy copy of Doom running without any sound, displaying on an Amiga whose brain has been replaced with a parasitic Linux. Further updates will likely make things even worse. Code is, of course,\navailable\n.\n[1] This is why we had trouble with late era 32 bit systems and 4GB of RAM - a bunch of your hardware wanted to be in the same address space and so you couldn't put RAM there so you ended up with less than 4GB of RAM\ncomments<a class="headerlink" href="#cordoomceps-replacing-an-amigas-brain-with-doomnn-httpsmjg59dreamwidthorgn-httpsmjg59dreamwidthorg73001htmln-tue-05-aug-2025-003019-gmtnn-nntheres-a-lovely-device-called-anpistormn-an-adapter-board-that-glues-a-raspberry-pi-gpio-bus-to-a-motorola-68000-bus-the-intended-use-case-is-that-you-plug-it-into-a-68000-device-and-then-run-an-emulator-that-reads-instructions-from-hardware-rom-or-ram-and-emulates-them-youre-still-limited-by-the-7mhz-bus-that-the-hardware-is-running-at-but-you-can-run-the-instructions-as-fast-as-you-wantnthese-days-youre-supposed-to-run-a-custom-built-os-on-the-pi-that-just-does-68000-emulation-but-initially-it-ran-linux-on-the-pi-and-a-userland-68000-emulator-process-and-well-that-got-me-thinking-the-emulator-takes-68000-instructions-emulates-them-and-then-talks-to-the-hardware-to-implement-the-effects-of-those-instructions-what-if-we-well-just-dont-what-if-we-just-run-all-of-our-code-in-linux-on-an-arm-core-and-then-talk-to-the-amiga-hardwarenwere-going-to-ignore-x86-here-because-its-weird-but-most-hardware-that-wants-software-to-be-able-to-communicate-with-it-maps-itself-into-the-same-address-space-that-ram-is-in-you-can-write-to-a-byte-of-ram-or-you-can-write-to-a-piece-of-hardware-thats-effectively-pretending-to-be-ram1-the-amiga-wasnt-unusual-in-this-respect-in-the-80s-and-to-talk-to-the-graphics-hardware-you-speak-to-a-special-address-range-that-gets-sent-to-that-hardware-instead-of-to-ram-the-cpu-knows-nothing-about-this-it-just-indicates-it-wants-to-write-to-an-address-and-then-sends-the-datanso-if-we-are-the-cpu-we-can-just-indicate-that-we-want-to-write-to-an-address-and-provide-the-data-and-those-addresses-can-correspond-to-the-hardware-so-we-can-write-to-the-ram-that-belongs-to-the-amiga-and-we-can-write-to-the-hardware-that-isnt-ram-but-pretends-to-be-and-that-means-we-can-run-whatever-we-want-on-the-pi-and-then-access-amiga-hardwarenand-obviously-the-thing-we-want-to-run-is-doom-because-thats-what-everyone-runs-in-fucked-up-hardware-situationsndoom-was-amiga-kryptonite-its-entire-graphical-model-was-based-on-memory-directly-representing-the-contents-of-your-display-and-being-able-to-modify-that-by-just-moving-pixels-around-this-worked-because-at-the-time-vga-displays-supported-having-a-memory-layout-where-each-pixel-on-your-screen-was-represented-by-a-byte-in-memory-containing-an-8-bit-value-that-corresponded-to-a-lookup-table-containing-the-rgb-value-for-that-pixelnthe-amiga-was-well-not-good-at-this-back-in-the-80s-when-the-amiga-hardware-was-developed-memory-was-expensive-dedicating-that-much-ram-to-the-video-hardware-was-unthinkable-the-amiga-1000-initially-shipped-with-only-256k-of-ram-and-you-could-fill-all-of-that-with-a-sufficiently-colourful-picture-so-instead-of-having-the-idea-of-each-pixel-being-associated-with-a-specific-area-of-memory-the-amiga-used-bitmaps-a-bitmap-is-an-area-of-memory-that-represents-the-screen-but-only-represents-one-bit-of-the-colour-depth-if-you-have-a-black-and-white-display-you-only-need-one-bitmap-if-you-want-to-display-four-colours-you-need-two-more-colours-more-bitmaps-and-each-bitmap-is-stored-in-an-independent-area-of-ram-you-never-use-more-memory-than-you-need-to-display-the-number-of-colours-you-want-tonbut-that-means-that-each-bitplane-contains-packed-information-every-byte-of-data-in-a-bitplane-contains-the-bit-value-for-8-different-pixels-because-each-bitplane-contains-one-bit-of-information-per-pixel-to-update-one-pixel-on-screen-you-need-to-read-from-every-bitmap-update-one-bit-and-write-it-back-and-thats-a-lot-of-additional-memory-accesses-doom-but-on-the-amiga-was-slow-not-just-because-the-cpu-was-slow-but-because-there-was-a-lot-of-manipulation-of-data-to-turn-it-into-the-format-the-amiga-wanted-and-then-push-that-over-a-fairly-slow-memory-bus-to-have-it-displayednthencdtvnwas-an-aesthetically-pleasing-piece-of-hardware-that-absolutely-sucked-it-was-an-amiga-500-in-a-hi-fi-box-with-a-caddy-loading-cd-drive-and-it-ran-software-that-was-just-awful-theres-no-path-to-remediation-here-no-compelling-apps-were-ever-released-its-a-terrible-device-i-love-it-i-bought-one-in-1996-because-a-local-computer-store-had-one-and-i-pointed-out-that-the-company-selling-it-had-gone-bankrupt-some-years-earlier-and-literally-nobody-in-my-farming-town-was-ever-going-to-have-any-interest-in-buying-a-cd-player-that-made-a-whirring-noise-when-you-turned-it-on-because-it-had-a-fan-and-eventually-they-just-sold-it-to-me-for-not-much-money-and-ever-since-then-i-wanted-to-have-a-cd-player-that-ran-linux-and-well-spoiler-30-years-later-im-nearly-there-that-cdtv-is-going-to-be-our-test-subject-were-going-to-try-to-get-doom-running-on-it-without-executing-any-68000-instructionsnwere-facing-two-main-problems-here-the-first-is-that-all-amigas-have-a-firmware-rom-called-kickstart-that-runs-at-powerup-no-matter-how-little-you-care-about-using-any-os-functionality-you-cant-start-running-your-code-until-kickstart-has-run-this-means-even-documentation-describing-bare-metal-amiga-programming-assumes-that-the-hardware-is-already-in-the-state-that-kickstart-left-it-in-this-will-become-important-later-the-second-is-that-were-going-to-need-to-actually-write-the-code-to-use-the-amiga-hardwarenfirstnlets-talk-about-amiga-graphicsn-weve-already-covered-bitmaps-but-for-anyone-used-to-modern-hardware-thats-not-the-weirdest-thing-about-what-were-dealing-with-here-the-cdtvs-chipset-supports-a-maximum-of-64-colours-in-a-mode-called-extra-half-brite-or-ehb-where-you-have-32-colours-arbitrarily-chosen-from-a-palette-and-then-32-more-colours-that-are-identical-but-with-half-the-intensity-for-64-colours-we-need-6-bitplanes-each-of-which-can-be-located-arbitrarily-in-the-region-of-ram-accessible-to-the-chipset-chip-ram-distinguished-from-fast-ram-thats-only-accessible-to-the-cpu-we-tell-the-chipset-where-our-bitplanes-are-and-it-displays-them-or-well-it-does-for-a-frame-after-that-the-registers-that-pointed-at-our-bitplanes-no-longer-do-because-when-the-hardware-was-dmaing-through-the-bitplanes-to-display-them-it-was-incrementing-those-registers-to-point-at-the-next-address-to-dma-from-which-means-that-every-frame-we-need-to-set-those-registers-backnmaking-sure-you-have-code-thats-called-every-frame-just-to-make-your-graphics-work-sounds-intensely-irritating-so-commodore-gave-us-a-way-to-avoid-doing-that-the-chipset-includes-a-coprocessor-called-copper-copper-doesnt-have-a-large-set-of-features-in-fact-it-only-has-three-the-first-is-that-it-can-program-chipset-registers-the-second-is-that-it-can-wait-for-a-specific-point-in-screen-scanout-the-third-which-we-dont-care-about-here-is-that-it-can-optionally-skip-an-instruction-if-a-certain-point-in-screen-scanout-has-already-been-reached-we-can-write-a-program-a-copper-list-for-the-copper-that-tells-it-to-program-the-chipset-registers-with-the-locations-of-our-bitplanes-and-then-wait-until-the-end-of-the-frame-at-which-point-it-will-repeat-the-process-now-our-bitplane-pointers-are-always-valid-at-the-start-of-a-framenok-we-know-how-to-display-stuff-now-we-just-need-to-deal-with-not-having-256-colours-and-the-whole-doom-expects-pixels-thing-for-the-first-of-these-i-stole-code-fromnadoomn-the-only-amiga-doom-port-i-could-easily-find-source-for-this-looks-at-the-256-colour-palette-loaded-by-doom-and-calculates-the-closest-approximation-it-can-within-the-constraints-of-ehb-adoom-also-includes-a-bunch-of-cpu-specific-assembly-optimisation-for-converting-the-chunky-doom-graphic-buffer-into-the-planar-amiga-bitplanes-none-of-which-i-used-because-a-its-all-for-68000-series-cpus-and-were-running-on-arm-and-b-i-have-a-quad-core-cpu-running-at-14ghz-and-im-going-to-be-pushing-all-the-graphics-over-a-714mhz-bus-the-graphics-mode-conversion-isnnotngoing-to-be-the-bottleneck-here-instead-i-just-wrote-a-series-of-nested-for-loops-that-iterate-through-each-pixel-and-update-each-bitplane-and-called-it-a-day-the-set-of-bitplanes-im-operating-on-here-is-allocated-on-the-linux-side-so-i-can-read-and-write-to-them-without-being-restricted-by-the-speed-of-the-amiga-bus-remember-each-byte-in-each-bitplane-is-going-to-be-updated-8-times-per-frame-because-it-holds-bits-associated-with-8-pixels-and-then-copied-over-to-the-amigas-ram-once-the-frame-is-completenand-kind-of-astonishingly-this-works-once-id-figured-out-where-i-was-going-wrong-with-rgb-ordering-and-which-order-the-bitplanes-go-in-i-had-a-recognisable-copy-of-doom-running-unfortunately-there-were-weird-graphical-glitches-sometimes-blocks-would-be-entirely-the-wrong-colour-it-took-me-a-while-to-figure-out-what-was-going-on-and-then-i-felt-stupid-recording-the-screen-and-watching-in-slow-motion-revealed-that-the-glitches-often-showed-parts-of-two-frames-displaying-at-once-the-amiga-hardware-is-taking-responsibility-for-scanning-out-the-frames-and-the-code-on-the-linux-side-isnt-synchronised-with-it-at-all-that-means-i-could-update-the-bitplanes-while-the-amiga-was-scanning-them-out-resulting-in-a-mashup-of-planes-from-two-different-doom-frames-being-used-as-one-amiga-frame-one-approach-to-avoid-this-would-be-to-tie-the-doom-event-loop-to-the-amiga-blocking-my-writes-until-the-end-of-scanout-the-other-is-to-use-double-buffering-have-two-sets-of-bitplanes-one-being-displayed-and-the-other-being-written-to-this-consumes-more-ram-but-since-im-not-using-the-amiga-ram-for-anything-else-thats-not-a-problem-with-this-approach-i-have-two-copper-lists-one-for-each-set-of-bitplanes-and-switch-between-them-on-each-frame-this-improved-things-a-lot-but-not-entirely-and-theres-still-glitches-when-the-palette-is-being-updated-because-theres-only-one-set-of-colour-registers-something-doom-does-rather-a-lot-so-im-going-to-need-to-implement-proper-synchronisationnexcept-this-was-only-working-if-i-ran-a-68k-emulator-first-in-order-to-run-kickstart-if-i-tried-accessing-the-hardware-without-doing-that-things-were-in-a-weird-state-i-could-update-the-colour-registers-but-accessing-ram-didnt-work-i-could-read-stuff-out-but-anything-i-wrote-vanished-some-more-digging-cleared-that-up-when-you-turn-on-a-cpu-it-needs-to-start-executing-code-from-somewhere-on-modern-x86-systems-it-starts-from-a-hardcoded-address-of-0xfffffff0-which-was-traditionally-a-long-way-any-ram-the-68000-family-instead-reads-its-start-address-from-address-0x00000004-which-overlaps-with-where-the-amiga-chip-ram-is-we-cant-write-anything-to-ram-until-were-executing-code-and-we-cant-execute-code-until-we-tell-the-cpu-where-the-code-is-which-seems-like-a-problem-this-is-solved-on-the-amiga-by-powering-up-in-a-state-where-the-kickstart-rom-is-overlayed-onto-address-0-the-cpu-reads-the-start-address-from-the-rom-which-causes-it-to-jump-into-the-rom-and-start-executing-code-there-early-on-the-code-tells-the-hardware-to-stop-overlaying-the-rom-onto-the-low-addresses-and-now-the-ram-is-available-this-is-poorly-documented-because-its-not-something-you-need-to-care-if-you-execute-kickstart-which-every-actual-amiga-does-and-im-only-in-this-position-because-ive-made-poor-life-choices-but-ok-that-explained-things-to-turn-off-the-overlay-you-write-to-a-register-in-one-of-the-complex-interface-adaptor-cia-chips-and-things-start-working-like-youd-expectnexcept-they-dont-writing-to-that-register-did-nothing-for-me-i-assumed-that-there-was-some-other-register-i-needed-to-write-to-first-and-went-to-the-extent-of-tracing-every-register-access-that-occurred-when-running-the-emulator-and-replaying-those-in-my-code-nope-still-broken-what-i-finally-discovered-is-that-you-need-to-pulse-the-reset-line-on-the-board-before-some-of-the-hardware-starts-working-powering-it-up-doesnt-put-you-in-a-well-defined-state-but-resetting-it-doesnso-i-now-have-a-slightly-graphically-glitchy-copy-of-doom-running-without-any-sound-displaying-on-an-amiga-whose-brain-has-been-replaced-with-a-parasitic-linux-further-updates-will-likely-make-things-even-worse-code-is-of-coursenavailablenn1-this-is-why-we-had-trouble-with-late-era-32-bit-systems-and-4gb-of-ram-a-bunch-of-your-hardware-wanted-to-be-in-the-same-address-space-and-so-you-couldnt-put-ram-there-so-you-ended-up-with-less-than-4gb-of-ramncomments" title="Permanent link">&para;</a></h1>







  
    
  
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="最后更新">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1zM12.5 7v5.2l4 2.4-1 1L11 13V7zM11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-iso_date" title="2026年2月5日 10:03:27 UTC">2026-02-05</span>
  </span>

    
    
    
    
  </aside>


  



  <form class="md-feedback" name="feedback" hidden>
    <fieldset>
      <legend class="md-feedback__title">
        这篇文章有帮助吗？
      </legend>
      <div class="md-feedback__inner">
        <div class="md-feedback__list">
          
            <button class="md-feedback__icon md-icon" type="submit" title="有帮助" data-md-value="1">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5 9v12H1V9zm4 12a2 2 0 0 1-2-2V9c0-.55.22-1.05.59-1.41L14.17 1l1.06 1.06c.27.27.44.64.44 1.05l-.03.32L14.69 8H21a2 2 0 0 1 2 2v2c0 .26-.05.5-.14.73l-3.02 7.05C19.54 20.5 18.83 21 18 21zm0-2h9.03L21 12v-2h-8.79l1.13-5.32L9 9.03z"/></svg>
            </button>
          
            <button class="md-feedback__icon md-icon" type="submit" title="没帮助" data-md-value="0">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 15V3h4v12zM15 3a2 2 0 0 1 2 2v10c0 .55-.22 1.05-.59 1.41L9.83 23l-1.06-1.06c-.27-.27-.44-.64-.44-1.06l.03-.31.95-4.57H3a2 2 0 0 1-2-2v-2c0-.26.05-.5.14-.73l3.02-7.05C4.46 3.5 5.17 3 6 3zm0 2H5.97L3 12v2h8.78l-1.13 5.32L15 14.97z"/></svg>
            </button>
          
        </div>
        <div class="md-feedback__note">
          
            <div data-md-value="1" hidden>
              
              
                
              
              
              
                
                
              
              感谢反馈！
            </div>
          
            <div data-md-value="0" hidden>
              
              
                
              
              
              
                
                
              
              感谢反馈！我们会改进。
            </div>
          
        </div>
      </div>
    </fieldset>
  </form>


                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2026 - OpenClaw
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        
<div class="md-social">
  
    
    
    
    
    <a href="https://github.com/mrgolftech" target="_blank" rel="noopener" title="GitHub" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../..", "features": ["navigation.instant", "navigation.tracking", "navigation.tabs", "navigation.sections", "navigation.expand", "navigation.top", "search.suggest", "search.highlight", "search.share", "content.code.copy", "content.action.edit"], "search": "../../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.79ae519e.min.js"></script>
      
    
  </body>
</html>