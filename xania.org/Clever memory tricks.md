# Clever memory tricks

**来源:** [xania.org](https://xania.org)
**发布时间:** 
**链接:** http://xania.org/202512/22-memory-cunningness?utm_source=feed&utm_medium=rss

---

{'type': 'application/xhtml+xml', 'language': 'en-GB', 'base': 'https://xania.org/feed', 'value': '<p class="ai-disclaimer">Written by me, proof-read by an LLM.\n<br />Details at end.</p>\n\n<p>After exploring SIMD vectorisation over the last <a href="https://xania.org/202512/20-simd-city">couple</a> of <a href="https://xania.org/202512/21-vectorising-floats">days</a>, let\'s shift gears to look at another class of compiler cleverness: memory access patterns. String comparisons seem straightforward enough - check the length, compare the bytes, done. But watch what Clang does when comparing against compile-time constants, and you\'ll see some rather clever tricks involving overlapping memory reads and bitwise operations. What looks like it should be a call to <code>memcmp</code> becomes a handful of inline instructions that exploit the fact that the comparison value is known at compile time<sup id="fnref:gcc"><a class="footnote-ref" href="https://xania.org/feed#fn:gcc">1</a></sup>.</p>\n\n<p>I\'ve set up nine functions that each compare a <code>std::string_view</code> against a constant string of increasing length, from one to nine characters. This gives us a chance to see how the compiler\'s approach changes based on the length of the comparison.</p>\n\n<p>As we learned when looking at <a href="https://xania.org/202512/16-calling-conventions">calling conventions</a>, a <code>std::string_view</code> is a pointer and a length, passed in two registers on x86 Linux. Each of these functions receives a <code>std::size_t</code> length in <code>rdi</code> and a <code>const char *</code> pointer in <code>rsi</code><sup id="fnref:yes"><a class="footnote-ref" href="https://xania.org/feed#fn:yes">2</a></sup>. One might reasonably expect a call to <code>memcmp</code>, but the compiler has both <a href="https://xania.org/202512/17-inlining-the-ultimate-optimisation">inlined</a> and specialised the comparison for each constant string. Let\'s take a look at some of these comparison functions, starting with <code>t1</code>:</p>\n\n<div class="codehilite"><pre><span></span><code><span class="nl">t1:</span>\n<span class="w">  </span><span class="nf">cmp</span><span class="w"> </span><span class="no">rdi</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w">                </span><span class="c1">; is length 1?</span>\n<span class="w">  </span><span class="nf">jne</span><span class="w"> </span><span class="no">.LBB0_1</span><span class="w">               </span><span class="c1">; if not 1, goto "return false"</span>\n<span class="w">  </span><span class="nf">cmp</span><span class="w"> </span><span class="no">byte</span><span class="w"> </span><span class="no">ptr</span><span class="w"> </span><span class="p">[</span><span class="no">rsi</span><span class="p">],</span><span class="w"> </span><span class="mi">65</span><span class="w">    </span><span class="c1">; is the byte 65 (\'A\')?</span>\n<span class="w">  </span><span class="nf">sete</span><span class="w"> </span><span class="no">al</span><span class="w">                   </span><span class="c1">; set result to 0 or 1 accordingly</span>\n<span class="w">  </span><span class="nf">ret</span><span class="w">                       </span><span class="c1">; return</span>\n<span class="nl">.LBB0_1:</span>\n<span class="w">  </span><span class="nf">xor</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="no">eax</span><span class="w">              </span><span class="c1">; set result to false</span>\n<span class="w">  </span><span class="nf">ret</span><span class="w">                       </span><span class="c1">; return</span>\n</code></pre></div>\n\n\n<p>We see the length is checked first, and if it\'s not 1, then we return. Otherwise, we check the one character to see if it\'s <code>A</code> or not, and then set the return value accordingly. The compiler has used a conditional set <code>sete</code> instruction to avoid a second branch.</p>\n\n<p>The pattern holds for power-of-two sizes: Looking at <code>t2</code>, <code>t4</code> and <code>t8</code> we see that the compiler does the same length check, and then cleverly realises it can compare a 2, 4 or 8-byte value directly with a constant of either <code>AB</code>, <code>ABCD</code> or <code>ABCDEFGH</code> (mouse over the constants in the view to see Compiler Explorer interpret them as ASCII).</p>\n\n<p>Things get more interesting with the 7 character case, <code>t7</code>:</p>\n\n<div class="codehilite"><pre><span></span><code><span class="nl">t7:</span>\n<span class="w">  </span><span class="nf">cmp</span><span class="w"> </span><span class="no">rdi</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="w">                    </span><span class="c1">; is length 7?</span>\n<span class="w">  </span><span class="nf">jne</span><span class="w"> </span><span class="no">.LBB6_1</span><span class="w">                   </span><span class="c1">; if not, goto "return false"</span>\n<span class="w">  </span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">1145258561</span><span class="w">           </span><span class="c1">; set eax to "ABCD"</span>\n<span class="w">  </span><span class="nf">xor</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="no">dword</span><span class="w"> </span><span class="no">ptr</span><span class="w"> </span><span class="p">[</span><span class="no">rsi</span><span class="p">]</span><span class="w">      </span><span class="c1">; eax ^= first four chars of sv</span>\n<span class="w">  </span><span class="nf">mov</span><span class="w"> </span><span class="no">ecx</span><span class="p">,</span><span class="w"> </span><span class="mi">1195787588</span><span class="w">           </span><span class="c1">; set ecx to "DEFG"</span>\n<span class="w">  </span><span class="nf">xor</span><span class="w"> </span><span class="no">ecx</span><span class="p">,</span><span class="w"> </span><span class="no">dword</span><span class="w"> </span><span class="no">ptr</span><span class="w"> </span><span class="p">[</span><span class="no">rsi</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">  </span><span class="c1">; ecx ^= chars 3,4,5,6 of sv</span>\n<span class="w">  </span><span class="nf">or</span><span class="w"> </span><span class="no">ecx</span><span class="p">,</span><span class="w"> </span><span class="no">eax</span><span class="w">                   </span><span class="c1">; ecx |= eax</span>\n<span class="w">  </span><span class="nf">sete</span><span class="w"> </span><span class="no">al</span><span class="w">                       </span><span class="c1">; result = 1 if "zero flag" else 0</span>\n<span class="w">  </span><span class="nf">ret</span><span class="w">                           </span><span class="c1">; return</span>\n</code></pre></div>\n\n\n<p>The check for the length is the same as the other cases, but once we know we\'re going to be comparing 7 bytes, some cunning tricks come into play. First, the compiler isn\'t directly comparing, as you might expect: It uses the fact that XORing identical values will result in a zero. Secondly, it has used two <em>overlapping</em> reads - reading bytes 0,1,2,3 and then 3,4,5,6. The redundant read of byte 3 doesn\'t matter, but doing two 32-bit reads is cheaper than having to read individual bytes.</p>\n\n<p>Once the two XORs have happened, we have "zero only if first four bytes match ABCD" in <code>eax</code> and "zero only if bytes 3,4,5,6 match DEFG" in <code>ecx</code>. Simply logical-ORing the two together gives us zero if and only if both were zero - only if all bytes matched. Then a simple <code>sete</code> turns the "zero flag" into either 0 or 1 for the <code>true</code>/<code>false</code> return value needed. Cute!</p>\n\n<p>This optimisation works well on x86 as reading unaligned 32-bit values is free. You can play around with the compiler choice and see what neat tricks are conjured up by different compilers and architecture choices.</p>\n\n<p>And that\'s what makes modern compilers remarkable - all this cleverness is conjured up from a simple <code>sv == "ABCDEFG"sv</code>. The overlapping reads, the XOR operations, the branchless conditionals - they\'re all applied automatically. Your job is to write clear code; the compiler\'s job is to make it fast. Leave it to do its thing, and try not to get in its way!</p>\n\n<p><em>See <a href="https://youtu.be/kXmqwJoaapg">the video</a> that accompanies this post.</em></p>\n\n<hr />\n\n<p><em>This post is day 22 of <a href="https://xania.org/AoCO2025-archive">Advent of Compiler Optimisations 2025</a>,\na 25-day series exploring how compilers transform our code.</em></p>\n\n<p><em>← <a href="https://xania.org/202512/21-vectorising-floats">When SIMD Fails: Floating Point Associativity</a> | <a href="https://xania.org/202512/23-switching-it-up">Switching it up a bit</a> →</em></p>\n\n<p><em>This post was written by a human (<a href="https://xania.org/MattGodbolt">Matt Godbolt</a>) and reviewed and proof-read by LLMs and humans.</em></p>\n\n<p><em>Support Compiler Explorer on <a href="https://patreon.com/c/mattgodbolt">Patreon</a>\nor <a href="https://github.com/sponsors/compiler-explorer">GitHub</a>,\nor by buying CE products in the <a href="https://shop.compiler-explorer.com">Compiler Explorer Shop</a></em>.</p>\n\n<div class="footnote">\n<hr />\n<ol>\n<li id="fn:gcc">\n<p>GCC generates more obvious, but slightly worse code, with some unnecessary logic operations. I <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=122315">filed a bug</a> to investigate.\xa0<a class="footnote-backref" href="https://xania.org/feed#fnref:gcc" title="Jump back to footnote 1 in the text">↩</a></p>\n</li>\n<li id="fn:yes">\n<p>libstdc++\'s <code>std::string_view</code> is defined as <a href="https://gcc.gnu.org/onlinedocs/gcc-15.2.0/libstdc++/api/a00227_source.html#l00102">length then pointer</a>, which is why we see length in <code>rdi</code> before pointer in <code>rsi</code>.\xa0<a class="footnote-backref" href="https://xania.org/feed#fnref:yes" title="Jump back to footnote 2 in the text">↩</a></p>\n</li>\n</ol>\n</div>'}

---

*抓取时间: 2026-02-06 06:02:40*
