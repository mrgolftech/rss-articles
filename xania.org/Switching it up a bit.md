# Switching it up a bit

**来源:** [xania.org](https://xania.org)
**发布时间:** 
**链接:** http://xania.org/202512/23-switching-it-up?utm_source=feed&utm_medium=rss

---

{'type': 'application/xhtml+xml', 'language': 'en-GB', 'base': 'https://xania.org/feed', 'value': '<p class="ai-disclaimer">Written by me, proof-read by an LLM.\n<br />Details at end.</p>\n\n<p>The standard wisdom is that switch statements compile to jump tables. And they do - when the compiler can\'t find something cleverer to do instead.</p>\n\n<p>Let\'s start with a really simple example:</p>\n\n<p>Here the compiler has spotted the relationship between <code>x</code> and the return value, and rewritten the code as: <code>if (x &lt; 5) return (x+1) * 100; else return 0;</code> - pretty neat. No jump table, just maths!</p>\n\n<p>If we mix up the code a bit so there\'s no obvious relationship between the input and the return value:</p>\n\n<p>Still no jump table: Now the compiler has built a bespoke lookup table (<code>CSWTCH.1</code>) and then uses <code>x</code> to index into it (after checking it\'s in bounds).</p>\n\n<p>For "dense" case statements, like the ones above, the compiler can be smart. But even with relatively sparse inputs, the compiler can work its magic. Consider this "is it whitespace?" routine<sup id="fnref:isspc"><a class="footnote-ref" href="https://xania.org/feed#fn:isspc">1</a></sup>:</p>\n\n<p>That <em>still</em> avoids any kind of jump table; and in fact even avoids a branch:</p>\n\n<div class="codehilite"><pre><span></span><code><span class="nf">is_whitespace</span><span class="p">(</span><span class="no">char</span><span class="p">):</span>\n<span class="w">  </span><span class="nf">sub</span><span class="w"> </span><span class="no">edi</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="w">            </span><span class="c1">; edi = x - 9 (`\\t`)</span>\n<span class="w">  </span><span class="nf">mov</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">8388631</span><span class="w">      </span><span class="c1">; eax = 0b100000000000000000010111</span>\n<span class="w">  </span><span class="nf">bt</span><span class="w"> </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="no">rdi</span><span class="w">           </span><span class="c1">; test bit edi in the eax bitmask</span>\n<span class="w">  </span><span class="nf">setc</span><span class="w"> </span><span class="no">al</span><span class="w">               </span><span class="c1">; al = (bit was set) ? 1 : 0</span>\n<span class="w">  </span><span class="nf">xor</span><span class="w"> </span><span class="no">edx</span><span class="p">,</span><span class="w"> </span><span class="no">edx</span><span class="w">          </span><span class="c1">; edx = 0</span>\n<span class="w">  </span><span class="nf">cmp</span><span class="w"> </span><span class="no">dil</span><span class="p">,</span><span class="w"> </span><span class="mi">24</span><span class="w">           </span><span class="c1">; compare edi with 24</span>\n<span class="w">  </span><span class="nf">cmovnb</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="no">edx</span><span class="w">       </span><span class="c1">; replace al with edx (0) if not below</span>\n<span class="w">  </span><span class="nf">ret</span><span class="w">                   </span><span class="c1">; return</span>\n</code></pre></div>\n\n\n<p>The compiler has built a bitmask where each bit says "should we consider this character to be whitespace". To fit the range of bits needed to cover all the whitespace characters, the compiler indexes into the bitmask with <code>(x - 9)</code>. The bit test instruction (<a href="https://www.felixcloutier.com/x86/bt"><code>bt</code></a>) will test any bit position, but our 32-bit bitmask only has meaningful data in positions 0-31. The compiler checks that <code>(x - 9) &lt;= 24</code> to ensure we\'re within the valid range <sup id="fnref:wrap"><a class="footnote-ref" href="https://xania.org/feed#fn:wrap">2</a></sup> of the bitmask (covering tab at position 0 through space at position 23), and replaces the result with 0 for anything outside this range.</p>\n\n<p>Just to see what else the compiler can generate, let\'s take a look at both a dense and sparse example that the compiler can\'t replace with a table (you\'ll need to scroll around in the Compiler Explorer panes to see more):</p>\n\n<p>For the dense case, the compiler does make a jump table, and indexes by <code>x</code> to jump to the right <code>func</code> routine<sup id="fnref:fall"><a class="footnote-ref" href="https://xania.org/feed#fn:fall">3</a></sup>. For the sparse case, the compiler has to fall back to essentially a set of <code>if()</code> statements, comparing and branching. However, it\'s clever enough to compare a "mid-range" value first (<code>2511</code>), and if the <code>x</code> value is greater, jumps to code that only looks at the <code>5284</code> and <code>4865</code>. So it\'s essentially a binary serarch tree of comparisons.</p>\n\n<p>Different compilers employ quite different tricks, so take some time to see what clang does for all the above examples.</p>\n\n<p>Write clear switch statements; let the compiler decide whether that means multiplication, bitmasks, or jump tables. It\'s pretty darned good at it!</p>\n\n<p><em>See <a href="https://youtu.be/aSljdPafBAw">the video</a> that accompanies this post.</em></p>\n\n<hr />\n\n<p><em>This post is day 23 of <a href="https://xania.org/AoCO2025-archive">Advent of Compiler Optimisations 2025</a>,\na 25-day series exploring how compilers transform our code.</em></p>\n\n<p><em>← <a href="https://xania.org/202512/22-memory-cunningness">Clever memory tricks</a> | <a href="https://xania.org/202512/24-cunning-clang">When compilers surprise you</a> →</em></p>\n\n<p><em>This post was written by a human (<a href="https://xania.org/MattGodbolt">Matt Godbolt</a>) and reviewed and proof-read by LLMs and humans.</em></p>\n\n<p><em>Support Compiler Explorer on <a href="https://patreon.com/c/mattgodbolt">Patreon</a>\nor <a href="https://github.com/sponsors/compiler-explorer">GitHub</a>,\nor by buying CE products in the <a href="https://shop.compiler-explorer.com">Compiler Explorer Shop</a></em>.</p>\n\n<div class="footnote">\n<hr />\n<ol>\n<li id="fn:isspc">\n<p>Of course you should use <code>isspace()</code>.\xa0<a class="footnote-backref" href="https://xania.org/feed#fnref:isspc" title="Jump back to footnote 1 in the text">↩</a></p>\n</li>\n<li id="fn:wrap">\n<p>The <code>bt</code> instruction uses the bit position modulo the operand size. In this particular case the compiler emits a <code>bt rax, rdi</code> so values of (x-9) greater than 64 would potentially map onto some of the set bits.\xa0<a class="footnote-backref" href="https://xania.org/feed#fnref:wrap" title="Jump back to footnote 2 in the text">↩</a></p>\n</li>\n<li id="fn:fall">\n<p>If you comment out the <code>case 4</code>, at least for GCC, you\'ll see the compiler goes back to compare-and-branch.\xa0<a class="footnote-backref" href="https://xania.org/feed#fnref:fall" title="Jump back to footnote 3 in the text">↩</a></p>\n</li>\n</ol>\n</div>'}

---

*抓取时间: 2026-02-06 06:02:40*
