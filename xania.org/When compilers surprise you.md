# When compilers surprise you

**来源:** [xania.org](https://xania.org)
**发布时间:** 
**链接:** http://xania.org/202512/24-cunning-clang?utm_source=feed&utm_medium=rss

---

{'type': 'application/xhtml+xml', 'language': 'en-GB', 'base': 'https://xania.org/feed', 'value': '<p class="ai-disclaimer">Written by me, proof-read by an LLM.\n<br />Details at end.</p>\n\n<p>Every now and then a compiler will surprise me with a really smart trick. When I first saw this optimisation I could hardly believe it. I was looking at loop optimisation, and wrote something like this simple function that sums all the numbers up to a given value:</p>\n\n<p>So far so decent: GCC has done some preliminary checks, then fallen into a loop that efficiently sums numbers using <code>lea</code> (we\'ve <a href="https://xania.org/202512/02-adding-integers">seen this before</a>). But taking a closer look at the loop we see something unusual:</p>\n\n<div class="codehilite"><pre><span></span><code><span class="nl">.L3:</span>\n<span class="w">  </span><span class="nf">lea</span><span class="w"> </span><span class="no">edx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">rdx</span><span class="err">+</span><span class="mi">1</span><span class="err">+</span><span class="no">rax</span><span class="p">*</span><span class="mi">2</span><span class="p">]</span><span class="w">        </span><span class="c1">; result = result + 1 + x*2</span>\n<span class="w">  </span><span class="nf">add</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w">                    </span><span class="c1">; x += 2</span>\n<span class="w">  </span><span class="nf">cmp</span><span class="w"> </span><span class="no">edi</span><span class="p">,</span><span class="w"> </span><span class="no">eax</span><span class="w">                  </span><span class="c1">; x != value</span>\n<span class="w">  </span><span class="nf">jne</span><span class="w"> </span><span class="no">.L3</span><span class="w">                       </span><span class="c1">; keep looping</span>\n</code></pre></div>\n\n\n<p>The compiler has cleverly realised it can do two numbers<sup id="fnref:check"><a class="footnote-ref" href="https://xania.org/feed#fn:check">1</a></sup> at a time using the fact it can see we\'re going to add <code>x</code> <em>and</em> <code>x + 1</code>, which is the same as adding <code>x*2 + 1</code>. Very cunning, I think you\'ll agree!</p>\n\n<p>If you turn the optimiser up to <code>-O3</code> you\'ll see the compiler works even harder to vectorise the loop using parallel adds. All very clever.</p>\n\n<p>This is all for GCC. Let\'s see what clang does with our code:</p>\n\n<p>This is where I nearly fell off my chair: <strong>there is no loop</strong>! Clang checks for positive <code>value</code>, and if so it does:</p>\n\n<div class="codehilite"><pre><span></span><code><span class="w">  </span><span class="nf">lea</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">rdi</span><span class="w"> </span><span class="p">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w">        </span><span class="c1">; eax = value - 1</span>\n<span class="w">  </span><span class="nf">lea</span><span class="w"> </span><span class="no">ecx</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">rdi</span><span class="w"> </span><span class="p">-</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w">        </span><span class="c1">; ecx = value - 2</span>\n<span class="w">  </span><span class="nf">imul</span><span class="w"> </span><span class="no">rcx</span><span class="p">,</span><span class="w"> </span><span class="no">rax</span><span class="w">             </span><span class="c1">; rcx = (value - 1) * (value - 2)</span>\n<span class="w">  </span><span class="nf">shr</span><span class="w"> </span><span class="no">rcx</span><span class="w">                   </span><span class="c1">; rcx &gt;&gt;= 1</span>\n<span class="w">  </span><span class="nf">lea</span><span class="w"> </span><span class="no">eax</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="no">rdi</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="no">rcx</span><span class="p">]</span><span class="w">      </span><span class="c1">; eax = value + rcx</span>\n<span class="w">  </span><span class="nf">dec</span><span class="w"> </span><span class="no">eax</span><span class="w">                   </span><span class="c1">; --eax</span>\n<span class="w">  </span><span class="nf">ret</span>\n</code></pre></div>\n\n\n<p>It was not at all obvious to me what on earth was going on here. By backing out the maths a little, this is equivalent to:</p>\n\n<div class="codehilite"><pre><span></span><code>v + ((v - 1)(v - 2) / 2) - 1;\n</code></pre></div>\n\n\n<p>Expanding the parentheses:</p>\n\n<div class="codehilite"><pre><span></span><code>v + (v² - 2v - v + 2) / 2 - 1\n</code></pre></div>\n\n\n<p>Rearranging a bit:</p>\n\n<div class="codehilite"><pre><span></span><code>(v² - 3v + 2) / 2 + (v - 1)\n</code></pre></div>\n\n\n<p>Multiplying the <code>(v - 1)</code> by 2 / 2:</p>\n\n<div class="codehilite"><pre><span></span><code>(v² - 3v + 2) / 2 + (2v - 2)/2\n</code></pre></div>\n\n\n<p>Combining those and cancelling:</p>\n\n<div class="codehilite"><pre><span></span><code>(v² - v) / 2\n</code></pre></div>\n\n\n<p>Simplifying and factoring gives us <code>v(v - 1) / 2</code> which is the closed-form solution to the "sum of integers"! Truly amazing<sup id="fnref:why"><a class="footnote-ref" href="https://xania.org/feed#fn:why">2</a></sup> - we\'ve gone from an O(n) algorithm as written, to an O(1) one!</p>\n\n<p>I love that despite working with compilers for more than twenty years, they can still surprise and delight me. The years of experience and work that have been poured into making compilers great is truly humbling, and inspiring.</p>\n\n<p>We\'re nearly at the end of this series - there\'s so much more to say but that will have to wait for another time. Tomorrow will be a little different: see you then!</p>\n\n<p><em>See <a href="https://youtu.be/V9dy34slaxA">the video</a> that accompanies this post.</em></p>\n\n<hr />\n\n<p><em>This post is day 24 of <a href="https://xania.org/AoCO2025-archive">Advent of Compiler Optimisations 2025</a>,\na 25-day series exploring how compilers transform our code.</em></p>\n\n<p><em>← <a href="https://xania.org/202512/23-switching-it-up">Switching it up a bit</a> | <a href="https://xania.org/202512/25-thank-you">Thank you</a> →</em></p>\n\n<p><em>This post was written by a human (<a href="https://xania.org/MattGodbolt">Matt Godbolt</a>) and reviewed and proof-read by LLMs and humans.</em></p>\n\n<p><em>Support Compiler Explorer on <a href="https://patreon.com/c/mattgodbolt">Patreon</a>\nor <a href="https://github.com/sponsors/compiler-explorer">GitHub</a>,\nor by buying CE products in the <a href="https://shop.compiler-explorer.com">Compiler Explorer Shop</a></em>.</p>\n\n<div class="footnote">\n<hr />\n<ol>\n<li id="fn:check">\n<p>Some of the initial code checks for odd/even and accounts accordingly.\xa0<a class="footnote-backref" href="https://xania.org/feed#fnref:check" title="Jump back to footnote 1 in the text">↩</a></p>\n</li>\n<li id="fn:why">\n<p>Why does the compiler emit this exact sequence and not a slightly more straightforward sequence? I think it\'s partly avoiding overflow in cases where it might otherwise overflow <em>and</em> just a side effect of the way clang tracks and infers <a href="https://xania.org/202512/09-induction-variables">induction variables</a>. I really don\'t know for sure, though.\xa0<a class="footnote-backref" href="https://xania.org/feed#fnref:why" title="Jump back to footnote 2 in the text">↩</a></p>\n</li>\n</ol>\n</div>'}

---

*抓取时间: 2026-02-06 06:02:40*
